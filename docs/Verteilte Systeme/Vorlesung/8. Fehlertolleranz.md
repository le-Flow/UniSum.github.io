### 1. Grundlagen: Verlässlichkeit und Terminologie

Fehlertoleranz ist ein Aspekt der **Verlässlichkeit (Dependability)**. Diese beschreibt, wie korrekt eine Komponente ihren Dienst erbringt, selbst wenn andere Komponenten, von denen sie abhängt, fehlerhaft sind.

* **Eigenschaften der Verlässlichkeit:**
  * **Verfügbarkeit (Availability):** Das System ist unmittelbar benutzbar.
  * **Zuverlässigkeit (Reliability):** Das System läuft fortlaufend ausfallfrei.
  * **(Funktions-)Sicherheit (Safety):** Es tritt kein katastrophaler Zustand ein.
  * **Wartbarkeit (Maintainability):** Wie leicht ein ausgefallenes System repariert werden kann.
* **Terminologie (Ursache & Wirkung):**
  * **Störung (Fault):** Die *Ursache* eines Problems (z.B. ein Programmierfehler, ein defektes Kabel).
  * **Fehler (Error):** Ein Teil des Systemzustands, der zu einem Ausfall führen *kann* (z.B. ein falscher Wert im Speicher).
  * **Ausfall (Failure):** Das System erfüllt seine Spezifikation nicht mehr (z.B. liefert ein falsches Ergebnis oder stürzt ab).
* **Strategien:**
  * **Störungsprävention (Fault Prevention):** Verhindern, dass Störungen überhaupt entstehen.
  * **Störungstoleranz (Fault Tolerance):** Die Spezifikation *trotz* Störungen erfüllen.
  * **Störungsbehebung (Fault Removal):** Die Anzahl oder Schwere von Störungen reduzieren (z.B. Debugging).

---

### 2. Fehlermodelle

Fehler werden in verschiedene Arten klassifiziert, um den Umgang mit ihnen zu modellieren.

* **Absturzausfall (Crash Failure):** Der Server stoppt, hat aber bis dahin korrekt gearbeitet.
* **Dienstausfall (Omission Failure):** Der Server reagiert nicht auf Anfragen (entweder beim Senden oder Empfangen ausgelassen).
* **Zeitbedingter Ausfall (Timing Failure):** Die Antwort des Servers liegt außerhalb des festgelegten Zeitintervalls (zu früh oder zu spät).
* **Ausfall korrekter Antwort (Response Failure):** Die Antwort des Servers ist inhaltlich falsch (falscher Wert oder falscher Zustandsübergang).
* **Byzantinischer (Zufälliger) Ausfall (Byzantine/Arbitrary Failure):** Der Server verhält sich völlig unvorhersehbar, erstellt zufällige Antworten zu zufälligen Zeiten. Dies ist der schwerwiegendste und am schwierigsten zu behandelnde Fehlertyp.
* **Wichtige Begriffe:**
  * **Fail-silent:** Ein Absturz- oder Dienstausfall. Der Client weiß nicht, was passiert ist.
  * **Fail-stop:** Ein Absturzausfall, der von anderen Prozessen (z.B. per Timeout) *erkannt werden kann*.
  * **Fail-safe:** Ein Ausfall, der "gutartig" ist und keinen Schaden anrichtet.

---

### 3. Prozessresilienz (Resilienz durch Gruppen)

Die grundlegende Strategie, um Prozesse fehlertolerant zu machen, ist die **Replikation**. Berechnungen werden auf eine Gruppe von Prozessreplikaten verteilt.

* **Flache Gruppe (Flat Group):**
  * Alle Mitglieder kommunizieren direkt miteinander (Peer-to-Peer).
  * **Vorteil:** Gut für Fehlertoleranz, da der Informationsaustausch sofort erfolgt.
  * **Nachteil:** Hoher Overhead und schwierig zu implementieren, da die Steuerung verteilt ist.
* **Hierarchische Gruppe (Hierarchical Group):**
  * Die gesamte Kommunikation läuft über einen zentralen **Koordinator**.
  * **Vorteil:** Einfach zu implementieren.
  * **Nachteil:** Nicht wirklich fehlertolerant, da der Koordinator ein **Single Point of Failure** ist.

---

### 4. Fehlermaskierung und Übereinstimmung (Konsens)

**Fehlermaskierung** bedeutet, dass eine Gruppe von Prozessen eine bestimmte Anzahl von Fehlern "verstecken" kann, sodass das System als Ganzes weiter funktioniert. Eine Gruppe, die $k$ Fehler maskieren kann, heißt **k-fehler-tolerant**.

Die zentrale Frage ist: Wie viele Replikate ($n$) braucht man, um $k$ Fehler zu tolerieren?

* **Bei Absturzausfällen (Crash Failures):**
  * Es werden **$n = k + 1$** Mitglieder benötigt.
  * *Begründung:* Wenn $k$ Prozesse ausfallen, liefert der eine verbleibende Prozess das Ergebnis.
* **Bei Byzantinischen Ausfällen (Arbitrary Failures):**
  * Hier ist eine **Abstimmung (Voting)** über das Ergebnis nötig.
  * **Fall A (mit synchronisierten Uhren):** Es werden **$n = 2k + 1$** Mitglieder benötigt.
    * *Begründung:* Die $k+1$ "loyalen" Mitglieder können die $k$ "verräterischen" Mitglieder überstimmen. (z.B. Dreifach-Modulare-Redundanz, TMR).
  * **Fall B (ohne synchronisierte Uhren / Konsensproblem):** Es werden **$n = 3k + 1$** Mitglieder benötigt.
    * *Begründung:* Dies ist das Ergebnis des **Byzantinischen Generalsproblems**. Um $k$ "Verräter" zu tolerieren, benötigt man $2k+1$ "loyale" Prozesse, um eine Mehrheit unter den Loyalen zu bilden, was eine Gesamtanzahl von $3k+1$ erfordert.
    * *Beispiel:* Um $k=1$ Verräter zu tolerieren, braucht man 4 Generäle. Mit nur 3 Generälen (2 Loyale, 1 Verräter) ist das Problem nicht lösbar, da die Loyalen nicht wissen, wer von den beiden anderen lügt.

---

### 5. Ausfallerkennung (Fault Detection)

Um auf Fehler reagieren zu können, müssen sie erkannt werden. Dies geschieht typischerweise über Timeouts.

* **Pull (Ping / Probe):** Prozess A sendet "Bist du aktiv?"-Nachrichten an Prozess B und erwartet eine Antwort.
* **Push (Heartbeat):** Prozess B sendet periodisch "Ich bin aktiv"-Nachrichten an Prozess A.
* **Problem:** In unzuverlässigen oder langsamen Netzwerken kann ein Timeout ablaufen, obwohl der Prozess gar nicht ausgefallen ist (ein **falsch-positiv**).

---

### 6. Verlässliche Kommunikation (RPC)

Neben Prozessen können auch Kommunikationskanäle ausfallen. Bei RPCs (Remote Procedure Calls) können 5 Hauptprobleme auftreten:

1.  **Client findet Server nicht:** Einfach, dem Client wird ein Fehler gemeldet.
2.  **Anfrage des Clients geht verloren:** Einfach, der Client sendet die Anfrage nach einem Timeout erneut.
3.  **Server stürzt ab:** **Schwierig**. Der Client weiß nicht, ob der Server die Operation *vor* oder *nach* dem Absturz ausgeführt hat.
4.  **Antwort des Servers geht verloren:** **Schwierig**. Der Client erhält keine Antwort und weiß nicht, ob der Server (Fall 3) oder nur die Antwort verloren ging.
5.  **Client stürzt ab:** **Schwierig**. Der Server führt eine Operation aus, deren Ergebnis niemand mehr abholt. Dies wird als **Waisenberechnung (Orphan Computation)** bezeichnet.

* **RPC-Semantiken (Umgang mit Fall 3 & 4):**
  * **Mindestens-einmal-Semantik (At-least-once):** Der Client sendet die Anfrage so lange, bis er eine Antwort erhält. Garantiert, dass die Operation ausgeführt wird. *Risiko: Mehrfache Ausführung.*
  * **Höchstens-einmal-Semantik (At-most-once):** Garantiert, dass eine Operation nicht mehrfach ausgeführt wird. *Risiko: Keine Ausführung*, wenn die Antwort verloren geht und der Client nicht erneut sendet.
* **Lösung für verlorene Antworten (Fall 4):** Wenn eine Operation **idempotent** ist (d.h. sie kann mehrfach ausgeführt werden, ohne Schaden anzurichten, z.B. das Lesen eines Kontostands), kann der Client die Anfrage einfach erneut senden.