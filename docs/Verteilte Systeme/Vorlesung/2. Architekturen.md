### 1. Wichtige Architekturstile

Architekturstile helfen, die Komplexität von Verteilten Systemen durch bewährte Muster beherrschbar zu machen. Die drei wichtigsten Stile sind:

* **Geschichtete Architekturen**
* **Serviceorientierte Architekturen (SOAs)**
* **Publish-Subscribe Architekturen**

(Veraltete, objektbasierte Modelle wie CORBA sind heute nahezu bedeutungslos.)

---

###  LAYER 2. Geschichtete Architekturen

Bei diesem Stil werden Komponenten in Schichten (Layern) organisiert. Eine Schicht $N$ bietet der Schicht $N+1$ einen Dienst über eine Schnittstelle an und nutzt selbst die Dienste der Schicht $N-1$.

* **Varianten:**
    * **Reine Schichtenarchitektur:** Nur "Downcalls" zur nächsttieferen Schicht.
    * **Architektur mit Upcalls:** Erlaubt auch Aufrufe in die höhere Schicht.
    * **Gemischte Architektur:** Schicht $N$ darf auch Schichten $N-K$ (mit $K > 1$) direkt ansprechen.
* **Beispiel Kommunikationsprotokolle:** Schicht $N$ auf Maschine A kommuniziert logisch mit Schicht $N$ auf Maschine B über ein festgelegtes **Protokoll**. Physisch nutzt sie dazu die Dienste von Schicht $N-1$.
* **Anwendungsebenen:** Auf der Anwendungsebene wird oft eine 3-stufige Schichtung verwendet:
    1.  **Anwendungsschnittstellenebene** (User-interface level)
    2.  **Verarbeitungsebene** (Processing level)
    3.  **Datenebene** (Data level)

---

### 3. Service-Orientierte Architekturen (SOAs)

SOAs bestehen aus einer losen Organisation von unabhängigen Einheiten (Services, Objekte oder Microservices), die miteinander kommunizieren.

* **Objektbasiert:** Ein Ansatz, bei dem Objekte ihren Zustand kapseln und über öffentliche Methoden eine Schnittstelle anbieten.
* **Entfernte Objekte:** Für die Kommunikation mit entfernten Objekten wird oft ein **Proxy** (auch client-side stub) auf der Client-Seite und ein **Skeleton** (auch server-side stub) auf der Server-Seite verwendet.
    * Der **Client** ruft eine Methode am lokalen **Proxy** auf.
    * Der Proxy verpackt den Aufruf ("marshalling") und sendet ihn über das Netzwerk.
    * Das **Skeleton** empfängt die Nachricht, entpackt sie und ruft die eigentliche Methode am **Objekt** auf dem Server auf.
* **Microservice Architektur:** Eine sehr populäre Form der SOA, bei der jeder Dienst als separater Prozess läuft und als Ganzes gekapselt ist. Dies fördert die Modularisierung und Innovation.

---

### 4. Publish-Subscribe Architekturen

Das definierende Merkmal dieses Stils ist die Trennung von Verarbeitung (Processing) und Koordination (Coordination) ohne direkte Referenzen. Komponenten kommunizieren nicht direkt, sondern über ein zwischengeschaltetes System.

* **Koordinierungsformen:**
    * **Referentiell gekoppelt:** Direkte Kommunikation oder über eine Mailbox (zeitlich entkoppelt).
    * **Referentiell entkoppelt:** Kommunikation, ohne dass sich die Partner kennen. Dies ist die Basis für Pub-Sub.
        * **Event-basiert:** (z.B. über einen Event-Bus)
        * **Gemeinsamer Datenraum** (Shared Data Space)
* **Stile:**
    * **Content-based:** Abonnenten filtern Nachrichten basierend auf deren Inhalt.
    * **Topic-based:** Abonnenten "abonnieren" ein bestimmtes Thema (Topic), und Publisher senden Nachrichten an dieses Topic.
* **Broker:** Oft wird ein **Broker** (Vermittler) eingesetzt, der die Kommunikation (z.B. Message Routing) zwischen Publishern und Subscribern erleichtert.
* **Populäre Plattformen:**
    * **Apache Kafka:** Verteilte Event-Streaming-Plattform, optimiert für **hohen Durchsatz** und Dauerhaftigkeit (Speicherung auf Festplatte).
    * **ZeroMQ (0MQ):** Leichtgewichtige Bibliothek (kein zentraler Broker), optimiert für **geringe Latenz** und direkte Knoten-Kommunikation.
    * **MQTT:** LeichtgewichtigeS Nachrichtenprotokoll (Topic-basiert mit Broker), optimiert für **geringen Aufwand** und Zuverlässigkeit (3 QoS-Stufen). Sehr populär im IoT-Bereich.

---

### 5. Entwurfsmuster für Verteilte Systeme

Neben den Architekturstilen gibt es bewährte Entwurfsmuster (Patterns) für den Aufbau von Verteilten Systemen.

* **Middleware**
    * **Analogie:** Middleware verhält sich zum Verteilten System wie ein Betriebssystem zur Hardware.
    * **Zweck:** Sie bildet eine Abstraktionsschicht über den lokalen Betriebssystemen und dem Netzwerk.
    * **Funktionen:** Bietet eine **gleiche Schnittstelle** für alle Anwendungen, Mechanismen zur Kommunikation, Sicherheit, Fehler-Maskierung und Buchführung.
    * **Vorteile:** Sorgt für **Portabilität** (über HW/SW-Grenzen) und **Interoperabilität** (zwischen Plattformen).
    * **Mechanismen:** Nutzt oft das **Adapter-** oder **Interceptor-Pattern**.
* **Geschichtete Architekturen (Client-Server)**
    * **Server:** Bietet Dienste im Zusammenhang mit einer geteilten Ressource an (z.B. Datenbank, Dateisystem, Web-Dokumente).
    * **Client:** Greift auf die Server-Dienste zu, z.B. über eine Programmierschnittstelle oder eine Benutzeroberfläche.
    * **Mehrstufige (Multi-Tier) Architekturen:** Die logischen Schichten (UI, Processing, Data) werden auf verschiedene physische Maschinen (Client und Server) verteilt.
        * Beispiel (d): Bankanwendung, UI auf Client, Application + Database auf Server.
        * Beispiel (e): Typische Browser-Anwendung, UI + Application auf Client (Browser), Database auf Server, plus evtl. lokaler Cache (Database) auf Client.

---

### 6. Symmetrische Verteilte Architekturen

Im Gegensatz zu Client-Server-Systemen (vertikale Verteilung) basieren symmetrische Architekturen auf einer horizontalen Verteilung.

* **Horizontale Verteilung:** Logisch äquivalente Teile des Systems sind über Rechner verteilt. Jeder Teil arbeitet auf einem Teil der gesamten Datenmenge, was zu einer natürlichen Lastverteilung führt.
* **Peer-to-Peer (P2P) Systeme**
    * **Definition:** Eine besondere Klasse symmetrischer Systeme, bei der die Interaktion symmetrisch ist. Es gibt keine festen Clients oder Server; jeder Rechner ist beides.
    * **Kategorien:**
        1.  **Strukturiert:** Basiert auf einem Overlay-Netzwerk mit einer bestimmten Topologie (z.B. Ring, Baum).
        2.  **Unstrukturiert:** Kein vordefiniertes Overlay-Netzwerk.
* **Beispiel: Chord**
    * Ein **strukturiertes** P2P-System mit einer **Ring-Topologie**.
    * Implementiert eine **verteilte Hashtabelle (DHT)**.
    * Ein Datenelement mit Schlüssel $k$ wird dem Knoten $succ(k)$ zugeordnet (der Knoten mit der kleinsten ID, die $\ge k$ ist).
* **Beispiel: Facebook's Cassandra**
    * Ein **strukturiertes Peer-to-Peer Storage System**.
    * Bietet extrem hohe Schreibraten und konfigurierbare Konsistenzlevel.