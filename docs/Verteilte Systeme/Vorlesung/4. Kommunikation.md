### 1. Grundlagen der Kommunikation

Kommunikation in verteilten Systemen basiert auf Protokollschichten. Während das 7-schichtige OSI-Referenzmodell als theoretisches Modell dient, wird in der Praxis meist TCP/IP oder UDP/IP verwendet. Für verteilte Systeme ist ein angepasstes Modell oft nützlicher.

* **Angepasstes Referenzmodell:** Eine vereinfachte Schichtung:
    1.  **Hardware** (Physical/Link-level protocol)
    2.  **Operating System** (Host-to-host protocol, z.B. TCP/IP)
    3.  **Middleware** (Middleware protocol)
    4.  **Application** (Application protocol)
* **Middleware-Protokolle:** Diese Schicht stellt die eigentlichen Kommunikationsdienste für verteilte Anwendungen bereit, z.B. RPC, Authentifizierung, verteilte Sperren oder DNS.
* **Kommunikationsdienste der Middleware:**
    * **Persistent vs. Transient:**
        * **Persistent:** Die Nachricht wird von der Middleware gespeichert (store-and-forward), bis sie erfolgreich zugestellt wird (z.B. E-Mail).
        * **Transient:** Die Nachricht wird nur gespeichert, solange Sender und Empfänger aktiv sind (z.B. TCP).
    * **Synchrone vs. Asynchrone Kommunikation:**
        * **Synchron:** Der Sender blockiert, bis seine Anfrage verarbeitet wurde. Dies kann an drei Punkten geschehen: bei der *Anforderungs-Übermittlung* (request submission), bei der *Anforderungs-Zustellung* (request delivery) oder nach der *Verarbeitung durch den Server*.
        * **Asynchron:** Der Sender blockiert nicht (oder nur sehr kurz).

---

### 2. Remote Procedure Call (RPC)

RPC ist eine Kerntechnologie, um **Zugriffstransparenz** zu erreichen. Die Idee ist, einen Aufruf an eine Prozedur auf einem entfernten Rechner (Server) genauso aussehen zu lassen wie einen normalen, lokalen Prozeduraufruf.

* **RPC-Ablauf (10 Schritte):**
    1.  Der Client-Prozess ruft die lokale **Client-Stub**-Funktion auf.
    2.  Der Client-Stub "verpackt" die Parameter in eine Nachricht (**Marshalling**).
    3.  Das Client-Betriebssystem sendet die Nachricht über das Netzwerk.
    4.  Das Server-Betriebssystem empfängt die Nachricht und übergibt sie an den **Server-Stub**.
    5.  Der Server-Stub "entpackt" die Parameter (**Unmarshalling**) und ruft die eigentliche, lokale Server-Prozedur auf.
    6.  Die Server-Prozedur wird ausgeführt und gibt ihr Ergebnis an den Server-Stub zurück.
    7.  Der Server-Stub verpackt das Ergebnis in eine Antwortnachricht (Marshalling).
    8.  Das Server-Betriebssystem sendet die Antwort zurück.
    9.  Das Client-Betriebssystem empfängt die Antwort und übergibt sie dem Client-Stub.
    10. Der Client-Stub entpackt das Ergebnis (Unmarshalling) und gibt es als Rückgabewert an den aufrufenden Client-Prozess zurück.
* **Herausforderung: Parameterübergabe (Marshalling):**
    * Computer haben unterschiedliche Datenrepräsentationen (z.B. **Little-Endian** vs. **Big-Endian**).
    * Marshalling wandelt daher alle Daten in ein maschinen-unabhängiges Format um, damit der Empfänger sie korrekt interpretieren kann.
* **Herausforderung: Pointer / Referenzen:**
    * Speicheradressen (Pointer) haben nur lokale Bedeutung und können nicht über das Netzwerk gesendet werden.
    * **Lösung 1:** Das referenzierte Objekt wird kopiert (meist nur "shallow copy") und auf dem Server eine Referenz auf die Kopie verwendet. Bei Objekten nennt man dies **Serialisierung** und **Deserialisierung**.
    * **Lösung 2:** Es werden globale Referenzen wie URIs verwendet.

---

### 3. RPC Implementierung und Varianten

Um die RPC-Komplexität zu verbergen, werden Stubs meist automatisch generiert. Außerdem kann das blockierende Verhalten von RPCs angepasst werden.

* **Stub-Generierung:**
    * Stubs werden nicht manuell geschrieben, sondern von einem **Stub-Compiler** automatisch generiert.
    * Als Eingabe dient eine **Interface Definition Language (IDL)**-Datei, welche die Prozeduren, Parameter und Rückgabetypen maschinenunabhängig beschreibt.
    * Populäre IDLs sind **Google Protobufs** und **Apache Thrift**.
* **Synchrone vs. Asynchrone RPCs:**
    * **Synchron (Standard):** Der Client ruft die Prozedur auf und **blockiert** (wartet), bis der Server die Ausführung beendet hat und das Ergebnis (Reply) zurückschickt.
    * **Asynchron (mit ACK):** Der Client ruft auf und blockiert nur, bis der Server den Empfang der Anfrage bestätigt hat (**Acknowledge**). Der Client wartet nicht auf das Endergebnis.
    * **Deferred Synchronous RPC (mit Callback):** Der Client macht einen asynchronen Aufruf und übergibt einen **Callback-Handler**. Der Client-Stub kehrt sofort zurück. Wenn der Server später das Ergebnis hat, ruft er den Client über einen separaten RPC zurück und löst den Callback-Handler aus.

---

### 4. Nachrichtenorientierte Kommunikation

Als Alternative zu RPC (das versucht, Kommunikation zu verbergen) gibt es explizite nachrichtenorientierte Kommunikation, bei der Sender und Empfänger Nachrichten bewusst austauschen.

* **Sockets (z.B. TCP):**
    * Bietet **transiente** (nicht-persistente) und **verbindungsorientierte** Kommunikation.
    * Der Server nutzt `socket()`, `bind()`, `listen()` und blockiert bei `accept()`.
    * Der Client nutzt `socket()` und `connect()`.
    * Sobald die Verbindung steht (Synchronisationspunkt), können beide über `read()` und `write()` kommunizieren.
* **Message-Queuing (MOM - Message-Oriented Middleware):**
    * Bietet **persistente**, asynchrone Kommunikation über Warteschlangen (Queues).
    * Dies ist oft die Basis für Publish-Subscribe-Systeme.
    * **AMQP (Advanced Message Queuing Protocol):** Ein offener Standard hierfür, der auf Sicherheit und Zuverlässigkeit ausgelegt ist (eingesetzt z.B. im Finanzwesen und Telekommunikation).
* **Message Passing Interface (MPI):**
    * Eine Abstraktionsebene über Sockets, die speziell für High-Performance Computing (HPC) und wissenschaftliches Rechnen entwickelt wurde.
    * Bietet transienten Nachrichtenaustausch mit verschiedenen Synchronisationsmodi (z.B. blockierend, asynchron).

---

### 5. Multicast Kommunikation

Multicast ist der Prozess, Informationen an alle Mitglieder einer definierten Gruppe zu verteilen. Die Herausforderung ist, dies skalierbar (für tausende Knoten) und fehlertolerant (gegen Paketverlust und Knotenausfälle) zu gestalten.

* **Zentralisierter Ansatz:** Ein Sender schickt die Nachricht an alle $N$ Empfänger. Dies ist **einfach**, aber **nicht skalierbar** und langsam.
* **Baum-basierte Protokolle:**
    * Die Knoten bilden einen **Spanning Tree**. Nachrichten werden entlang des Baums verteilt.
    * Verlorene Pakete werden durch **ACKs** (Bestätigungen) oder **NAKs** (Negative Bestätigungen) "repariert".
    * **RMTP (Reliable Multicast Transport Protocol):** Verwendet ACKs.
    * **SRM (Scalable Reliable Multicast):** Verwendet NAKs, nutzt aber zufällige Verzögerungen, um "NAK-Stürme" (wenn alle gleichzeitig ein NAK senden) zu vermeiden.

---

### 6. Gossip Protokolle (Epidemischer Multicast)

Gossip ist eine populäre, dezentrale und sehr robuste Alternative für Multicast. Die Verbreitung von Nachrichten wird wie eine Epidemie modelliert.

* **Grundprinzip (Push-Gossip):**
    1.  Ein Knoten (der "infiziert" ist) möchte eine Nachricht verbreiten.
    2.  Er wählt **k zufällige** Zielknoten aus und sendet ihnen die Nachricht (per UDP).
    3.  Jeder Knoten, der die Nachricht neu empfängt, wiederholt diesen Vorgang in der nächsten "Runde".
* **Varianten:**
    * **Push-Gossip (Epidemisch):** Aktives Verbreiten (infizieren) von Nachrichten.
    * **Pull-Gossip:** Knoten fragen periodisch k zufällige Knoten, ob sie neue Nachrichten haben.
    * **Hybrid:** Eine Kombination aus beidem.
* **Analyse & Effizienz:**
    * Gossip ist **leichtgewichtig**, **sehr fehlertolerant** und **verbreitet sich schnell**.
    * Mit nur **$c \cdot log(n)$** Runden (sehr geringe Latenz) erreicht die Nachricht fast alle Knoten.
    * Die Last pro Knoten ist gering (jeder sendet nur $c \cdot k \cdot log(n)$ Nachrichten).
* **Fehlertoleranz:**
    * **Paketverlust:** Selbst bei 50% Paketverlust funktioniert das Protokoll zuverlässig, wenn man die Anzahl der Runden verdoppelt.
    * **Knotenausfall:** Selbst wenn 50% der Knoten ausfallen, funktioniert das Protokoll (mit Anpassung der Runden).
* **Topologie-Berücksichtigung:**
    * Naives Gossip (Auswahl *irgendeines* Knotens im Internet) kann Core-Router überlasten.
    * **Lösung:** Hierarchisches Gossip. Wähle zuerst ein Subnetz zufällig aus, dann einen Knoten *innerhalb* dieses Subnetzes. Dies hält die Router-Last minimal ($O(1)$).
* **Anwendung:** Gossip wird in vielen Key-Value Stores (z.B. **Cassandra**), Sensornetzen und dem Network News Transport Protocol (NNTP) verwendet.