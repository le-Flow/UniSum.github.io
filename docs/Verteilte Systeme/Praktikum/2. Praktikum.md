## Takeaway-Zusammenfassung: RPC-Wörterbuch

Dieses Projekt implementiert ein Remote-Wörterbuch mithilfe von **RPC (Remote Procedure Call)**. Das System besteht aus einem Server (`rdictd`), der die Daten hält, und einem Client (`rdict`), der Funktionen auf dem Server aufruft, als wären sie lokal.

---

## 1. Architektur & Build-Prozess

Die gesamte Architektur wird durch `rpcgen` aus einer einzigen Definitionsdatei generiert.

1.  **Definitionsdatei (`rdict.x`)**:
    * Dies ist die "Schnittstellendefinitionsdatei" (Interface Definition Language, IDL).
    * Sie legt alle Datenstrukturen (`struct upd`, `manywords`) und die Signaturen der Remote-Funktionen (`INITW`, `INSERTW`, etc.) fest.

2.  **Code-Generierung (`rpcgen`)**:
    * Das Tool `rpcgen` liest die `rdict.x`-Dateiv.
    * Es generiert automatisch die "Stub"-Dateien (Client- und Server-Stubs), die den gesamten Netzwerk-Code enthalten.
    * **Wichtige generierte Dateien**:
        * `rdict.h`: Header-Datei mit allen Definitionen.
        * `rdict_clnt.c`: Der Client-Stub. Er wandelt lokale Aufrufe in Netzwerk-Calls um.
        * `rdict_svc.c`: Der Server-Stub. Enthält die `main()`-Funktion des Servers, einen "Dispatcher" (der Aufrufe verteilt) und den Code zur Registrierung beim Portmapper.
        * `rdict_xdr.c`: Code für die XDR-Konvertierung (eXternal Data Representation), der sicherstellt, dass Daten zwischen verschiedenen Systemen korrekt serialisiert werden.

3.  **Benutzerdefinierter Code (Logik)**:
    * Dies ist der Code, den Sie schreiben. Er wird "zwischen" die Stubs eingefügt:
    * **Server-Logik (`rdict_srp.c`)**: Enthält die *tatsächliche* Implementierung der Funktionen (z.B. `insertw`, `countw`). Die Daten werden hier in einem globalen Array (`char dict[][]`) und einem Zähler (`int nwords`) gespeichert.
    * **Client-UI (`rdict.c`)**: Das `main()`-Programm des Clients, das Benutzereingaben entgegennimmt und die (scheinbar lokalen) Funktionen aufruft.
    * **Interface-Dateien (`_cif.c`, `_sif.c`)**: Diese "Klebedateien" verbinden die benutzerfreundlichen Funktionsnamen (z.B. `insertw`) mit den RPC-konformen Stub-Funktionsnamen (z.B. `insertw_1_svc`).

4.  **Kompilierung**:
    * Alle `.c`-Dateien (generierte und benutzerdefinierte) werden zu `.o`-Objektdateien kompiliert.
    * Der Linker fügt sie zu zwei finalen Programmen zusammen:
        * `rdict` (Der Client)
        * `rdictd` (Der Server-Daemon)

---

## 2. Kommunikations-Fluss

Die Client-Server-Kommunikation wird durch den **Portmapper** (auch `rpcbind` genannt) verwaltet.

1.  **Server-Start**:
    * `./rdictd` wird gestartet.
    * Die `main()`-Funktion (in `rdict_svc.c`) registriert das Programm (`RDICTPROG`) beim Portmapper des Betriebssystems und teilt ihm mit, an welchem Port es lauscht.

2.  **Client-Start & Aufruf**:
    * `./rdict` wird gestartet.
    * Der Client kontaktiert zuerst den Portmapper auf dem Server-Host (`RMACHINE`).
    * Er fragt den Portmapper: "An welchem Port lauscht Programm `RDICTPROG` (Version `RDICTVERS`)?".
    * Der Portmapper antwortet mit der Portnummer.

3.  **RPC-Aufruf (Beispiel `countw()`):**
    * **Client:** Der Benutzer gibt `n` ein.
        1.  `rdict.c` (`main`) ruft `countw()` auf.
        2.  `rdict_cif.c` (Stub) ruft `countw_1(0, handle)` auf.
        3.  `rdict_clnt.c` (generiert) führt den RPC-Netzwerkaufruf `clnt_call()` zum Server-Port durch.
    * **Server:**
        1.  `rdict_svc.c` (generiert) empfängt den Aufruf. Der Dispatcher (`switch`-Statement) sieht, dass Prozedur `6` (`COUNTW`) aufgerufen wurde.
        2.  Er ruft die Wrapper-Funktion `countw_1_svc()` in `rdict_sif.c` auf.
        3.  Diese ruft schließlich Ihre Logik-Funktion `countw()` in `rdict_srp.c` auf.
        4.  `rdict_srp.c` gibt `nwords` zurück.
    * **Rückweg:** Der Rückgabewert (`int nwords`) wird den gesamten Weg über XDR zurück zum Client serialisiert, wo er in `rdict.c` von `printf` ausgegeben wird.

---

## 3. Fragen aus der PDF

**Frage:** "Was bedeutet die Zahl am Ende der Programmdefinition?"

**Antwort:**
Die Zahl `0x30090949` ist die **eindeutige Programm-Nummer** des `RDICTPROG`.

* Sie dient als universelle ID für diesen Dienst.
* Der Server (`rdictd`) **registriert** sich mit dieser Nummer beim Portmapper.
* Der Client (`rdict`) **findet** den Server, indem er den Portmapper nach genau dieser Nummer fragt.
* Der `0x3...`-Nummernkreis ist für benutzerdefinierte, nicht-offiziell registrierte Programme vorgesehen.
* 