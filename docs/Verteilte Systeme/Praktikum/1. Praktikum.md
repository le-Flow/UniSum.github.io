## 1. Architektur & Aufbau (Die "Blueprints")

Das System ist eine klassische **Client-Server-Anwendung** auf Basis von **RMI (Remote Method Invocation)**.

  * **Der Server:** Ist die `Bank`. Sie "bietet" Dienste an (wie `einzahlen`).
  * **Die Clients:** Sind `Kunde` und `Finanzamt`. Sie "nutzen" diese Dienste.
  * **Die RMI-Registry:** Ist das "Telefonbuch". Der Server (die Bank) trägt sich hier unter einem Namen ein (z.B. "Sparkasse"), und die Clients suchen nach diesem Namen, um die Bank zu finden.

### Server-Seite

  * `BankServer.java`: Die **Start-Klasse** (mit `main`). Sie ist der "Portier".
      * Startet die RMI-Registry (das Telefonbuch) auf Port 1099.
      * Erstellt eine Instanz von `Bank` (z.B. `new Bank()`).
      * Registriert diese Instanz unter einem Namen (z.B. "Sparkasse") mit `Naming.rebind()`.
  * `Bank.java`: Das **Herzstück** der Anwendung.
      * `extends UnicastRemoteObject`: Macht sie zu einem RMI-fähigen Server-Objekt.
      * `implements KundenInterface, FinanzamtInterface`: Sie *verspricht*, alle Methoden aus *beiden* Verträgen zu implementieren.
      * Enthält die **Geschäftslogik** (Passwörter prüfen, Saldo berechnen).
      * Enthält die **Datenhaltung** (z.B. eine `Map<Integer, Konto>`, die Kontonummern auf Konto-Objekte abbildet).
  * `Konto` (als innere Klasse in `Bank`): Ein einfacher Datencontainer (POJO), der Name, Passwort und Kontostand hält. **Wichtig:** Dieses Objekt *verlässt nie den Server*.

### Client-Seite

  * `BankClient.java`: Die **Kunden-Anwendung** (mit `main`).
      * Fragt den Benutzer, mit welcher Bank er sich verbinden will (z.B. "Sparkasse").
      * Sucht die Bank mit `Naming.lookup("rmi://localhost/Sparkasse")`.
      * **WICHTIG:** Castet das Ergebnis auf das `KundenInterface`. Dadurch *kann* dieser Client die Finanzamt-Methoden gar nicht sehen oder aufrufen.
      * Startet die interaktive Schleife ("Was möchten Sie tun?").
  * `FinanzamtClient.java`: Die **Finanzamt-Anwendung** (mit `main`).
      * Sucht die *gleiche* Bank (z.B. "Sparkasse") mit `Naming.lookup()`.
      * **WICHTIG:** Castet das Ergebnis auf das `FinanzamtInterface`.
      * Startet seine eigene interaktive Schleife.

### Geteilte Komponenten (Der "Vertrag")

Das sind die `.java`-Dateien, die **sowohl Server als auch Client kennen müssen**. Sie sind die gemeinsame Sprache.

  * `KundenInterface.java`:
      * `extends java.rmi.Remote`
      * Definiert Methoden wie `abheben(...)`, `einzahlen(...)`.
      * Alle Methoden werfen `java.rmi.RemoteException`.
  * `FinanzamtInterface.java`:
      * `extends java.rmi.Remote`
      * Definiert Methoden wie `getSummeKontostaende(...)`.
      * Alle Methoden werfen `java.rmi.RemoteException`.
  * `Kontostand.java`:
      * `implements java.io.Serializable`
      * Ein DTO (Data Transfer Object), um Kontonummer und Saldo *vom Server zum Client* zu schicken.
  * `KontoZugriffsException.java` & `KontoNichtGedecktException.java`:
      * `extends Exception` (und ist damit automatisch `Serializable`).
      * Eigene Fehler-Objekte, die *vom Server zum Client* geschickt (geworfen) werden können.

-----

## 2. Konzeptuelle Sachen & Need-to-Knows

  * **Interface vs. Implementierung:** Das ist das Kernkonzept. Der Client programmiert *nur* gegen das Interface (den "Vertrag"). Er weiß nicht (und es ist ihm egal), wie die Bank intern die Konten speichert (ob in einer `Map`, einer `List` oder einer Datenbank).

  * **RMI (Remote Method Invocation):** Ermöglicht es dem Client, `bank.abheben(...)` aufzurufen, als ob das `bank`-Objekt bei ihm lokal im Speicher läge. In Wirklichkeit wird der Aufruf über das Netzwerk an den Server geschickt, dort ausgeführt, und das Ergebnis (oder die Exception) kommt zurück.

  * **Stub & Skeleton:** Der Client erhält beim `lookup()` nicht das echte `Bank`-Objekt, sondern einen **Stub** (einen Stellvertreter). Dieser Stub weiß, wie man die Daten verpackt und an den Server (das **Skeleton**) schickt.

  * **Serialisierung:** Damit Objekte wie `Kontostand` oder `KontoZugriffsException` über das Netzwerk reisen können, müssen sie "serialisiert" (in einen Bytestrom umgewandelt) werden. Das passiert automatisch, wenn die Klasse `implements Serializable` implementiert.

  * **Security durch Interfaces:** Der stärkste Teil des Designs. Obwohl die `Bank`-Klasse *beide* Interfaces implementiert, kann der `BankClient` (der nur das `KundenInterface` kennt) unmöglich die `FinanzamtInterface`-Methoden aufrufen.

-----

## 3. Implementierungs-Highlights

  * **Datenhaltung:** Eine `Map<Integer, Konto>` (oder besser `ConcurrentHashMap` für Thread-Sicherheit) in der `Bank`-Klasse ist ideal, weil die Kontonummer der perfekte, eindeutige Schlüssel ist.
  * **Fehlerbehandlung:** Statt nur `true`/`false` oder Fehlercodes zurückzugeben, werfen wir *spezifische, eigene Exceptions*. Der `BankClient` kann diese in einem `try-catch`-Block fangen und dem Benutzer eine saubere Fehlermeldung ("Passwort falsch\!", "Konto nicht gedeckt\!") anzeigen.
  * **Mehrere Banken:** Der Trick war, den `BankServer` so umzubauen, dass er den Banknamen als **Kommandozeilen-Argument** (`String[] args`) entgegennimmt.
  * **Registry-Start:** Der verbesserte `BankServer` versucht, die Registry zu starten (`LocateRegistry.createRegistry(1099)`). Wenn das fehlschlägt (weil sie schon läuft), fängt er die `ExportException` ab und macht einfach weiter. So kann der erste Server die Registry starten und alle weiteren (z.B. "Postbank") hängen sich einfach dran.

-----

## 4. "README" – So wird's ausgeführt

So testest du das System mit zwei Banken, einem Kunden und dem Finanzamt.

**Voraussetzung:** Alle `.java`-Dateien sind kompiliert (z.B. liegen als `.class`-Dateien im selben Ordner-Layout).

**WICHTIG:** Alle Befehle müssen aus dem **Stammverzeichnis** ausgeführt werden (dem Ordner *über* deinem `Praktikum`-Ordner).

### Schritt 1: Terminal 1 - "Sparkasse" starten

```bash
# Gehe ins Stammverzeichnis (z.B. /.../Verteilte Systeme/)
cd /pfad/zum/stammverzeichnis/

# Starte den Server und gib ihm den Namen "Sparkasse"
java Praktikum.Praktikum_1.Banken.BankServer Sparkasse
```

*Ausgabe:*
`RMI Registry auf Port 1099 gestartet.`
`Sparkasse-Server ist bereit.`

### Schritt 2: Terminal 2 - "Postbank" starten

*Lass Terminal 1 offen\!*

```bash
# Gehe ins selbe Stammverzeichnis
cd /pfad/zum/stammverzeichnis/

# Starte einen zweiten Server unter dem Namen "Postbank"
java Praktikum.Praktikum_1.Banken.BankServer Postbank
```

*Ausgabe:*
`RMI Registry läuft bereits auf Port 1099.`
`Postbank-Server ist bereit.`

### Schritt 3: Terminal 3 - Kunden-Client starten

*Lass Terminal 1 & 2 offen\!*

```bash
# Gehe ins selbe Stammverzeichnis
cd /pfad/zum/stammverzeichnis/

# Starte den Kunden-Client
java Praktikum.Praktikum_1.Banken.BankClient
```

*Ausgabe:*
`Mit welcher Bank verbinden (z.B. Sparkasse, Postbank)?`
`Sparkasse`
`Erfolgreich mit Bank 'Sparkasse' verbunden.`
`--- Kunden-Terminal ---`
`Was möchten Sie tun?`
`...`

Jetzt kannst du Konten bei der "Sparkasse" anlegen, Geld einzahlen usw. Wenn du den Client neu startest und "Postbank" eingibst, bist du mit der anderen Bank verbunden.

### Schritt 4: Terminal 4 - Finanzamt-Client starten

*Lass alle Terminals offen\!*

```bash
# Gehe ins selbe Stammverzeichnis
cd /pfad/zum/stammverzeichnis/

# Starte den Finanzamt-Client
java Praktikum.Praktikum_1.Banken.FinanzamtClient
```

*Ausgabe:*
`Mit welcher Bank verbinden (z.B. Sparkasse, Postbank)?`
`Sparkasse`
`Erfolgreich mit Bank 'Sparkasse' verbunden.`
`--- Finanzamt-Terminal ---`
`...`

Jetzt kann das Finanzamt die Summe aller Konten von "Anna" bei der "Sparkasse" abfragen.