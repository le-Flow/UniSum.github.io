# 4. Praktikum

## Projektziel

Entwicklung eines **verteilten Systems ohne Frameworks/IDL** für eine Produktionshalle mit mehreren Anlagen (Clients) und Leitrechnern (Servern).

## Systemarchitektur

### Drei-Komponenten-Modell

```
┌─────────────────────────────────────────────────────────────┐
│                     ServerManager (Port 5000)                │
│              Zentrale Registrierungsstelle                   │
│    • Speichert Server-Namen → IP:Port Mappings              │
│    • Ermöglicht Service Discovery                            │
└──────────────┬────────────────────────────┬─────────────────┘
               │                            │
       1. Register                  2. Lookup "Leitrechner 1"
               │                            │
               ↓                            ↓
    ┌──────────────────┐         ┌─────────────────┐
    │ ProductionServer │         │     Client      │
    │  (Leitrechner)   │←────────│   (SPS/Anlage)  │
    │   Port: 6000+    │  3. Direct Communication   │
    └──────────────────┘         └─────────────────┘
```

### Kommunikationsfluss

1. **Server startet** → Registriert sich beim ServerManager mit Name, IP, Port
2. **Client braucht Server** → Fragt ServerManager nach Server-Name
3. **ServerManager antwortet** → Gibt IP und Port des Servers zurück
4. **Client verbindet direkt** → Kommuniziert ab jetzt direkt mit Server

## Komponenten im Detail

### 1. ServerManager (Registry/Name Service)

**Rolle:** Telefonbuch für Server

**Funktionen:**
- **Funktion 1:** Server suchen (Lookup by Name)
- **Funktion 2:** Server registrieren (Register)
- **Funktion 3:** Alle Server auflisten (List All)

**Warum wichtig?**
- Clients müssen keine festen IP-Adressen kennen
- Server können dynamisch hinzugefügt werden
- Flexibilität: Server können auf anderen Ports/Maschinen laufen
- Ähnlich wie DNS im Internet

**Implementierung:**
```java
HashMap<String, ServerInfo> servers;  // Name → ServerInfo Mapping
```

### 2. ProductionServer (Leitrechner)

**Rolle:** Empfängt und verarbeitet Produktionsdaten

**Funktionen:**
- **Funktion 1:** Daten visualisieren (Swing GUI)
- **Funktion 2:** Daten persistent speichern (Datei)

**Features:**
- Multi-threaded (jeder Client = eigener Thread)
- Grafisches Echtzeit-Dashboard
- Activity Log für Nachverfolgbarkeit
- Automatische Registrierung beim Start

**Warum GUI?**
- Echtzeitüberwachung in Produktionshallen
- Sofortige visuelle Rückmeldung
- Typisch für SCADA-Systeme

### 3. Client (SPS/Anlage)

**Rolle:** Sendet Produktionsdaten (Sensoren, Maschinen)

**Ablauf:**
1. Fragt ServerManager nach Server
2. Erhält IP:Port
3. Verbindet direkt zum Server
4. Sendet Daten (Nachricht + Prozesswert)

**Multi-Language Support:**
- Java-Client
- Python-Client
- → Zeigt Sprachunabhängigkeit des Protokolls

## Netzwerkprotokoll

### Warum eigenes Protokoll?

**Lernziel:** Verstehen, wie Frameworks intern arbeiten
- Keine "Magic" von gRPC, REST, etc.
- Direktes Arbeiten mit Sockets und Bytes
- Volle Kontrolle über Format

### Protokoll-Design

#### ServerInfo-Format (ServerManager ↔ Alle)
```
┌────────────┬──────────┬────────────┬──────────┬────────┐
│ nameLength │   name   │  ipLength  │    ip    │  port  │
│   4 Bytes  │ variable │  4 Bytes   │ variable │ 4 Bytes│
└────────────┴──────────┴────────────┴──────────┴────────┘
```

**Warum variable Längen?**
- Namen können unterschiedlich lang sein
- Effizienter als feste Größe (kein Platz-Verschwendung)
- Length-Prefix Pattern: Standard in vielen Protokollen

#### ProductionData-Format (Client → Server)
```
┌──────────┬───────────────────────┬─────────┐
│ function │       message         │  value  │
│  1 Byte  │      100 Bytes        │ 4 Bytes │
└──────────┴───────────────────────┴─────────┘
```

**Design-Entscheidungen:**
- **Function Byte:** Command Pattern - Server weiß, was zu tun ist
- **Fixed 100 Bytes:** Einfaches Parsing, kein Length-Prefix nötig
- **32-Bit Integer:** Standard für Prozessdaten (Temperatur, Druck, etc.)

### Byte-Order (Endianness)

**Problem:** Intel (Little-Endian) vs. ARM/Network (Big-Endian)

**Lösung:** Network Byte Order (Big-Endian)
```java
ByteBuffer.putInt(value);  // Java: Always Big-Endian in network I/O
struct.pack('>i', value)   # Python: '>' = Big-Endian
```

## Wichtige Konzepte

### 1. Service Discovery (Diensterkennung)

**Problem:** Wie finden Clients Server in verteilten Systemen?

**Lösungsansätze:**
- **Feste IP-Adressen:** Unflexibel, nicht skalierbar
- **DNS:** Nur für Internet-Domains
- **Registry (unsere Lösung):** Zentrale Registrierungsstelle

**Real-World Beispiele:**
- Kubernetes: etcd (Service Registry)
- Microservices: Consul, Eureka
- Cloud: AWS Service Discovery

### 2. Client-Server Architektur

**Charakteristik:**
- Server = Passiv, wartet auf Anfragen
- Client = Aktiv, initiiert Kommunikation
- Server kann mehrere Clients bedienen (Multi-Threading)

**Vorteile:**
- Klare Rollentrennung
- Zentrale Datenverwaltung
- Einfache Wartung

**Nachteile:**
- Single Point of Failure (Server fällt aus → System tot)
- Skalierbarkeit begrenzt

### 3. Multi-Threading

**Warum?**
```java
new Thread(() -> handleClient(socket)).start();
```

- **Ohne Threads:** Server blockiert bei einem Client, andere warten
- **Mit Threads:** Jeder Client wird parallel bedient
- **Alternative:** Asynchrone I/O (NIO, async/await)

**Wichtig:**
- Jeder Socket = eigene Verbindung
- Thread-Safety bei shared resources (HashMap)

### 4. Serialisierung (Marshalling)

**Problem:** Objekte über Netzwerk senden

**Unsere Lösung:** Manuelle Byte-Konvertierung
```java
public byte[] toByteArray() {
    ByteBuffer buffer = ByteBuffer.allocate(...);
    buffer.putInt(nameBytes.length);
    buffer.put(nameBytes);
    return buffer.array();
}
```

**Alternativen:**
- Java Serializable (sprachspezifisch)
- JSON (text, menschenlesbar, größer)
- Protocol Buffers (effizient, braucht Schema)
- XML (veraltet, sehr groß)

### 5. Protokoll-Versionierung

**Unser System:** Keine Versionierung

**In der Praxis wichtig:**
```
┌─────────┬──────────┬─────────┐
│ version │ function │  data   │
└─────────┴──────────┴─────────┘
```

**Warum?**
- Server/Client Updates ohne Downtime
- Backwards Compatibility
- Neue Features schrittweise einführen

## Kommunikationsablauf - Schritt für Schritt

### Szenario: Client sendet Daten an "Leitrechner 1"

#### Phase 1: Server-Registrierung
```
ProductionServer                    ServerManager
     |                                    |
     |----(1) TCP Connect--------------->|
     |                                    |
     |----(2) Function=2 (Register)----->|
     |----(3) ServerInfo Bytes---------->|
     |                                    | [Speichert: "Leitrechner 1" → 127.0.0.1:6000]
     |<---(4) Success=true---------------|
     |                                    |
     |----(5) TCP Close----------------->|
```

#### Phase 2: Client-Lookup
```
Client                              ServerManager
  |                                       |
  |----(1) TCP Connect------------------->|
  |                                       |
  |----(2) Function=1 (Lookup)----------->|
  |----(3) "Leitrechner 1" Bytes--------->|
  |                                       | [Sucht in HashMap]
  |<---(4) ServerInfo Bytes---------------|
  |       (IP=127.0.0.1, Port=6000)       |
  |                                       |
  |----(5) TCP Close--------------------->|
```

#### Phase 3: Direkte Kommunikation
```
Client                           ProductionServer
  |                                    |
  |----(1) TCP Connect (Port 6000)---->|
  |                                    |
  |----(2) Function=1 (Display)------->|
  |----(3) Message (100 Bytes)-------->|
  |----(4) Value (4 Bytes)------------>|
  |                                    | [Zeigt Daten in GUI]
  |                                    | [Speichert in Datei]
  |                                    |
  |----(5) TCP Close------------------>|
```

## Was haben wir gelernt?

### Technisch

1. **Socket-Programmierung**
    - TCP vs. UDP
    - ServerSocket vs. Socket
    - Blocking I/O

2. **Binäre Protokolle**
    - Byte-Manipulation
    - Serialisierung/Deserialisierung
    - Endianness-Probleme

3. **Verteilte Architektur**
    - Service Registry Pattern
    - Client-Server Kommunikation
    - Loose Coupling durch Indirektion

4. **Interoperabilität**
    - Sprachunabhängige Protokolle
    - Java ↔ Python Kommunikation
    - Network Byte Order

5. **Multi-Threading**
    - Parallele Client-Verarbeitung
    - Thread-Safety Überlegungen

### Konzeptionell

1. **Separation of Concerns**
    - Registry ≠ Business Logic
    - Jede Komponente hat klare Aufgabe

2. **Indirektion**
    - Clients kennen Server-Namen, nicht IPs
    - Flexibilität durch zusätzliche Schicht

3. **Request-Response Pattern**
    - Synchrone Kommunikation
    - Client initiiert, Server antwortet

4. **Protocol Design**
    - Trade-offs: Effizienz vs. Lesbarkeit
    - Fixed vs. Variable Length Fields
    - Versioning und Erweiterbarkeit

## Fazit

**Was wir erreicht haben:**

✅ Funktionierendes verteiltes System ohne Frameworks  
✅ Verständnis für Low-Level Netzwerkprogrammierung  
✅ Service Discovery Pattern implementiert  
✅ Sprachunabhängiges Protokoll (Java ↔ Python)  
✅ Multi-Client-Server Architektur