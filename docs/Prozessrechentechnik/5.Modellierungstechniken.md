## Inhalte

* Modellbasiertes Design (Grundlagen, Evolution)
* Anforderungen an Modellierungssprachen
* Alternative Ausführungsmodelle (Rechenmodelle)
* Quality Gates im V-Modell (MIL, SIL, PIL, HIL)
* Rapid Prototyping

---

## Modellbasiertes Design (MBD)

### Grundlagen & Definitionen

**Modell**
Eine zielorientierte **Abstraktion** einer Entität. Es ist eine Vereinfachung, die exakt jene Eigenschaften enthält, die für eine bestimmte Aufgabe relevant sind, während irrelevante Details weggelassen werden.

**Der MBD-Ansatz**
Ein Evolutionsschritt weg von der manuellen textuellen Programmierung (C/Assembler).
* **Zentrales Artefakt:** Die Software wird primär grafisch in Modellen (z. B. Simulink, ASCET) entworfen. Diese sind maschinenlesbar und haben eine eindeutige Semantik.
* **Auto-Coding:** Der finale Quellcode wird nicht manuell geschrieben, sondern durch einen Generator (**Auto-Coder**) automatisch erzeugt.
* **Vorteil:** Arbeit auf hoher Abstraktionsebene. Der Auto-Coder erzeugt hochoptimierten Code ohne den klassischen Konflikt zwischen Effizienz und Flexibilität.

### Modellevolution
Der Prozess beschreibt die schrittweise Anreicherung des Modells ohne Informationsverlust.

1.  **Physikalisches Modell:** Rein funktionale Beschreibung (meist Floating-Point-Arithmetik).
2.  **Implementierungsmodell:** Ergänzung um HW/SW-spezifische Anforderungen.
    * Umstellung auf **Fixed-Point-Arithmetik**.
    * Datentyprestriktionen (8/16/32-Bit).
    * Speicher- und Laufzeitoptimierungen.
3.  **Autocode:** Das generierte C-Programm.

---

## Ausführungsmodelle (Rechenmodelle)

Ein Rechenmodell definiert, wie Komponenten intern arbeiten und wie sie kommunizieren.

### 1. Von-Neumann-Modell (Control Flow)
Das Standardmodell für C/C++ und Java.
* **Prinzip:** Sequenzielle Abfolge von Befehlen (Kontrollfluss).
* **Kommunikation:** Über Variablen (Shared Memory).
* **Problem:** Nebenläufigkeit muss künstlich über Threads erzeugt werden $\to$ Gefahr von **Race Conditions** und **Deadlocks**.

### 2. Datenflussmodell (Data Flow)

Typisch für Simulink oder SDF.
* **Prinzip:** Die Ausführung von Blöcken wird ausschließlich durch die **Verfügbarkeit von Daten** getriggert. Es gibt keinen zentralen "Instruction Pointer".
* **Vorteil:** Inhärent parallel; ideal für verteilte Systeme.
* **Kommunikation:** Über Signale.

### 3. Endliche Zustandsautomaten (FSM)

Typisch für Stateflow.
* **Einsatz:** Ideal für **reaktive Systeme**.
* **Prinzip:** Das Verhalten wird durch diskrete Zustände, Ereignisse und Zustandsübergänge (Transitionen) modelliert.

### 4. Weitere Modelle
* **Diskretes Ereignismodell (Discrete Event):** (VHDL). Eine Warteschlange mit zeitlich sortierten Aktionen. Aktionen feuern, wenn der Simulationszeitpunkt erreicht ist.
* **Petri-Netze:** Fokus auf Synchronisation und Abhängigkeiten in verteilten Systemen. Mathematisch exakt analysierbar.

---

## Anforderungen an Modellierungssprachen

Da keine einzelne Sprache alle Aspekte perfekt abdeckt, ist die Wahl oft ein Kompromiss. Wichtige Kriterien sind:

* **Hierarchie:** Aufbau von Systemen aus Subsystemen (Bottom-Up).
* **Nebenläufigkeit & Synchronisation:** Darstellung paralleler Abläufe und deren Abhängigkeiten.
* **Zeitverhalten:** Abbildung von Periodendauern, Deadlines und Latenzen.
* **Reaktives Verhalten:** Unterstützung für (hierarchische) Zustandsautomaten.
* **Ausnahmebehandlung:** Modellierung von Fehlerfällen (Fail-Operational).

---

## Quality Gates (im V-Modell)

Das V-Modell sieht eine stufenweise Validierung vor: von der reinen Simulation bis zur echten Hardware.

### 1. MIL (Model-in-the-Loop)
* **Testobjekt:** Das **ausführbare Modell** (Simulink).
* **Umgebung:** Simuliert.
* **Plattform:** Host-PC.
* **Ziel:** Validierung der grundlegenden Logik/Funktion.

### 2. SIL (Software-in-the-Loop)
* **Testobjekt:** Der **generierte Code** (kompiliert für PC).
* **Umgebung:** Simuliert.
* **Plattform:** Host-PC.
* **Ziel:** Konsistenzprüfung zwischen Modell und Code (Code-Generator verifizieren). Noch *keine* Echtzeit.

### 3. PIL (Processor-in-the-Loop)
* **Testobjekt:** Der **generierte Code** (kompiliert für Ziel-Hardware).
* **Umgebung:** Simuliert (auf PC), Daten per Schnittstelle übertragen.
* **Plattform:** **Reale Ziel-CPU** (z. B. Evaluation Board).
* **Ziel:** Prüfung des Ziel-Compilers, Analyse von **Ressourcenbedarf** (Memory, Stack) und Laufzeitverhalten auf dem echten Chip.

### 4. HIL (Hardware-in-the-Loop)

* **Testobjekt:** Das finale **Steuergerät (ECU)** (HW + SW).
* **Umgebung:** **Echtzeit-Simulation** der Strecke (Fahrzeug, Sensorik) auf einem HIL-Simulator (z. B. dSpace).
* **Plattform:** Reale ECU.
* **Ziel:** Test unter **Echtzeitbedingungen**, Fehlerinjektion, Absicherung vor dem Feldeinsatz.

### 5. Test im realen System
* Abschließende Erprobung im realen Fahrzeug/Prototypen.

---

## Rapid Prototyping (RP)

Ein "Shortcut" im Entwicklungsprozess, um Ideen schnell am realen Objekt zu testen.

* **Vorgehen:** Die klassischen Quality Gates (SIL/PIL/HIL) werden zunächst übersprungen.
* **Hardware:** Der Code läuft nicht auf der (schwachen) Serien-ECU, sondern auf einer **leistungsstarken RP-Hardware** (z. B. dSpace Autobox), die im Fahrzeug verbaut wird ("Bypass").
* **Ziele:**
    * Schnelle Validierung ("Proof of Concept").
    * Systemidentifikation (Parameter ermitteln).
    * Erst *nach* erfolgreichem RP beginnt die Serienentwicklung mit allen Quality Gates.