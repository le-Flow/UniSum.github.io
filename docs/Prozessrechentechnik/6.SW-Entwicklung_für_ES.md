## Inhalte

* Besonderheiten eingebetteter Software
* Systemarchitekturen (Zeit- vs. Ereignisgesteuert)
* Verlässlichkeit (Dependability) und Funktionale Sicherheit
* Reliability Engineering (Analytische und Konstruktive Maßnahmen)
* Software-Schichten (Plattform vs. Applikationssoftware)

---

## Besonderheiten eingebetteter Software

Eingebettete Systeme (ES) unterliegen anderen Zwängen als klassische PC-Software.

* **Ressourcenbeschränkung:** Da ES oft Massenprodukte sind, herrscht hoher Kostendruck. Man investiert lieber mehr Entwicklungszeit in Code-Optimierung, um an der Hardware (Speicher, CPU) Cent-Beträge zu sparen.
* **Energieverbrauch:** Kritisch, da Batteriekapazitäten begrenzt sind und oft keine aktive Kühlung (Lüfter) möglich ist.
* **Robustheit:** Die Software muss mit ungenauen Sensordaten, Rauschen und vereinfachten Modellen der Realität zuverlässig arbeiten.
* **Echtzeit & Normen:** Oft müssen harte Zeitlimits eingehalten werden, zertifiziert nach Normen wie IEC 61508 (Industrie) oder ISO 26262 (Automotive).
* **Zielkonflikt:** Hohe Flexibilität (Wartbarkeit, Abstraktion) steht meist im Widerspruch zu maximaler Performanz und minimalem Ressourcenverbrauch.

---

## Systemarchitekturen

Wie wird die Ausführung der Software gesteuert?

### Zeitgesteuerte Systeme (Time-Triggered)
* **Steuerung:** Durch einen **festen Zeittakt**.
* **Datenfluss:** Sensoren werden aktiv abgefragt (**Polling**).
* **Vorteil:** Das zeitliche Verhalten ist **vollständig deterministisch und planbar**. Dies ist für **harte Echtzeitanforderungen** oft zwingend notwendig.

### Ereignisgesteuerte Systeme (Event-Triggered)
* **Steuerung:** Durch externe Ereignisse (**Interrupts**).
* **Nachteil:** Das zeitliche Verhalten ist schwer vorhersehbar. Ein Risiko sind **"Event Showers"** (Ereignisstürme), bei denen zu viele Interrupts gleichzeitig auftreten und das System überlasten.

---

## Verlässlichkeit (Dependability)

Ein Oberbegriff für die Vertrauenswürdigkeit eines Systems, unterteilt in drei Aspekte:

### 1. Zuverlässigkeit (Reliability)
Die Wahrscheinlichkeit $R(t)$, dass ein System über einen Zeitraum $t$ **durchgängig fehlerfrei** funktioniert.

**Die Badewannenkurve**

Beschreibt die Ausfallrate von Hardware über die Lebenszeit:
1.  **Frühausfallphase:** Hohe Rate durch Produktionsfehler (sinkend).
2.  **Konsolidierungsphase:** Niedrige, konstante Rate (Zufallsausfälle).
3.  **Spätausfallphase:** Steigende Rate durch Verschleiß/Alterung.

### 2. Verfügbarkeit (Availability)
Der Anteil der Zeit, in der das System funktionsbereit ist (unabhängig von Unterbrechungen).

$$Verfügbarkeit = \frac{\text{Gesamtzeit} - \text{Ausfallzeit}}{\text{Gesamtzeit}}$$

### 3. Funktionale Sicherheit (Safety)
Die Freiheit von nicht akzeptierbaren Risiken.
* **Risikodefinition:**
  
$$Risiko = \text{Eintrittshäufigkeit} \times \text{Schadensausmaß}$$
  
![alt text](images/6.SW-Entwicklung_für_ES/image.png)

* **Ziel:** Das Risiko muss unter einem definierten **Grenzrisiko** bleiben.
* **Zielkonflikt Safety vs. Availability:** Eine sehr empfindliche Fehlererkennung, die das System beim kleinsten Zweifel abschaltet, erhöht die Sicherheit (kein Schaden), aber ruiniert die Verfügbarkeit (System steht still).

---

## Reliability Engineering

Methoden zur Berechnung und Steigerung der Verlässlichkeit.

### Analytische Verfahren
Berechnung der Gesamtsystem-Zuverlässigkeit ($R$) aus Komponenten.



[Image of series vs parallel reliability block diagram]


* **Serielle Kopplung (Kette):**
  * System fällt aus, wenn **eine** Komponente versagt.
  * $R_{Gesamt} = R_1 \cdot R_2 \cdot \ldots \cdot R_n$
  * *Ergebnis:* Die Zuverlässigkeit ist **schlechter** als die der schlechtesten Komponente.
* **Parallele Kopplung (Redundanz):**
  * System fällt nur aus, wenn **alle** Komponenten versagen.
  * $R_{Gesamt} = 1 - [(1 - R_1) \cdot (1 - R_2) \cdot \ldots \cdot (1 - R_n)]$
  * *Ergebnis:* Die Zuverlässigkeit ist **besser** als die der besten Komponente.

### Konstruktive Maßnahmen (Redundanz)
Einsatz zusätzlicher Ressourcen zur Fehlertoleranz.

#### Hardware-Redundanz
* **Statisch (Voting):** Identische Module arbeiten parallel. Ein **Voter** entscheidet per Mehrheit (z. B. 2-aus-3 Auswahl / Triple Modular Redundancy). Maskiert Fehler sofort.
  
* **Dynamisch (Switching):** Eine Fehlererkennung schaltet im Notfall auf ein Reserve-Modul ("Standby") um.
* **Hybrid:** Kombination aus Voting und Rekonfiguration (defekte Module werden vom Voter ignoriert und durch Reserve ersetzt).

#### Software-Redundanz
Da Software nicht "verschleißt", helfen einfache Kopien nicht gegen Designfehler (Bugs). Man benötigt **Diversität**.
* **N-Versions Programming (Statisch):** Mehrere Teams entwickeln die Software unabhängig voneinander. Alle Versionen laufen parallel, ein Voter entscheidet. (Extrem teuer).
* **Recovery Blocks (Dynamisch):** Ein Akzeptanztest prüft das Ergebnis. Schlägt dieser fehl, wird eine (einfachere) Reserve-Variante ausgeführt.

---

## Software-Schichten: Plattform vs. Applikation

Moderne ECU-Architekturen (z. B. AUTOSAR) trennen strikt in zwei Schichten.



| Merkmal | **Plattformsoftware** | **Applikationssoftware** |
| :--- | :--- | :--- |
| **Position** | Unten (Hardwarenah) | Oben (Hardwareunabhängig) |
| **Aufgabe** | **Abstraktion der Hardware**. Stellt Treiber (ADC, CAN) und Basisdienste (Scheduling) bereit. | Enthält die **eigentliche Produktlogik** (Regler, Steuerungsabläufe). |
| **Semantik** | **Keine Semantik.** Liefert nur Rohwerte (z.B. "Spannungswert 102"). | **Trägt die Semantik.** Interpretiert Werte (z.B. "102 = 5 m/s² Beschleunigung"). |
| **Abhängigkeit** | Plattformspezifisch (angepasst an den Chip). | Anwendungsspezifisch (enthält das Domänenwissen). |
| **Beispiel** | Betriebssystem, Bustreiber, HAL. | Tempomat-Regler, Motorsteuerung. |