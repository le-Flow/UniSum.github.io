## **Compiler vs Interpreter**
* Ein **Compiler** ist ein Programm, das ein ausführbares Programm in einer Sprache in ein ausführbares Programm in einer anderen Sprache übersetzt.
* Ein **Interpreter** ist ein Programm, das ein ausführbares Programm liest und das Resultat der Ausführung dieses Programmes produziert.
* Interpreter sind typischerweise 10- bis 100-mal langsamer als die Ausführung eines kompilierten Programms.
* Obwohl es in diesem Modul (IB610) primär um Compiler geht, sind einige der Probleme / Methoden identisch (z. B. Lexikalische Analyse).

## **Sprachimplementierung**
* **Typischerweise kompilierte Sprachen:** C/C++, Go.
* **Typischerweise interpretierte Sprachen:** Scheme (Lisp), Python, Javascript.
* **Hybride Modelle:** Java (übersetzt in Java Bytecodes, JVM Interpreter).
* Kompilierung findet vor der Ausführung statt (Ausnahme: Laufzeit oder Just-In-Time (JIT) Compiler).

## **Anforderungen an einen Compiler**
* Erzeugt korrekten Code.
* Erzeugter Code ist schnell.
* Die Übersetzungszeit ist kurz.
* Unterstützt getrennte Übersetzung ("separate compilation").
* Liefert gute Fehlermeldungen und Warnungen.
* Unterstützt symbolisches Debugging.
* Konsistente & berechenbare Optimierung.

## **Aufbau**

### **Übersetzungsschritte**
Der Weg vom Quellprogramm zum Maschinencode:

1.  **Präprozessor:** Erzeugt ein modifiziertes Quellprogramm.
2.  **Compiler:** Erzeugt ein Assembler-Zielprogramm.
3.  **Assembler:** Erzeugt verschiebbaren Maschinencode.
4.  **Linker/Lader:** Verknüpft Bibliotheksdateien und verschiebbare Objektdateien zum Zielcode in Maschinensprache.

### **Compiler Phasen**
* **Frontend (Maschinenunabhängig, Quellsprachenabhängig):**
  * *Lexikalische Analyse:* Wandelt Zeichenstream in Tokenstream.
  * *Syntaxanalyse:* Erzeugt Syntaxbaum.
  * *Semantische Analyse:* Nutzt Symboltabelle.
* **Middle-End (Von Quell- und Zielsprache unabhängig):**
  * Zwischencodegenerator und maschinenunabhängiger Codeoptimierer arbeiten auf einer Zwischendarstellung.
* **Backend (Quellsprachenunabhängig, Maschinenabhängig):**
  * Codegenerator und maschinenabhängiger Codeoptimierer erzeugen den finalen Maschinencode.

## **Two-Pass Compiler**
* Phasen werden typischerweise in 2 Läufe (passes) unterteilt:
  1.  **Front-End:** Lexikalische, syntaktische und semantische Analyse sowie Zwischencodegenerierung.
  2.  **Back-End:** Erzeugung von Maschinencode aus dem Zwischencode.
* **Vorteile:** Wiederverwendung von Code. Für $n$ Sprachen und $m$ Ziel-Architekturen benötigt man $n+m$ Versionen anstelle von $n*m$.

## **Compilerbau: Wichtige Werkzeuge**
* **Scannergeneratoren (z. B. j(f)lex):** Erzeugen einen Lexikalischen Analysator aus der lexikalischen Spezifikation (Reguläre Ausdrücke, NFA, DFA).
* **Parsergeneratoren (z. B. CUP):** Erzeugen aus einer (Kontextfreien) Grammatik einen syntaktischen Analysator.
* Viele Code-Optimierungs- und Codegenerierungsaufgaben sind NP-vollständig oder architekturabhängig und werden daher typischerweise "von Hand" geschrieben.