{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Compiler/Roadmap/","title":"Roadmap","text":""},{"location":"Compiler/Roadmap/#kapitel-1-einfuhrung","title":"Kapitel 1 (Einf\u00fchrung)","text":""},{"location":"Compiler/Roadmap/#1-einfuhrung","title":"1. Einf\u00fchrung","text":"<ul> <li> Compiler vs Interpreter</li> <li> Sprachimplementierung</li> <li> Anforderungen an Compiler</li> <li> Aufbau<ul> <li> \u00dcbersetzungsschritte</li> <li> Compilerphasen</li> </ul> </li> <li> Two-Pass Compiler</li> <li> Compilerbau Werkzeuge</li> </ul>"},{"location":"Compiler/Roadmap/#kapitel-2-lexikalische-analyse","title":"Kapitel 2 (Lexikalische Analyse)","text":""},{"location":"Compiler/Roadmap/#2-lexikalische-analyse","title":"2. Lexikalische Analyse:","text":"<ul> <li> Kontextfreie Grammatiken</li> <li> Parsebaum<ul> <li> konkreter Syntaxbaum</li> <li> Abstrakter Syntaxbaum</li> </ul> </li> <li> Lexer</li> <li> Jflex (Regex etc)</li> <li> Tokenerkennung<ul> <li> \u00dcbergangsdiagramme</li> </ul> </li> <li> Automaten<ul> <li> DFA zu Tabellen getriebener Implementierung</li> <li> Automaten (DFA und NFA)</li> <li> NFA in DFA \u00dcbersetzen (B\u00fcchi-Algorithmus)</li> <li> Regex zu NFA (McNaughthon-Yamada-Thompson Algorithmus)</li> <li> Effizienz</li> </ul> </li> <li>TODO: Kapitel 3.3 + \u00dcbungen 3.3.2 und 3.3.5</li> </ul>"},{"location":"Compiler/Roadmap/#kapitel-3-syntaktische-analyse","title":"Kapitel 3 (Syntaktische Analyse)","text":""},{"location":"Compiler/Roadmap/#3-syntaktische-analyse","title":"3. Syntaktische Analyse","text":"<ul> <li> Parser Typen<ul> <li> Top-Down<ul> <li> Rekursiver Abstieg (Links/Rechts Rekursiv)</li> </ul> </li> <li> Bottom-Up<ul> <li> Pr\u00e4dikative Parser</li> <li> LL(1)</li> <li> Faktorisierung (Links/Rechts)</li> <li> First und Follow Mengen</li> </ul> </li> </ul> </li> <li> Kontextfreie Grammatiken (CFG)</li> <li> Ableitungen (Links/Rechtsseitig)</li> <li> Eindeutige Grammatiken</li> </ul>"},{"location":"Compiler/Roadmap/#4-syntaktische-analyse-buttom-up-parsing","title":"4. Syntaktische Analyse (Buttom-Up Parsing)","text":"<ul> <li> Bottom-Up Parsing<ul> <li> Reduktion<ul> <li> Shift Reduce</li> </ul> </li> <li> Handles</li> <li> LR-Parsen, LR(0) und SLR</li> <li> Closure</li> </ul> </li> </ul>"},{"location":"Compiler/Roadmap/#5-syntaktische-analyse-fortgeschrittene-parsing-methoden","title":"5. Syntaktische Analyse (Fortgeschrittene Parsing Methoden)","text":"<ul> <li> LALR Parsing und LR(1)</li> </ul>"},{"location":"Compiler/Roadmap/#6-syntaktische-analyse-cup","title":"6. Syntaktische Analyse (Cup)","text":"<ul> <li> Java Cup<ul> <li> Deklaration terminale und Nichtterminale</li> <li> Precedence Declaration</li> <li> Gramatikregeln</li> </ul> </li> </ul>"},{"location":"Compiler/Roadmap/#kapitel-4-semantische-analyse","title":"Kapitel 4 (Semantische Analyse)","text":""},{"location":"Compiler/Roadmap/#7-semantische-analyse","title":"7. Semantische Analyse","text":"<ul> <li> Symboltabelle<ul> <li> Implementierung</li> <li> Allgemein</li> <li> Liste von Hashtabellen</li> <li> Hashtabellen von Listen</li> <li> Operationen</li> </ul> </li> <li> G\u00fcltigkeit<ul> <li> G\u00fcltigkeitsregeln</li> <li> Dynamsiche G\u00fcltigkeitsbereiche</li> <li> Statische G\u00fcltigkeitsbereiche</li> </ul> </li> <li> Typen<ul> <li> Typechecking</li> <li> Typregeln</li> <li> Typinferenz</li> </ul> </li> </ul>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/","title":"1. Einf\u00fchrung","text":""},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#compiler-vs-interpreter","title":"Compiler vs Interpreter","text":"<ul> <li>Ein Compiler ist ein Programm, das ein ausf\u00fchrbares Programm in einer Sprache in ein ausf\u00fchrbares Programm in einer anderen Sprache \u00fcbersetzt.</li> <li>Ein Interpreter ist ein Programm, das ein ausf\u00fchrbares Programm liest und das Resultat der Ausf\u00fchrung dieses Programmes produziert.</li> <li>Interpreter sind typischerweise 10- bis 100-mal langsamer als die Ausf\u00fchrung eines kompilierten Programms.</li> <li>Obwohl es in diesem Modul (IB610) prim\u00e4r um Compiler geht, sind einige der Probleme / Methoden identisch (z. B. Lexikalische Analyse).</li> </ul>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#sprachimplementierung","title":"Sprachimplementierung","text":"<ul> <li>Typischerweise kompilierte Sprachen: C/C++, Go.</li> <li>Typischerweise interpretierte Sprachen: Scheme (Lisp), Python, Javascript.</li> <li>Hybride Modelle: Java (\u00fcbersetzt in Java Bytecodes, JVM Interpreter).</li> <li>Kompilierung findet vor der Ausf\u00fchrung statt (Ausnahme: Laufzeit oder Just-In-Time (JIT) Compiler).</li> </ul>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#anforderungen-an-einen-compiler","title":"Anforderungen an einen Compiler","text":"<ul> <li>Erzeugt korrekten Code.</li> <li>Erzeugter Code ist schnell.</li> <li>Die \u00dcbersetzungszeit ist kurz.</li> <li>Unterst\u00fctzt getrennte \u00dcbersetzung (\"separate compilation\").</li> <li>Liefert gute Fehlermeldungen und Warnungen.</li> <li>Unterst\u00fctzt symbolisches Debugging.</li> <li>Konsistente &amp; berechenbare Optimierung.</li> </ul>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#aufbau","title":"Aufbau","text":""},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#ubersetzungsschritte","title":"\u00dcbersetzungsschritte","text":"<p>Der Weg vom Quellprogramm zum Maschinencode:</p> <ol> <li>Pr\u00e4prozessor: Erzeugt ein modifiziertes Quellprogramm.</li> <li>Compiler: Erzeugt ein Assembler-Zielprogramm.</li> <li>Assembler: Erzeugt verschiebbaren Maschinencode.</li> <li>Linker/Lader: Verkn\u00fcpft Bibliotheksdateien und verschiebbare Objektdateien zum Zielcode in Maschinensprache.</li> </ol>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#compiler-phasen","title":"Compiler Phasen","text":"<ul> <li>Frontend (Maschinenunabh\u00e4ngig, Quellsprachenabh\u00e4ngig):<ul> <li>Lexikalische Analyse: Wandelt Zeichenstream in Tokenstream.</li> <li>Syntaxanalyse: Erzeugt Syntaxbaum.</li> <li>Semantische Analyse: Nutzt Symboltabelle.</li> </ul> </li> <li>Middle-End (Von Quell- und Zielsprache unabh\u00e4ngig):<ul> <li>Zwischencodegenerator und maschinenunabh\u00e4ngiger Codeoptimierer arbeiten auf einer Zwischendarstellung.</li> </ul> </li> <li>Backend (Quellsprachenunabh\u00e4ngig, Maschinenabh\u00e4ngig):<ul> <li>Codegenerator und maschinenabh\u00e4ngiger Codeoptimierer erzeugen den finalen Maschinencode.</li> </ul> </li> </ul>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#two-pass-compiler","title":"Two-Pass Compiler","text":"<ul> <li>Phasen werden typischerweise in 2 L\u00e4ufe (passes) unterteilt:<ol> <li>Front-End: Lexikalische, syntaktische und semantische Analyse sowie Zwischencodegenerierung.</li> <li>Back-End: Erzeugung von Maschinencode aus dem Zwischencode.</li> </ol> </li> <li>Vorteile: Wiederverwendung von Code. F\u00fcr \\(n\\) Sprachen und \\(m\\) Ziel-Architekturen ben\u00f6tigt man \\(n+m\\) Versionen anstelle von \\(n*m\\).</li> </ul>"},{"location":"Compiler/Vorlesung/1.%20Einf%C3%BChrung/#compilerbau-wichtige-werkzeuge","title":"Compilerbau: Wichtige Werkzeuge","text":"<ul> <li>Scannergeneratoren (z. B. j(f)lex): Erzeugen einen Lexikalischen Analysator aus der lexikalischen Spezifikation (Regul\u00e4re Ausdr\u00fccke, NFA, DFA).</li> <li>Parsergeneratoren (z. B. CUP): Erzeugen aus einer (Kontextfreien) Grammatik einen syntaktischen Analysator.</li> <li>Viele Code-Optimierungs- und Codegenerierungsaufgaben sind NP-vollst\u00e4ndig oder architekturabh\u00e4ngig und werden daher typischerweise \"von Hand\" geschrieben.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/","title":"2. Lexikalische Analyse","text":""},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#kontextfreie-grammatiken","title":"Kontextfreie Grammatiken","text":"<p>CFGs sind das Werkzeug, um die Syntax einer Programmiersprache zu beschreiben (z. B. \"Wie sieht eine If-Anweisung aus?\", \"Wie werden Klammern geschachtelt?\"). Sie sind m\u00e4chtiger als Regul\u00e4re Ausdr\u00fccke, da sie Rekursion (Verschachtelung) darstellen k\u00f6nnen.</p>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#formale-definition","title":"Formale Definition","text":"<p>Im Compilerbau wird eine Grammatik \\(G\\) oft als 4-Tupel definiert:</p> \\[ G = (N, T, P, S) \\] <ul> <li>\\(N\\) (Nicht-Terminale): Platzhalter oder Variablen, die weiter aufgel\u00f6st werden m\u00fcssen (z. B. <code>&lt;Statement&gt;</code>, <code>&lt;Expression&gt;</code>, <code>&lt;If-Block&gt;</code>).</li> <li>\\(T\\) (Terminale): Die kleinsten Bausteine, die nicht weiter zerlegt werden. Im Compiler sind das die Tokens, die vom Lexer kommen (z. B. <code>if</code>, <code>int</code>, <code>id</code>, <code>;</code>, <code>+</code>).</li> <li>\\(P\\) (Produktionsregeln): Regeln der Form \\(A \\rightarrow \\alpha\\), wobei \\(A \\in N\\) ist und \\(\\alpha\\) eine Folge von Terminalen und Nicht-Terminalen.<ul> <li>Beispiel: \\(E \\rightarrow E + E\\)</li> </ul> </li> <li>\\(S\\) (Startsymbol): Das Nicht-Terminal, bei dem die Analyse beginnt (oft <code>&lt;Program&gt;</code>).</li> </ul> <p>Hier ist die Zusammenfassung zum Parsebaum (oft auch CST - Concrete Syntax Tree genannt), fokussiert auf das, was du f\u00fcr das Verst\u00e4ndnis der Syntaxanalyse brauchst.</p> <p>Der Parsebaum ist die grafische Darstellung der Ableitung. Er beweist, dass ein Tokenstrom tats\u00e4chlich zur Grammatik passt.</p>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#parsebaume","title":"Parseb\u00e4ume","text":""},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#aufbau-anatomie","title":"Aufbau (Anatomie)","text":"<p>Jedes Element im Baum entspricht exakt den Mengen aus der Grammatik (\\(N, T, S\\)):</p> <ul> <li>Wurzel (Root): Das Startsymbol \\(S\\).</li> <li>Innere Knoten (Nodes): Die Nicht-Terminale (\\(N\\)), also die Regeln (z. B. <code>&lt;Expr&gt;</code>, <code>&lt;Stmt&gt;</code>).</li> <li>Bl\u00e4tter (Leaves): Die Terminale (\\(T\\)), also die Tokens, die vom Lexer kamen (z. B. <code>id</code>, <code>+</code>, <code>;</code>).</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#konkreter-syntaxbaum-parsebaum","title":"Konkreter Syntaxbaum (Parsebaum)","text":"<ul> <li>1:1 Abbild der Grammatik: Jeder Ast entspricht genau einer angewendeten Produktionsregel.</li> <li>Vollst\u00e4ndig: Er enth\u00e4lt jedes einzelne Zeichen, das der Parser verarbeitet hat, auch syntaktischen \"Zucker\" wie Klammern <code>( )</code>, Semikolons <code>;</code> oder Kommas, die f\u00fcr die sp\u00e4tere Logik eigentlich unwichtig sind.</li> <li>Hierarchie: Die Struktur des Baums zeigt die Bindung (Pr\u00e4zedenz) von Operatoren.<ul> <li>Regel: Was im Baum tiefer steht, wird zuerst ausgewertet (engere Bindung).</li> </ul> </li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#abstrakter-syntaxbaum-ast","title":"Abstrakter Syntaxbaum (AST)","text":"<ul> <li>Kondensierte Logik: Eine bereinigte Version des Parsebaums, die nur die f\u00fcr die Semantik (Bedeutung) relevanten Informationen enth\u00e4lt.</li> <li>Kein syntaktischer \"Zucker\": Hilfszeichen, die nur f\u00fcr den Parser n\u00f6tig waren (wie Klammern <code>( )</code>, Semikolons <code>;</code> oder Keywords wie <code>then</code>), werden entfernt. Die Struktur des Baums selbst definiert nun die Zusammengeh\u00f6rigkeit (die Klammerung ist implizit).</li> <li>Operatoren als Knoten: W\u00e4hrend im CST die Knoten abstrakte Regelnamen sind (z. B. <code>&lt;Expr&gt;</code>), sind die inneren Knoten im AST meist direkt die Operatoren oder Anweisungen (z. B. ein <code>PLUS</code>-Knoten, der direkt zwei Unterb\u00e4ume als Operanden hat).</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#cst-vs-ast","title":"CST vs. AST","text":"<p>Das ist die klassische Pr\u00fcfungsfrage. Warum nutzen wir sp\u00e4ter meist keinen Parsebaum mehr?</p> Merkmal Parsebaum (CST) Abstrakter Syntaxbaum (AST) Inhalt Enth\u00e4lt alles (Klammern, Keywords like <code>if</code>, <code>then</code>). Enth\u00e4lt nur Logik (Operationen und Operanden). Knoten Nicht-Terminale der Grammatik. Operatoren oder Anweisungen. Gr\u00f6\u00dfe Riesig, tief verschachtelt (z. B.<code>Expr -&gt; Term -&gt; Factor -&gt; Number</code>). Kompakt, flach. Zweck Dient dem Parser zur Validierung der Syntax. Dient dem Rest des Compilers (Semantik, Code-Gen)."},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#mehrdeutigkeit-im-baum","title":"Mehrdeutigkeit im Baum","text":"<p>Wie vorhin bei den Grammatiken erw\u00e4hnt: Wenn du f\u00fcr einen Input zwei verschiedene Parseb\u00e4ume zeichnen kannst, ist die Grammatik mehrdeutig (Ambiguous).</p> <ul> <li>Beispiel: <code>3 + 4 * 5</code>.</li> <li>Baum A gruppiert <code>(3+4)</code> tiefer \\(\\rightarrow\\) falsch.</li> <li>Baum B gruppiert <code>(4*5)</code> tiefer \\(\\rightarrow\\) richtig (wegen Punkt-vor-Strich).</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#lexer","title":"Lexer","text":""},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#hauptaufgabe","title":"Hauptaufgabe","text":"<p>Der Lexer ist die erste Stufe des Compilers. Er wandelt den rohen Zeichenstrom (Source Code) in eine Folge von Tokens um.</p> <ul> <li>Input: Quellprogramm (Buchstaben, Ziffern, Sonderzeichen).</li> <li>Output: Tokens f\u00fcr den Parser.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#konkrete-tatigkeiten","title":"Konkrete T\u00e4tigkeiten","text":"<ul> <li>Tokenisierung: Erfasst zusammengeh\u00f6rige Zeichen als logische Einheiten (z. B. <code>if</code>, <code>123</code>, <code>variableName</code>).</li> <li>Bereinigung: Entfernt alles, was f\u00fcr die Syntax irrelevant ist (Leerzeichen, Tabs, Zeilenumbr\u00fcche, Kommentare).</li> <li>Symboltabelle: Erstellt oft schon erste Eintr\u00e4ge in der Symboltabelle (z. B. f\u00fcr Bezeichner).</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#funktionsweise-interaktion","title":"Funktionsweise &amp; Interaktion","text":"<p>Der Lexer arbeitet nicht auf Vorrat, sondern \"on demand\":</p> <ul> <li>Der Parser ruft <code>getNextToken</code> auf.</li> <li>Der Lexer liest den Input und sucht die l\u00e4ngste Zeichenfolge (Longest Match / Maximal Munch), die auf ein Token-Muster passt.</li> <li>Er gibt dieses Token an den Parser zur\u00fcck.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#erstellung","title":"Erstellung","text":"<p>Man schreibt Lexer selten komplett per Hand, sondern nutzt Scanner-Generatoren (wie JFlex oder Lex/Flex).</p> <ul> <li>Eingabe: Regul\u00e4re Ausdr\u00fccke f\u00fcr jedes Token.</li> <li>Ausgabe des Tools: Fertiger Code (in Java oder C), der einen Endlichen Automaten implementiert.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#fehlerbehandlung","title":"Fehlerbehandlung","text":"<p>Der Lexer versteht keine Logik oder komplexe Syntax (er wei\u00df nicht, ob <code>i(x)</code> ein Tippfehler f\u00fcr <code>if(x)</code> ist).</p> <ul> <li>Wenn kein Muster passt: Der Lexer darf nicht abst\u00fcrzen (Crash/Exception sind verboten!).</li> <li>L\u00f6sung: \"Panikmodus\". Er l\u00f6scht/ignoriert einfach so lange Eingabezeichen (z. B. bis zum Zeilenende), bis er wieder ein bekanntes Token erkennen kann.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#jflex","title":"JFlex","text":""},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#grundstruktur-einer-jflex-datei","title":"Grundstruktur einer .jflex Datei","text":"<p>JFlex-Dateien sind in drei Abschnitte unterteilt, die durch <code>%%</code> getrennt werden.</p> <pre><code>/* 1. USER CODE (Imports, Package) */\npackage mein.compiler;\nimport java_cup.runtime.*;\n\n%%\n\n/* 2. OPTIONEN &amp; MAKROS */\n%class MeinLexer\n%unicode\n%line\n%column\n\n/* Makro-Definitionen */\nDigit = [0-9]\nLetter = [a-zA-Z]\n\n%%\n\n/* 3. REGELN (Lexical Rules) */\n/* Syntax:  Regex   { Java Code } */\n\n\"if\"         { return symbol(sym.IF); }\n{Digit}+     { return symbol(sym.NUM, Integer.parseInt(yytext())); }\n.            { throw new Error(\"Unerwartetes Zeichen\"); }\n</code></pre>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#wichtige-operatoren-syntax","title":"Wichtige Operatoren &amp; Syntax","text":"<p>Wie man Muster definiert.</p> Operator Beschreibung Beispiel Matcht... <code>|</code> Oder (Alternative) `a <code>*</code> Kleene-Stern <code>a*</code> 0 bis unendlich viele \"a\" <code>+</code> Plus <code>a+</code> 1 bis unendlich viele \"a\" <code>?</code> Optional <code>a?</code> Kein oder ein \"a\" <code>(...)</code> Gruppierung <code>(ab)+</code> \"ab\", \"abab\", ... <code>.</code> Punkt <code>.</code> Jedes Zeichen (au\u00dfer Newline) <code>\\</code> Escape <code>\\.</code> Einen echten Punkt <code>~</code> Bis-Zu (JFlex Special) <code>~\"\\n\"</code> Allesbis zum Zeilenumbruch"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#literale-vs-regex","title":"Literale vs. Regex","text":"<p>In JFlex ist der Unterschied zwischen Text und Code strikt.</p> Schreibweise Bedeutung Erkl\u00e4rung <code>\"wort\"</code> String-Literal Matcht exakt die Zeichenfolge<code>wort</code>. Sonderzeichen darin (wie <code>*</code>) verlieren ihre Bedeutung. <code>wort</code> Regex / Makro Versucht ein Makro namens<code>wort</code> zu finden oder interpretiert es als Regex. <code>\" \"</code> Leerzeichen Leerzeichen m\u00fcssen oft in Anf\u00fchrungszeichen stehen, sonst denkt JFlex, der Java-Code beginnt. <code>\\\\</code> Backslash Muss auch innerhalb von Anf\u00fchrungszeichen escaped werden:<code>\"\\\\\"</code> matcht <code>\\</code>."},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#makros-definition-nutzung","title":"Makros (Definition &amp; Nutzung)","text":"<p>Makros machen den Code lesbar. Sie funktionieren wie Variablen f\u00fcr Regex-Teile.</p> <p>1. Definition (Abschnitt 2)</p> <ul> <li>Links der Name, rechts der Regex.</li> <li>Keine geschweiften Klammern hier!</li> </ul> <pre><code>Identifier = [a-zA-Z]+\nWhitespace = [ \\t\\r\\n]+\n</code></pre> <p>2. Benutzung (Abschnitt 3)</p> <ul> <li>Muss in geschweifte Klammern <code>{}</code> gesetzt werden.</li> </ul> <pre><code>{Identifier}   { System.out.println(\"ID gefunden: \" + yytext()); }\n{Whitespace}   { /* ignorieren */ }\n</code></pre>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#zeichenklassen","title":"Zeichenklassen","text":"<p>Definition von Mengen erlaubter Zeichen.</p> Syntax Bedeutung Beispiel <code>[...]</code> Menge <code>[abc]</code> (a, b oder c) <code>[ - ]</code> Bereich <code>[0-9]</code> (Ziffern 0-9) <code>[^...]</code> Negation <code>[^abc]</code> (Alles au\u00dfer a, b, c) <code>&amp;&amp;</code> Schnittmenge <code>[a-z]&amp;&amp;[^aeiou]</code> (Kleinbuchstaben ohne Vokale)"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#matching-reihenfolge","title":"Matching-Reihenfolge","text":"<p>Wenn mehrere Regeln auf den Input passen, entscheidet JFlex so:</p> <ol> <li>Longest Match: Die Regel, die den l\u00e4ngsten String abdeckt, gewinnt.</li> </ol> <ul> <li>Beispiel: Input <code>ifvar</code> \u2192 matcht <code>{Identifier}</code>, nicht <code>\"if\"</code>.</li> </ul> <ol> <li>First Match: Bei gleicher L\u00e4nge gewinnt die Regel, die weiter oben in der Datei steht.</li> </ol> <ul> <li>Wichtig: Spezifische Keywords (<code>\"if\"</code>) m\u00fcssen vor allgemeinen Regeln (<code>{Identifier}</code>) stehen.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#nutzliche-snippets","title":"N\u00fctzliche Snippets","text":"<p>Zeilenumbruch (Plattformunabh\u00e4ngig):</p> <pre><code>LineTerminator = \\r|\\n|\\r\\n\n</code></pre> <p>Kommentare (C-Style <code>/* ... */</code>):</p> <pre><code>Comment = \"/*\" [^*] ~\"*/\" | \"/*\" \"*\"+ \"/\"\n</code></pre> <p>(Hinweis: Echte C-Kommentare sind etwas komplexer wegen geschachtelten Sternen, aber dies ist die einfache JFlex-Variante)</p> <p>String-Literale (z.B. <code>\"Hallo\"</code>):</p> <pre><code>String = \\\"[^\\\"]*\\\"\n</code></pre>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#tokenerkennung","title":"Tokenerkennung","text":""},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#ubergangsdiagramme-endliche-automaten","title":"\u00dcbergangsdiagramme (Endliche Automaten)","text":"<p>Der Lexer basiert auf Deterministischen Endlichen Automaten (DFA).</p> <ul> <li>Prinzip: Der Lexer startet bei Zustand 0. Er liest ein Zeichen und folgt dem Pfeil, der mit diesem Zeichen beschriftet ist, zum n\u00e4chsten Zustand.</li> <li>Ziel: Einen \"akzeptierenden Zustand\" (Endzustand) erreichen. Das bedeutet, ein g\u00fcltiges Token (z. B. eine Zahl, ein Operator) wurde erkannt.</li> <li>Verzweigung: Wenn der Lexer ein <code>&lt;</code> liest, wei\u00df er noch nicht, welches Token es wird. Er muss weiterlesen, um zu unterscheiden, ob es <code>&lt;</code> (kleiner), <code>&lt;=</code> (kleiner gleich) oder <code>&lt;&gt;</code> (ungleich) ist.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#retract-problem-lookahead","title":"\"Retract\"-Problem (Lookahead)","text":"<p>Dies ist das wichtigste technische Detail beim Scannen.</p> <ul> <li>Das Problem: Oft wei\u00df der Automat erst, dass ein Token zu Ende ist, wenn er bereits ein Zeichen zu viel gelesen hat, das gar nicht mehr dazu geh\u00f6rt.</li> <li>Beispiel: Der Lexer soll <code>&gt;</code> erkennen.<ol> <li>Er liest <code>&gt;</code>. (K\u00f6nnte auch der Anfang von <code>&gt;=</code> sein).</li> <li>Er liest das n\u00e4chste Zeichen, z. B. ein <code>a</code> (vom Variablennamen <code>anzahl</code>).</li> <li>Erkenntnis: Es ist kein <code>=</code>, also war das Token <code>&gt;</code> hier zu Ende.</li> </ol> </li> <li>Die Aktion (Retract): Das Zeichen <code>a</code> wurde schon \"konsumiert\". Es muss nun zur\u00fcck in den Eingabepuffer geschoben werden, damit es beim n\u00e4chsten Aufruf des Lexers als erstes Zeichen gelesen wird. In Diagrammen wird dies oft mit einem Sternchen (<code>*</code>) am Endzustand markiert.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#identifier-ids-vs-keywords","title":"Identifier (IDs) vs. Keywords","text":"<p>Automaten k\u00f6nnen strukturell kaum zwischen Variablennamen (IDs) und Schl\u00fcsselw\u00f6rtern unterscheiden, da beide aus Buchstabenfolgen bestehen.</p> <ul> <li>Falscher Ansatz: F\u00fcr jedes Schl\u00fcsselwort (<code>if</code>, <code>while</code>, <code>return</code>) einen eigenen Pfad im Automaten bauen. Das w\u00fcrde den Automaten riesig machen.</li> <li>Richtiger Ansatz:<ol> <li>Der Automat hat nur einen generischen Pfad f\u00fcr \"W\u00f6rter\" (Buchstabe gefolgt von Buchstaben/Zahlen).</li> <li>Ist das Wort fertig eingelesen, wird in einer Symboltabelle (Liste reservierter W\u00f6rter) nachgeschlagen.</li> <li>Logik: Steht das Wort in der Liste? \\(\\rightarrow\\) Token <code>KEYWORD</code>. Wenn nicht \\(\\rightarrow\\) Token <code>ID</code>.</li> </ol> </li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#automaten","title":"Automaten","text":"<p>F\u00fcr Theorie-Aufgaben ist der Unterschied der Automatentypen wichtig:</p> <ul> <li>NFA (Nicht-deterministisch): Erlaubt \"Raten\". Es kann von einem Zustand mehrere Pfeile f\u00fcr das gleiche Zeichen geben (oder Spr\u00fcnge ohne Zeichen). Gut f\u00fcr Menschen zum Entwerfen, schlecht f\u00fcr Computer.</li> <li>DFA (Deterministisch): Eindeutig. F\u00fcr jedes Zeichen gibt es genau einen definierten Weg.</li> <li>Workflow: Man definiert Muster als Regul\u00e4re Ausdr\u00fccke, wandelt diese (theoretisch) in NFAs um und optimiert sie schlie\u00dflich zu DFAs, um sie effizient zu programmieren.</li> </ul>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#formale-definition_1","title":"Formale Definition","text":"<p>Ein Automat besteht immer aus 5 Teilen \\((\\Sigma, S, \\delta, s_0, S_F)\\):</p> <ol> <li>\\(\\Sigma\\) (Alphabet): Welche Zeichen darf ich lesen? (z. B. <code>a</code>, <code>b</code>, <code>0</code>, <code>1</code>).</li> <li>\\(S\\) (Zust\u00e4nde): Alle Kreise im Bild.</li> <li>\\(s_0\\) (Start): Der Start-Pfeil (hier geht's los).</li> <li>\\(S_F\\) (Endzust\u00e4nde): Die doppelten Kreise (hier ist das Wort g\u00fcltig).</li> <li>\\(\\delta\\) (\u00dcberg\u00e4nge): Die Pfeile zwischen den Kreisen (Regelwerk: Wo gehe ich hin bei welchem Zeichen?).</li> </ol>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#tabellengetriebener-ansatz","title":"Tabellengetriebener Ansatz","text":"<p>Anstatt den Automaten durch verschachtelte Kontrollstrukturen (wie <code>switch-case</code>) hart zu kodieren, wird die \u00dcbergangsfunktion \\(\\delta\\) in einer Datenstruktur abgebildet.</p> <p>\u00dcbergangsmatrix Man verwendet eine zweidimensionale Tabelle (Matrix/Array), um die Zustands\u00fcberg\u00e4nge zu speichern.</p> <ul> <li>Zeilen: Repr\u00e4sentieren die Menge aller Zust\u00e4nde \\(S\\).</li> <li>Spalten: Repr\u00e4sentieren das Eingabealphabet \\(\\Sigma\\).</li> </ul> <p>Zugriff Der n\u00e4chste Zustand wird durch einen direkten Tabellenzugriff ermittelt: <code>Table[aktueller_Zustand][eingabe_Zeichen] = ziel_Zustand</code></p> <p>Fehlerbehandlung Ein leerer Eintrag (oder ein spezieller Fehlerwert) in der Matrix an der Stelle <code>[j][k]</code> bedeutet, dass f\u00fcr den Zustand <code>j</code> mit dem Zeichen <code>k</code> kein \u00dcbergang definiert ist. Dies entspricht einem Syntaxfehler im Eingabecode.</p>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#nfa-zu-dfa-buchi-algorithmus","title":"NFA zu DFA (B\u00fcchi-Algorithmus)","text":"<ol> <li> <p>Ziel:   Umwandlung eines nichtdeterministischen Automaten (NFA) in einen deterministischen Automaten (DFA).</p> </li> <li> <p>Hauptoperationen:</p> <ul> <li>\u03b5-closure: Berechnung aller Zust\u00e4nde, die durch \u03b5-\u00dcberg\u00e4nge (ohne Eingabezeichen) erreichbar sind.</li> <li>move: Bestimmung, wohin man mit einem Eingabesymbol von einem Zustand aus geht.</li> </ul> </li> <li> <p>Ablauf:</p> <ul> <li>Beginne mit der \u03b5-closure des Startzustands des NFA.</li> <li>Berechne f\u00fcr jedes Eingabesymbol move(T, a) und dann \u03b5-closure(move(T, a)).</li> <li>Wiederhole, bis alle Zust\u00e4nde des DFA bestimmt sind.</li> </ul> </li> <li> <p>Ergebnis:   Ein deterministischer Automat (DFA) mit einer Menge von NFA-Zust\u00e4nden als DFA-Zust\u00e4nde.</p> </li> </ol>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#regex-zu-nfa-yamada-thompson","title":"Regex zu NFA (Yamada-Thompson)","text":"<p>Der Yamada-Thompson-Algorithmus ist ein Verfahren zur Umwandlung eines regul\u00e4ren Ausdrucks (Regex) in einen NFA. Dabei wird der regul\u00e4re Ausdruck schrittweise in eine Zustandsmaschine umgewandelt.</p>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#schritte","title":"Schritte:","text":"<ol> <li>Regex aufteilen: Der regul\u00e4re Ausdruck wird in seine Grundbausteine (Operationen wie Konkatenation, Vereinigung, Kleene-Stern) zerlegt.</li> <li>Teil-NFAs erstellen: F\u00fcr jede Operation (z. B. \u201e|\u201c f\u00fcr Vereinigung, \u201e*\u201c f\u00fcr Kleene-Stern) wird ein eigener NFA konstruiert.</li> <li>Zust\u00e4nde verkn\u00fcpfen: Diese Teil-NFAs werden dann miteinander verkn\u00fcpft, um den vollst\u00e4ndigen NFA zu bilden.</li> </ol>"},{"location":"Compiler/Vorlesung/2.%20Lexikalische%20Analyse/#effizienz","title":"Effizienz","text":"<ul> <li>NFA (Der \"Sichere\"):<ul> <li>Bau: Sehr schnell und braucht wenig Speicher (\\(O(|r|)\\)).</li> <li>Laufzeit: Etwas langsamer, weil er beim Lesen des Textes mehrere Zust\u00e4nde gleichzeitig verwalten muss.</li> </ul> </li> <li>DFA (Der \"Schnelle, aber Riskante\"):<ul> <li>Bau: Kann extrem lange dauern und den Speicher sprengen (exponentielles Wachstum der Zust\u00e4nde m\u00f6glich).</li> <li>Laufzeit: Unschlagbar schnell (\\(O(|x|)\\)), da er pro Zeichen immer nur exakt einen Schritt macht.</li> </ul> </li> </ul> <p>Obwohl der DFA beim Scannen schneller w\u00e4re, nutzen viele Tools (Scanner-Generatoren) lieber die NFA-Simulation.</p>"},{"location":"Prozessrechentechnik/1.Einleitung/","title":"1. Einleitung","text":""},{"location":"Prozessrechentechnik/1.Einleitung/#inhalte","title":"Inhalte","text":"<ul> <li>Die Begriffe \u201eProzess\u201c und \u201eProzessrechentechnik\u201c</li> <li>Indirekte vs. direkte Kopplung</li> <li>Echtzeitanforderungen (weiche vs. harte)</li> <li>Klassifikationen von Computersystemen</li> <li>Charakteristiken und Anwendungsfelder eingebetteter Systeme (ES)</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#wichtige-konzepte","title":"Wichtige Konzepte","text":""},{"location":"Prozessrechentechnik/1.Einleitung/#definitionen","title":"Definitionen","text":"<p>Prozess Eine Umformung, Speicherung oder Transport von Materie, Energie oder Information. Ein Technischer Prozess ist ein Prozess, der mit technischen Mitteln gemessen, gesteuert oder geregelt werden kann.</p> <p>Prozessrechentechnik Ein Teilgebiet der Informatik, das sich mit dem Einsatz von Rechensystemen f\u00fcr das Messen, Steuern oder Regeln (MSR) technischer Prozesse befasst. Synonyme: Prozessdatenverarbeitung (PDV), Prozessinformatik.</p>"},{"location":"Prozessrechentechnik/1.Einleitung/#kopplung","title":"Kopplung","text":"<p>Die Art und Weise, wie der Rechner mit dem Prozess interagiert.</p>"},{"location":"Prozessrechentechnik/1.Einleitung/#indirekte-kopplung-offline","title":"Indirekte Kopplung (\"offline\")","text":"<p>Der Mensch ist Teil der Kette zwischen technischem Prozess und Prozessrechner. Daten werden erfasst, manuell eingegeben und sp\u00e4ter verarbeitet.</p>"},{"location":"Prozessrechentechnik/1.Einleitung/#direkte-kopplung-online","title":"Direkte Kopplung (\"online\")","text":"<p>Der Rechner ist elektrisch direkt mit dem Prozess verbunden. Die Richtung des Datenflusses bestimmt die Aktion:</p> <ul> <li>Messen: Prozess \\(\\to\\) Rechner</li> <li>Steuern: Rechner \\(\\to\\) Prozess</li> <li>Regeln: Bidirektional (Rechner vergleicht Ist- mit Sollwert und wirkt auf Prozess zur\u00fcck).</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#echtzeitanforderungen-ez","title":"Echtzeitanforderungen (EZ)","text":"<p>Die korrekte Funktion h\u00e4ngt nicht nur von der logischen Korrektheit der Ergebnisse ab, sondern auch vom Zeitpunkt ihrer Bereitstellung. Ein logisch richtiges Ergebnis zur falschen Zeit wird als Fehler gewertet.</p>"},{"location":"Prozessrechentechnik/1.Einleitung/#weiche-echtzeit-soft-real-time","title":"Weiche Echtzeit (Soft Real-Time)","text":"<p>Das Verpassen einer Deadline ist tolerierbar, f\u00fchrt aber zu einer Qualit\u00e4tsminderung (z. B. Ruckeln im Video, Komfortverlust).</p> <ul> <li>Konsequenz: Der Wert des Ergebnisses sinkt nach der Deadline allm\u00e4hlich ab.</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#harte-echtzeit-hard-real-time","title":"Harte Echtzeit (Hard Real-Time)","text":"<p>Das Verpassen einer Deadline ist nicht tolerierbar und kann katastrophale Folgen haben (z. B. Airbag-Ausl\u00f6sung, ABS-Bremsung).</p> <ul> <li>Konsequenz: Der Wert des Ergebnisses f\u00e4llt nach der Deadline sofort auf null oder wird sogar negativ (Schaden).</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#klassifikationen-von-computersystemen","title":"Klassifikationen von Computersystemen","text":""},{"location":"Prozessrechentechnik/1.Einleitung/#transformationelle-systeme","title":"Transformationelle Systeme","text":"<ul> <li>Transformieren Eingaben, die zu Beginn der Verarbeitung vollst\u00e4ndig vorliegen, in Ausgaben.</li> <li>Ausgaben sind erst nach Abschluss der Verarbeitung verf\u00fcgbar.</li> <li>Es findet keine Interaktion mit der Umgebung w\u00e4hrend der Verarbeitung statt (typisch f\u00fcr klassische IT-Batch-Systeme, Compiler, wissenschaftliche Berechnungen).</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#interaktive-systeme","title":"Interaktive Systeme","text":"<ul> <li>Erzeugen Ausgaben nicht nur am Ende, sondern interagieren und synchronisieren sich stetig mit ihrer Umgebung.</li> <li>Die Interaktion wird durch das System selbst bestimmt (proaktiv).</li> <li>Beispiel: Ein System fragt den Nutzer nach einer Eingabe (Prompt).</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#reaktive-systeme","title":"Reaktive Systeme","text":"<ul> <li>Die Interaktion/Synchronisation wird von der Umgebung bestimmt.</li> <li>Das System muss in vorgegebener Zeit auf Stimuli (Ereignisse) der Umgebung reagieren.</li> <li>Das Verhalten h\u00e4ngt von der aktuellen Eingabe UND dem internen Zustand des Systems ab.</li> <li>Wichtige Aspekte: Sicherheit und Rechtzeitigkeit.</li> <li>Dies ist die typische Klasse f\u00fcr Eingebettete Systeme.</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#hybride-systeme","title":"Hybride Systeme","text":"<ul> <li>Systeme, die sowohl analoge als auch digitale Komponenten besitzen und verarbeiten.</li> </ul>"},{"location":"Prozessrechentechnik/1.Einleitung/#charakteristiken-eingebetteter-systeme-es","title":"Charakteristiken Eingebetteter Systeme (ES)","text":"<p>Eingebettete Systeme unterscheiden sich fundamental von klassischen Desktop-Systemen durch folgende Eigenschaften:</p> <ol> <li>Mit der physikalischen Umwelt verbunden: \u00dcber Sensoren und Aktuatoren direkt an den Prozess gekoppelt.</li> <li>Reaktiv: Sie reagieren kontinuierlich auf externe Ereignisse.</li> <li>Echtzeitf\u00e4hig: Sie m\u00fcssen oft harte oder weiche Zeitbedingungen (\"Deadlines\") einhalten.</li> <li>Effizient: Starke Ressourcenbeschr\u00e4nkungen erfordern Optimierung hinsichtlich Preis, Gewicht, Energieverbrauch und Codegr\u00f6\u00dfe.</li> <li>Verl\u00e4sslich: Hohe Anforderungen an Zuverl\u00e4ssigkeit (Reliability) und Funktionale Sicherheit (Safety), da Fehlfunktionen physische Sch\u00e4den verursachen k\u00f6nnen.</li> </ol>"},{"location":"Prozessrechentechnik/1.Einleitung/#vergleich-es-vs-it-systeme","title":"Vergleich: ES vs. IT-Systeme","text":"Merkmal IT-Systeme (z. B. Buchhaltung) Eingebettete Systeme (ES) Hauptaufgabe Datenverwaltung / Transformation Steuerung technischer Prozesse Interaktion Transformationell / Interaktiv Reaktiv (System reagiert auf Umwelt) Zeitverhalten \"Best Effort\" (so schnell wie m\u00f6glich) Echtzeit (garantierte Reaktionszeiten) Hardware Standard-PC / Server Spezialhardware, Mikrocontroller, ASICs"},{"location":"Prozessrechentechnik/1.Einleitung/#anwendungsfelder","title":"Anwendungsfelder","text":"<p>Eingebettete Systeme sind allgegenw\u00e4rtig (\u201eInvisible Computing\u201c).</p> <ul> <li>Automobilbereich: Ein modernes Auto enth\u00e4lt bis zu 100 Steuerger\u00e4te (ECUs), vernetzt \u00fcber Bussysteme wie LIN, CAN oder FlexRay.</li> <li>Avionik: Flugsteuerung (Fly-by-Wire).</li> <li>Medizintechnik: Herzschrittmacher, Bildgebende Verfahren.</li> <li>Telekommunikation: Router, Smartphones, Basisstationen.</li> <li>Fabrikautomatisierung: SPS-Steuerungen, Industrieroboter.</li> </ul>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/","title":"2. Begriffe und Grundlagen","text":""},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#inhalte","title":"Inhalte","text":"<ul> <li>Signale (Klassifikation, Quantisierung)</li> <li>Signaltransformationen (A/D- und D/A-Wandlung)</li> <li>\u00dcbertragungssysteme (LTI-Systeme)</li> <li>Identifizierung des \u00dcbertragungsverhaltens (Impulsantwort)</li> <li>Modellierung mit Blockschaltbildern</li> </ul>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#wichtige-konzepte","title":"Wichtige Konzepte","text":""},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#definition-signal","title":"Definition Signal","text":"<p>Ein Signal ist die Darstellung einer Information durch eine zeitver\u00e4nderliche physikalische Gr\u00f6\u00dfe (z. B. Spannung, Strom). Die eigentliche Information wird durch einen Parameter dieser Gr\u00f6\u00dfe kodiert (z. B. Amplitude, Frequenz, Phase).</p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#signalklassifikation","title":"Signalklassifikation","text":"<p>Man unterscheidet Signale nach ihrem Verhalten \u00fcber die Zeit und \u00fcber ihren Wertebereich.</p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#deterministisch-vs-stochastisch","title":"Deterministisch vs. Stochastisch","text":"<ul> <li>Deterministisch: Der Signalverlauf ist analytisch beschreibbar.<ul> <li>Periodisch (wiederkehrend)</li> <li>Transient / Aperiodisch (einmalig, abklingend)</li> </ul> </li> <li>Stochastisch: Zuf\u00e4lliger Verlauf (z. B. Rauschen), nur statistisch beschreibbar.</li> </ul>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#kontinuierlich-vs-diskret","title":"Kontinuierlich vs. Diskret","text":"<p>Diese Attribute werden sowohl auf die Zeitachse (\\(t\\)) als auch auf den Wertebereich (Amplitude) angewandt:</p> Attribut Zeitachse (\\(t\\)) Wertebereich (Amplitude) Kontinuierlich Signal ist zu jedem Zeitpunkt definiert. Signal kann jeden beliebigen Zwischenwert annehmen (\\(\\infty\\) viele Werte). Diskret Signal ist nur zu bestimmten Zeitpunkten definiert (z.B. \\(t_k\\)). Signal kann nur aus einem begrenzten Vorrat an Werten w\u00e4hlen (Stufen)."},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#die-4-signalklassen","title":"Die 4 Signalklassen","text":"<p>Aus der Kombination ergeben sich vier Grundtypen:</p> <ol> <li>Analoges Signal: Zeit- und wertkontinuierlich (das physikalische Original).</li> <li>Amplitudenquantisiertes Signal: Zeitkontinuierlich, aber wertdiskret (Treppenfunktion).</li> <li>Abtastsignal: Zeitdiskret, aber wertkontinuierlich (Nadelimpulse mit exakter H\u00f6he).</li> <li>Digitales Signal: Zeit- und wertdiskret (eine Folge von Zahlen/Bits).</li> </ol>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#signaltransformation","title":"Signaltransformation","text":"<p>Beschreibt die Umwandlung zwischen den Signalklassen, insbesondere den Weg vom analogen Prozess zum digitalen Rechner und zur\u00fcck.</p> <p></p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#ad-wandlung-analog-digital","title":"A/D-Wandlung (Analog \u2192 Digital)","text":"<p>Der Prozess besteht aus zwei Hauptschritten: 1.  Abtastung (Sampling): Wandelt ein zeitkontinuierliches in ein zeitdiskretes Signal um (Analog \\(\\to\\) Abtastsignal). 2.  Quantisierung: Wandelt ein wertkontinuierliches in ein wertdiskretes Signal um. Dabei entsteht ein Quantisierungsfehler (Rauschen).</p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#da-wandlung-digital-analog","title":"D/A-Wandlung (Digital \u2192 Analog)","text":"<ol> <li>Halteglied: Wandelt die digitale Zahlenfolge meist in ein Treppensignal (Zeitkontinuierlich, wertdiskret).</li> <li>Gl\u00e4ttung/Interpolation: Ein Tiefpassfilter rekonstruiert aus dem Treppensignal oder den Abtastwerten wieder ein glattes, wertkontinuierliches Signal.</li> </ol> <p>Hinweis: \u00dcber reale physikalische Medien (Kabel, Funk) k\u00f6nnen effektiv nur Analogsignale \u00fcbertragen werden, da diese Medien immer eine Tiefpasswirkung und D\u00e4mpfung besitzen, die harte digitale Flanken \"verschleift\".</p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#ubertragungssysteme","title":"\u00dcbertragungssysteme","text":"<p>Ein mathematisches Modell, das beschreibt, wie ein System eine Ursache (Eingang \\(s_1(t)\\)) in eine Wirkung (Ausgang \\(s_2(t)\\)) umwandelt.</p> <p>In der Regelungstechnik betrachtet man meist LTI-Systeme (Linear, Time-Invariant):</p> <ul> <li>Linear: Es gilt das Superpositionsprinzip. Die Antwort auf eine Summe von Signalen ist gleich der Summe der einzelnen Antworten.</li> <li>Zeitinvariant: Das Systemverhalten \u00e4ndert sich nicht \u00fcber die Zeit (ein Experiment heute liefert das gleiche Ergebnis wie morgen).</li> <li>Kausal: Die Wirkung tritt nicht vor der Ursache ein.</li> </ul>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#identifikation-des-ubertragungsverhaltens","title":"Identifikation des \u00dcbertragungsverhaltens","text":"<p>Wie findet man heraus, was ein System (\"Black Box\") tut? Man nutzt Testsignale.</p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#dirac-impuls-t","title":"Dirac-Impuls (\u03b4(t))","text":"<p>Ein theoretisches Testsignal von unendlich kurzer Dauer und unendlich hoher Amplitude, aber definierter Fl\u00e4che.</p> <ul> <li>Modell: Rechteckimpuls der Breite \\(2/\\tau\\) und H\u00f6he \\(\\tau/2\\) (f\u00fcr \\(\\tau \\to \\infty\\)).</li> <li>Fl\u00e4che (Energie):</li> </ul> \\[\\text{Fl\u00e4che} = \\text{Breite} \\times \\text{H\u00f6he} = \\frac{2}{\\tau} \\times \\frac{\\tau}{2} = 1\\]"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#impulsantwort-ht","title":"Impulsantwort (h(t))","text":"<ul> <li>Die Impulsantwort ist das Ausgangssignal eines Systems, wenn man am Eingang einen Dirac-Impuls \\(\\delta(t)\\) anlegt.</li> <li>Bedeutung: Bei einem LTI-System beschreibt \\(h(t)\\) das \u00dcbertragungsverhalten vollst\u00e4ndig. Kennt man \\(h(t)\\), kann man die Reaktion auf jedes beliebige Eingangssignal berechnen (Faltung).</li> </ul>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#modellierung-mit-blockschaltbildern","title":"Modellierung mit Blockschaltbildern","text":"<p>Komplexe dynamische Systeme werden durch die Verschaltung elementarer Bl\u00f6cke dargestellt. Die Grundlage bilden physikalische Differentialgleichungen (DGL).</p>"},{"location":"Prozessrechentechnik/2.Begriffe_und_Grundlagen/#beispiel-masse-feder-dampfer-system","title":"Beispiel: Masse-Feder-D\u00e4mpfer-System","text":"<p>Ein mechanisches System 2. Ordnung. Es wirkt eine externe Kraft \\(F(t)\\), w\u00e4hrend Tr\u00e4gheit, Federkraft und D\u00e4mpfung entgegenwirken.</p> <ul> <li>Parameter: Masse \\(m\\), Federkonstante \\(c\\), D\u00e4mpfungsfaktor \\(b\\).</li> <li>Reibungsmodell: Hier z.B. Newton-Reibung (quadratisch zur Geschwindigkeit), was eine Nichtlinearit\u00e4t darstellt.</li> <li>DGL:</li> </ul> \\[mx''(t) = F(t) - c \\cdot x(t) - b \\cdot \\text{sign}(x'(t)) \\cdot (x'(t))^2\\] <p>(Hinweis: \\(x(t)\\) ist die Position, \\(x'(t)\\) die Geschwindigkeit, \\(x''(t)\\) die Beschleunigung).</p> <p>Dieses Modell kann direkt in Tools wie Simulink durch Integrator-Bl\u00f6cke, Verst\u00e4rkungs-Bl\u00f6cke (Gain) und Summierer nachgebaut werden.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/","title":"3. Aufbau eingebetteter Systeme","text":""},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#inhalte","title":"Inhalte","text":"<ul> <li>MSR-Kreislauf (Messen, Steuern, Regeln)</li> <li>Anbindung an den technischen Prozess (Sample&amp;Hold-Schaltungen, A/D-Wandlung)</li> <li>Sensoren und Aktuatoren</li> <li>Verarbeitungseinheiten (Prozessoren, rekonfigurierbare Logiken, ASICs)</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#wichtige-konzepte","title":"Wichtige Konzepte","text":""},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#msr-kreislauf","title":"MSR-Kreislauf","text":"<p>Beschreibt den geschlossenen Regelkreis. 1.  Sensorik: Erfasst den Prozesszustand (Messgr\u00f6\u00dfenaufnahme, Wandlung, Aufbereitung). 2.  Verarbeitung: Der Mikroprozessor (\\(\\mu P\\)) verarbeitet die Daten. 3.  Aktorik: Die Verarbeitungseinheit wirkt \u00fcber Leistungselektronik und Wandler wieder auf den Prozess ein.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#signalverarbeitungsprozess-ad-wandlung","title":"Signalverarbeitungsprozess (A/D-Wandlung)","text":"<p>Der Weg vom analogen Eingangssignal zum digitalen Signal.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#nyquist-shannon-abtasttheorem","title":"Nyquist-Shannon-Abtasttheorem","text":"<p>Die Abtastfrequenz \\(f_a\\) muss mindestens doppelt so hoch sein wie die h\u00f6chste im Signal vorkommende Frequenz (Grenzfrequenz \\(f_g\\)), um das Signal korrekt rekonstruieren zu k\u00f6nnen.</p> \\[f_a &gt; 2f_g\\]"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#aliasing","title":"Aliasing","text":"<p>Wird das Theorem verletzt (\\(f_a \\le 2f_g\\)), kommt es zu einer \u00dcberlappung der Frequenzspektren. Hohe Frequenzen werden f\u00e4lschlicherweise als niedrigere Frequenzen interpretiert, was zu massiven Messfehlern f\u00fchrt.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#anti-aliasing-filter","title":"Anti-Aliasing-Filter","text":"<p>Um Aliasing zu verhindern, wird ein Tiefpassfilter vor die Abtastung geschaltet. Es filtert alle Frequenzen oberhalb der halben Abtastrate (\\(f_g &lt; f_a/2\\)) heraus. Oft wird ein einfaches passives RC-Glied genutzt, dessen Grenzfrequenz \\(f_g\\) sich berechnet als:</p> \\[f_g = \\frac{1}{2\\pi RC}\\]"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#sample-hold-sh-zeitquantisierung","title":"Sample &amp; Hold (S&amp;H) / Zeitquantisierung","text":"<p>Eine Schaltung (im Prinzip ein Schalter mit Kondensator), die den analogen Spannungswert am Abtastzeitpunkt \"einfriert\" und f\u00fcr die Dauer der A/D-Wandlung konstant h\u00e4lt. Dies ist n\u00f6tig, da der Wandler eine gewisse Zeit (Wandlungszeit) ben\u00f6tigt.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#ad-wandler-amplitudenquantisierung","title":"A/D-Wandler / Amplitudenquantisierung","text":"<p>Setzt den konstanten analogen Spannungswert in einen diskreten digitalen Wert um.</p> <ul> <li>W\u00e4geverfahren (Successive Approximation): Ein direkter Wandler, der die Eingangsspannung schrittweise (Bit f\u00fcr Bit, von MSB zu LSB) mit einer Referenzspannung vergleicht (z.B. \\(U &gt; U_V/2\\)? \\(\\to\\) Bit = 1). Die Wandlungsdauer w\u00e4chst mit der Aufl\u00f6sung.</li> <li>Parallele Wandler (Flash): Sehr schnell, da alle \\(2^n-1\\) m\u00f6glichen Spannungsstufen gleichzeitig mit Komparatoren verglichen werden. Nachteil: Extrem hoher Schaltungsaufwand (z.B. 8-Bit \\(\\to\\) 255 Komparatoren).</li> <li>Integrierende Wandler (z.B. Dual-Slope): Langsam, aber sehr genau und robust, da die Spannung \u00fcber eine Zeit integriert wird.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#ruckfuhrungsprozess-da-wandlung","title":"R\u00fcckf\u00fchrungsprozess (D/A-Wandlung)","text":"<p>Der Weg vom digitalen Signal zur\u00fcck zum analogen Ausgangssignal.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#da-wandler-methoden","title":"D/A-Wandler Methoden","text":"<ul> <li>Widerstandsnetzwerk: Addiert Teilstr\u00f6me, die \u00fcber Schalter (gesteuert durch die Bits) gewichtet werden.</li> </ul> \\[I_S = \\frac{U_{\\text{ref}}}{2^{n-1}R} \\sum_{i=0}^{n-1} b_i 2^i\\] <ul> <li>R-2R-Kettenleiter:  Eine clevere Alternative, die nur zwei verschiedene Widerstandswerte (R und 2R) ben\u00f6tigt. Diese lassen sich mit sehr kleinen Toleranzen herstellen und sind daher f\u00fcr h\u00f6here Aufl\u00f6sungen besser geeignet.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#pulsweiten-modulation-pwm","title":"Pulsweiten-Modulation (PWM)","text":"<p>Eine alternative (digitale) Methode zur Erzeugung eines analogen Signals. Ein digitales Signal wird mit konstanter Frequenz, aber variablem Tastverh\u00e4ltnis (\\(t_{\\text{ein}} / t_{\\text{Periode}}\\)) ausgegeben. Ein nachgeschalteter Tiefpass filtert dieses Signal und erzeugt eine analoge Durchschnittsspannung:</p> \\[U_{\\text{aus}} = U_{\\text{ref}} \\cdot \\frac{t_{\\text{ein}}}{t_{\\text{Periode}}}\\] <p>(Anwendung: LED-Dimmung, Motor-Drehzahlsteuerung)</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#storungen-filterung","title":"St\u00f6rungen &amp; Filterung","text":"<ul> <li>Hazards (Glitches): Unerw\u00fcnschte, kurze Spannungsspitzen am D/A-Ausgang. Sie entstehen, wenn mehrere Bits nicht exakt synchron kippen (z.B. Wechsel <code>0111</code> \\(\\to\\) <code>1000</code>).</li> <li>Deglitcher (Hazard-Unterdr\u00fcckung): Ein S&amp;H-Verst\u00e4rker nach dem D/A-Wandler, der den letzten stabilen Analogwert h\u00e4lt, bis der neue Wert stabil ist.</li> <li>Datenrekonstruktion (Filter): Ein abschlie\u00dfender Tiefpassfilter gl\u00e4ttet den treppenartigen Spannungsverlauf am Ausgang zu einem sauberen Signal.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#sensoren","title":"Sensoren","text":"<p>Erfassen den Prozesszustand. Sie wandeln nichtelektrische Gr\u00f6\u00dfen (z. B. mechanisch, thermisch) in elektrische Gr\u00f6\u00dfen (z. B. U, I, R, C) um.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#klassifikation","title":"Klassifikation","text":"<ul> <li>Extrinsisch (erfassen Umgebung) vs. Intrinsisch (erfassen Systemzustand).</li> <li>Passiv/Rezeptiv (Stimulus erzeugt Energie/Signal) vs. Aktiv/Signalbearbeitend (Stimulus \u00e4ndert Parameter).</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#integrationsstufen","title":"Integrationsstufen","text":"<ol> <li>Elementarsensor: Rein physikalischer Wandler.</li> <li>Integrierter Sensor: Sensor + Signalaufbereitung/Verst\u00e4rkung.</li> <li>Intelligenter Sensor: Sensor + Aufbereitung + Vorverarbeitung (Digitalisierung, Skalierung).</li> </ol>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#beispiel-optischer-encoder","title":"Beispiel: Optischer Encoder","text":"<p>Ein inkrementeller Positions-/Winkelsensor. Ein Ma\u00dfstab (hell/dunkel) wird abgetastet. Zwei um 0.25 Perioden versetzte Detektoren (A und B) erm\u00f6glichen die Erkennung der Bewegungsrichtung und Z\u00e4hlung der Inkremente.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#beispiel-beschleunigungssensor-kapazitiv","title":"Beispiel: Beschleunigungssensor (Kapazitiv)","text":"<p>Basiert auf dem Prinzip \\(F = m \\cdot a\\). Eine tr\u00e4ge Masse (m) ist an Federn (k) als mittlere Platte eines Differentialkondensators (\\(C_1\\), \\(C_2\\)) befestigt. Eine Beschleunigung sorgt f\u00fcr Auslenkung \\(\\Delta d\\) und \u00e4ndert die Kapazit\u00e4ten gegenl\u00e4ufig.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#aktuatoren","title":"Aktuatoren","text":"<p>Wandeln elektrische Energie (Steuergr\u00f6\u00dfe) in mechanische Arbeit um.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#elektrische-antriebe-grundprinzip","title":"Elektrische Antriebe (Grundprinzip)","text":"<p>Nutzen die Lorentzkraft auf einen stromdurchflossenen Leiter in einem Magnetfeld: \\(F = I \\times B\\).</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#gleichstrommotor-dc","title":"Gleichstrommotor (DC)","text":"<ul> <li>Typen: B\u00fcrstenbehaftet (mechanische Kommutierung) oder B\u00fcrstenlos (BLDC, elektronisch).</li> <li>Drehmoment: \\(M = I \\cdot k\\) (linear vom Strom abh\u00e4ngig).</li> <li>Gegenspannung (EMK): \\(U_L = k \\cdot \\omega\\) (linear von Drehzahl abh\u00e4ngig).</li> <li>Kennlinie: \\(\\omega = \\frac{U}{k} - \\frac{R}{k^2} \\cdot M\\) (lineare Kennlinie).</li> <li>Betriebspunkte: Max. Drehmoment bei Stillstand. Max. Leistung bei halber Leerlaufdrehzahl.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#schrittmotor-stepper","title":"Schrittmotor (Stepper)","text":"<p>Ein Motor, der durch digitale Stromimpulse angesteuert wird.</p> <ul> <li>Winkelschritt: \\(\\alpha = 360 / (2p \\cdot m)\\)</li> <li>Vorteil: Positionierung ohne Sensor (\"open loop\") m\u00f6glich.</li> <li>Nachteil: Geringeres Drehmoment; Gefahr von Schrittverlusten bei \u00dcberlast.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#leistungselektronik-h-brucke","title":"Leistungselektronik (H-Br\u00fccke)","text":"<p>Eine Schaltung aus vier Schaltern (z.B. MOSFETs) zur Ansteuerung von DC-Motoren.</p> <ul> <li>Drehrichtung: Durch diagonales Schlie\u00dfen der Schalter (S1+S4 oder S2+S3).</li> <li>Regelung: \u00dcber PWM-Ansteuerung der Schalter wird die effektive Motorspannung variiert.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#verarbeitungseinheiten","title":"Verarbeitungseinheiten","text":"<p>Der Effizienz-/Flexibilit\u00e4tskonflikt:</p> <ul> <li>ASICs: H\u00f6chste Effizienz, keine Flexibilit\u00e4t.</li> <li>Prozessoren: Geringste Effizienz, h\u00f6chste Flexibilit\u00e4t.</li> <li>FPGAs: Liegen dazwischen.</li> </ul>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#asics-application-specific-integrated-circuits","title":"ASICs (Application-Specific Integrated Circuits)","text":"<p>Fest verdrahtete Schaltungen. Funktion ist nachtr\u00e4glich nicht \u00e4nderbar. Lohnen sich nur bei extrem hohen St\u00fcckzahlen oder extremen Effizienzanforderungen.</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#prozessoren","title":"Prozessoren","text":"<p>Flexibel programmierbar. Energieoptimierung durch angepasste Befehlss\u00e4tze (DSP), dynamische Taktung und Energiesparzust\u00e4nde (Run, Idle, Sleep).</p>"},{"location":"Prozessrechentechnik/3.Aufbau_eingebetteter_Systeme/#fpgas-field-programmable-gate-arrays","title":"FPGAs (Field Programmable Gate Arrays)","text":"<p>Rekonfigurierbare Logik. Die Funktion wird durch eine Konfigurationsdatei (Bitstream) in ein internes RAM geladen.</p> <ul> <li>CLB (Configurable Logic Block): Basisblock aus Look-Up Table (LUT) (f\u00fcr Logik), Flip-Flop (Speicher) und Multiplexern.</li> <li>SoC: Moderne FPGAs enthalten oft zus\u00e4tzlich feste Prozessorkerne (z.B. ARM).</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/","title":"4. Steuerung und Regelung","text":""},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#inhalte","title":"Inhalte","text":"<ul> <li>Filter (analoge und digitale Filter, Filtereigenschaften)</li> <li>Steuerung und Regelung (Begriffe, Blockschaltbilder)</li> <li>Kenngr\u00f6\u00dfen der Regelg\u00fcte (Stabilit\u00e4t, Robustheit)</li> <li>PID-Regler</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#filtertechnik","title":"Filtertechnik","text":""},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#filtereigenschaften","title":"Filtereigenschaften","text":""},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#frequenzselektivitat","title":"Frequenzselektivit\u00e4t","text":"<p>Filter werden oft nach ihrem Verhalten im Frequenzbereich klassifiziert. Sie besitzen einen Durchlassbereich (Signal passiert) und einen Sperrbereich (Signal wird ged\u00e4mpft).</p> <ul> <li>Tiefpass: L\u00e4sst tiefe Frequenzen durch (z. B. zur Unterdr\u00fcckung von hochfrequentem Sensor-Rauschen).</li> <li>Hochpass: L\u00e4sst hohe Frequenzen durch (z. B. um Gleichanteile/Offset auszufiltern).</li> <li>Bandpass: L\u00e4sst nur ein bestimmtes Frequenzband durch.</li> <li>Bandsperre: Sperrt ein bestimmtes Frequenzband (z. B. 50Hz-Brummen).</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#grenzfrequenz-fg","title":"Grenzfrequenz (f<sub>g</sub>)","text":"<p>Die Frequenz, bei der die Signal-Amplitude um 3 dB (Dezibel) abgefallen ist.</p> <ul> <li>Dies entspricht einer Reduzierung der Amplitude auf \\(1/\\sqrt{2} \\approx 70,7 \\%\\).</li> <li>Dies entspricht der halben Leistung des Signals.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#filterordnung","title":"Filterordnung","text":"<p>Beschreibt die h\u00f6chste Potenz in der mathematischen Modellierung (DGL oder \u00dcbertragungsfunktion).</p> <ul> <li>Bestimmt die Steilheit des \u00dcbergangsbereichs (Flankensteilheit).</li> <li>Faustregel: Pro Ordnung steigt die D\u00e4mpfung um 20 dB/Dekade (z. B. 2. Ordnung = 40 dB/Dekade).</li> <li>Trade-off: H\u00f6here Ordnung = steilere Flanke (besser), aber h\u00f6herer Realisierungsaufwand und l\u00e4ngere Laufzeit.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#analoge-filter","title":"Analoge Filter","text":"<p>Werden direkt durch elektronische Bauteile realisiert.</p> <ul> <li>Passiv: Bestehen nur aus passiven Bauteilen (R, L, C).<ul> <li>Ben\u00f6tigen keine Spannungsversorgung.</li> <li>Beispiel: Tiefpass 1. Ordnung (RC-Glied) \\(\\to f_g = \\frac{1}{2\\pi RC}\\).</li> </ul> </li> <li>Aktiv: Verwenden aktive Bauteile wie Operationsverst\u00e4rker (OPV).<ul> <li>Vorteile: K\u00f6nnen Signale auch verst\u00e4rken; erm\u00f6glichen Kaskadierung (Hintereinanderschaltung) ohne gegenseitige Beeinflussung.</li> <li>Nachteile: Ben\u00f6tigen Spannungsversorgung; OPV f\u00fcgt eigenes Rauschen hinzu; anf\u00e4llig f\u00fcr Alterung und Temperaturdrift.</li> </ul> </li> <li>Einsatz: Oft als Anti-Aliasing-Filter vor dem A/D-Wandler oder im sehr hohen Frequenzbereich.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#digitale-filter","title":"Digitale Filter","text":"<p>Verarbeiten abgetastete Zahlenfolgen (Signale) softwareseitig (MCU, DSP) oder in Hardware (FPGA). Mathematisch basieren sie auf Differenzengleichungen.</p>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#fir-finite-impulse-response","title":"FIR (Finite Impulse Response)","text":"<ul> <li>Nicht-rekursiv: Der Ausgangswert \\(x_n\\) h\u00e4ngt nur von aktuellen und alten Eingangswerten \\(y\\) ab (keine R\u00fcckkopplung).</li> <li>Formel: \\(x_n = \\sum b_k \\cdot y_{n-k}\\)</li> <li>Vorteile: Immer stabil (kann nicht schwingen); konstante Gruppenlaufzeit (keine Phasenverzerrung des Signals).</li> <li>Nachteile: Ben\u00f6tigt eine sehr hohe Ordnung (viele Rechenschritte) f\u00fcr steile Flanken.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#iir-infinite-impulse-response","title":"IIR (Infinite Impulse Response)","text":"<ul> <li>Rekursiv: Der Ausgangswert \\(x_n\\) h\u00e4ngt von Eingangswerten \\(y\\) UND alten Ausgangswerten \\(x\\) ab (R\u00fcckkopplung).</li> <li>Formel: \\(x_n = \\sum b_k \\cdot y_{n-k} + \\sum a_j \\cdot x_{n-j}\\)</li> <li>Vorteile: Sehr effizient. Erreicht steile Flanken mit wenigen Koeffizienten (geringe Rechenlast).</li> <li>Nachteile: Kann instabil werden (aufschwingen); phasenverzerrend (keine konstante Gruppenlaufzeit).</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#steuerung-und-regelung","title":"Steuerung und Regelung","text":""},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#steuerung-open-loop-control","title":"Steuerung (Open Loop Control)","text":"<ul> <li>Eine offene Wirkkette: Eingang \\(\\to\\) Steuerglied \\(\\to\\) Stellglied \\(\\to\\) Strecke \\(\\to\\) Ausgang.</li> <li>Die Berechnungen sind unabh\u00e4ngig vom Ist-Zustand der Strecke.</li> <li>Problem: St\u00f6rgr\u00f6\u00dfen (z. B. Seitenwind, Last\u00e4nderung) werden nicht erkannt und nicht korrigiert.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#regelung-closed-loop-control","title":"Regelung (Closed Loop Control)","text":"<ul> <li>Eine geschlossene Wirkkette (Regelkreis).</li> <li>Prinzip:<ol> <li>Der Istwert (Regelgr\u00f6\u00dfe \\(x(t)\\)) wird gemessen (R\u00fcckf\u00fchrung \\(r(t)\\)).</li> <li>Vergleich: Regeldifferenz \\(e(t) = w(t) - r(t)\\) (Sollwert - Istwert).</li> <li>Der Regler versucht, \\(e(t)\\) auf Null zu zwingen.</li> </ol> </li> <li>Vorteil: Kann St\u00f6rgr\u00f6\u00dfen aktiv ausgleichen.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#kenngroen-der-regelgute","title":"Kenngr\u00f6\u00dfen der Regelg\u00fcte","text":"<p>Wie gut arbeitet ein Regler? Man betrachtet meist die Sprungantwort (Reaktion auf eine sprunghafte \u00c4nderung des Sollwerts).</p>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#dynamische-regelgute-zeitverhalten","title":"Dynamische Regelg\u00fcte (Zeitverhalten)","text":"<ul> <li>Anregelzeit (\\(T_{An}\\)): Zeit, bis der Istwert erstmals den Toleranzbereich um den Sollwert erreicht.</li> <li>\u00dcberschwingweite (\\(X_o\\)): Maximale Abweichung \u00fcber den Sollwert hinaus (\u00dcberreaktion).</li> <li>Ausregelzeit (\\(T_{Aus}\\)): Zeit, bis der Istwert dauerhaft im Toleranzbereich bleibt (Einschwingen).</li> <li>Regelfl\u00e4che (\\(I_R\\)): Integral der Regeldifferenz (Gesamtfehler \u00fcber die Zeit).</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#stationare-regelgute-genauigkeit","title":"Station\u00e4re Regelg\u00fcte (Genauigkeit)","text":"<ul> <li>Bleibende Regeldifferenz (\\(e(\\infty)\\)): Der Fehler, der auch nach unendlich langer Zeit noch besteht (Genauigkeit im eingeschwungenen Zustand).</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#stabilitat-robustheit","title":"Stabilit\u00e4t &amp; Robustheit","text":"<ul> <li>Stabilit\u00e4t: Ein System ist stabil, wenn es nach einer St\u00f6rung in einen Ruhezustand zur\u00fcckkehrt (abklingt). Instabile Systeme schwingen sich unbegrenzt auf (Zerst\u00f6rungsgefahr).</li> <li>Robustheit: Die F\u00e4higkeit des Reglers, auch dann stabil und gut zu arbeiten, wenn sich die Parameter der Strecke \u00e4ndern (z. B. Auto wird schwerer durch Beladung).</li> <li>Zielkonflikt: Man kann meist nicht alles haben. Ein sehr schneller Regler neigt zum \u00dcberschwingen (weniger stabil). Ein sehr robuster Regler ist oft tr\u00e4ge.</li> </ul>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#pid-regler","title":"PID-Regler","text":"<p>Der Standard-Industrieregler. Er berechnet die Stellgr\u00f6\u00dfe \\(y(t)\\) aus drei parallelen Anteilen.</p> <p>Reglergleichung:</p> \\[y(t) = K_P \\cdot e(t) + K_I \\int e(t) dt + K_D \\cdot \\dot{e}(t)\\]"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#die-drei-anteile","title":"Die drei Anteile","text":"<ol> <li>P-Anteil (Proportional) \\(\\to\\) \"Gegenwart\"<ul> <li>Reagiert auf die aktuelle Abweichung.</li> <li>Wirkt sofort, hinterl\u00e4sst aber meist eine bleibende Regelabweichung.</li> </ul> </li> <li>I-Anteil (Integral) \\(\\to\\) \"Vergangenheit\"<ul> <li>Summiert die vergangenen Fehler auf.</li> <li>Solange ein Fehler existiert, w\u00e4chst der I-Anteil \\(\\to\\) zwingt den Fehler auf Null (keine bleibende Regelabweichung).</li> <li>Nachteil: Macht das System tr\u00e4ger und neigt zum \u00dcberschwingen.</li> </ul> </li> <li>D-Anteil (Differential) \\(\\to\\) \"Zukunft\"<ul> <li>Reagiert auf die \u00c4nderungsgeschwindigkeit des Fehlers.</li> <li>Wirkt d\u00e4mpfend (\"vorausdenkend\").</li> <li>Stabilisiert den Kreis und erlaubt aggressiveren P-Anteil.</li> </ul> </li> </ol>"},{"location":"Prozessrechentechnik/4.Steuerung_und_Regelung/#vergleichstabelle","title":"Vergleichstabelle","text":"Reglertyp Reaktion (Anregelzeit) \u00dcberschwingen Bleibende Regeldifferenz P Mittel Klein Ja (Nachteil) I Langsam Gro\u00df Nein (Vorteil) PI Mittel Mittel Nein PD Schnell Klein Ja PID Schnell Klein Nein (Ideal)"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/","title":"5. Modelierungstechniken","text":""},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#inhalte","title":"Inhalte","text":"<ul> <li>Modellbasiertes Design (Grundlagen, Evolution)</li> <li>Anforderungen an Modellierungssprachen</li> <li>Alternative Ausf\u00fchrungsmodelle (Rechenmodelle)</li> <li>Quality Gates im V-Modell (MIL, SIL, PIL, HIL)</li> <li>Rapid Prototyping</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#modellbasiertes-design-mbd","title":"Modellbasiertes Design (MBD)","text":""},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#grundlagen-definitionen","title":"Grundlagen &amp; Definitionen","text":"<p>Modell Eine zielorientierte Abstraktion einer Entit\u00e4t. Es ist eine Vereinfachung, die exakt jene Eigenschaften enth\u00e4lt, die f\u00fcr eine bestimmte Aufgabe relevant sind, w\u00e4hrend irrelevante Details weggelassen werden.</p> <p>Der MBD-Ansatz Ein Evolutionsschritt weg von der manuellen textuellen Programmierung (C/Assembler).</p> <ul> <li>Zentrales Artefakt: Die Software wird prim\u00e4r grafisch in Modellen (z. B. Simulink, ASCET) entworfen. Diese sind maschinenlesbar und haben eine eindeutige Semantik.</li> <li>Auto-Coding: Der finale Quellcode wird nicht manuell geschrieben, sondern durch einen Generator (Auto-Coder) automatisch erzeugt.</li> <li>Vorteil: Arbeit auf hoher Abstraktionsebene. Der Auto-Coder erzeugt hochoptimierten Code ohne den klassischen Konflikt zwischen Effizienz und Flexibilit\u00e4t.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#modellevolution","title":"Modellevolution","text":"<p>Der Prozess beschreibt die schrittweise Anreicherung des Modells ohne Informationsverlust.</p> <ol> <li>Physikalisches Modell: Rein funktionale Beschreibung (meist Floating-Point-Arithmetik).</li> <li>Implementierungsmodell: Erg\u00e4nzung um HW/SW-spezifische Anforderungen.<ul> <li>Umstellung auf Fixed-Point-Arithmetik.</li> <li>Datentyprestriktionen (8/16/32-Bit).</li> <li>Speicher- und Laufzeitoptimierungen.</li> </ul> </li> <li>Autocode: Das generierte C-Programm.</li> </ol>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#ausfuhrungsmodelle-rechenmodelle","title":"Ausf\u00fchrungsmodelle (Rechenmodelle)","text":"<p>Ein Rechenmodell definiert, wie Komponenten intern arbeiten und wie sie kommunizieren.</p>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#1-von-neumann-modell-control-flow","title":"1. Von-Neumann-Modell (Control Flow)","text":"<p>Das Standardmodell f\u00fcr C/C++ und Java.</p> <ul> <li>Prinzip: Sequenzielle Abfolge von Befehlen (Kontrollfluss).</li> <li>Kommunikation: \u00dcber Variablen (Shared Memory).</li> <li>Problem: Nebenl\u00e4ufigkeit muss k\u00fcnstlich \u00fcber Threads erzeugt werden \\(\\to\\) Gefahr von Race Conditions und Deadlocks.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#2-datenflussmodell-data-flow","title":"2. Datenflussmodell (Data Flow)","text":"<p>Typisch f\u00fcr Simulink oder SDF.</p> <ul> <li>Prinzip: Die Ausf\u00fchrung von Bl\u00f6cken wird ausschlie\u00dflich durch die Verf\u00fcgbarkeit von Daten getriggert. Es gibt keinen zentralen \"Instruction Pointer\".</li> <li>Vorteil: Inh\u00e4rent parallel; ideal f\u00fcr verteilte Systeme.</li> <li>Kommunikation: \u00dcber Signale.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#3-endliche-zustandsautomaten-fsm","title":"3. Endliche Zustandsautomaten (FSM)","text":"<p>Typisch f\u00fcr Stateflow.</p> <ul> <li>Einsatz: Ideal f\u00fcr reaktive Systeme.</li> <li>Prinzip: Das Verhalten wird durch diskrete Zust\u00e4nde, Ereignisse und Zustands\u00fcberg\u00e4nge (Transitionen) modelliert.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#4-weitere-modelle","title":"4. Weitere Modelle","text":"<ul> <li>Diskretes Ereignismodell (Discrete Event): (VHDL). Eine Warteschlange mit zeitlich sortierten Aktionen. Aktionen feuern, wenn der Simulationszeitpunkt erreicht ist.</li> <li>Petri-Netze: Fokus auf Synchronisation und Abh\u00e4ngigkeiten in verteilten Systemen. Mathematisch exakt analysierbar.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#anforderungen-an-modellierungssprachen","title":"Anforderungen an Modellierungssprachen","text":"<p>Da keine einzelne Sprache alle Aspekte perfekt abdeckt, ist die Wahl oft ein Kompromiss. Wichtige Kriterien sind:</p> <ul> <li>Hierarchie: Aufbau von Systemen aus Subsystemen (Bottom-Up).</li> <li>Nebenl\u00e4ufigkeit &amp; Synchronisation: Darstellung paralleler Abl\u00e4ufe und deren Abh\u00e4ngigkeiten.</li> <li>Zeitverhalten: Abbildung von Periodendauern, Deadlines und Latenzen.</li> <li>Reaktives Verhalten: Unterst\u00fctzung f\u00fcr (hierarchische) Zustandsautomaten.</li> <li>Ausnahmebehandlung: Modellierung von Fehlerf\u00e4llen (Fail-Operational).</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#quality-gates-im-v-modell","title":"Quality Gates (im V-Modell)","text":"<p>Das V-Modell sieht eine stufenweise Validierung vor: von der reinen Simulation bis zur echten Hardware.</p>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#1-mil-model-in-the-loop","title":"1. MIL (Model-in-the-Loop)","text":"<ul> <li>Testobjekt: Das ausf\u00fchrbare Modell (Simulink).</li> <li>Umgebung: Simuliert.</li> <li>Plattform: Host-PC.</li> <li>Ziel: Validierung der grundlegenden Logik/Funktion.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#2-sil-software-in-the-loop","title":"2. SIL (Software-in-the-Loop)","text":"<ul> <li>Testobjekt: Der generierte Code (kompiliert f\u00fcr PC).</li> <li>Umgebung: Simuliert.</li> <li>Plattform: Host-PC.</li> <li>Ziel: Konsistenzpr\u00fcfung zwischen Modell und Code (Code-Generator verifizieren). Noch keine Echtzeit.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#3-pil-processor-in-the-loop","title":"3. PIL (Processor-in-the-Loop)","text":"<ul> <li>Testobjekt: Der generierte Code (kompiliert f\u00fcr Ziel-Hardware).</li> <li>Umgebung: Simuliert (auf PC), Daten per Schnittstelle \u00fcbertragen.</li> <li>Plattform: Reale Ziel-CPU (z. B. Evaluation Board).</li> <li>Ziel: Pr\u00fcfung des Ziel-Compilers, Analyse von Ressourcenbedarf (Memory, Stack) und Laufzeitverhalten auf dem echten Chip.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#4-hil-hardware-in-the-loop","title":"4. HIL (Hardware-in-the-Loop)","text":"<ul> <li>Testobjekt: Das finale Steuerger\u00e4t (ECU) (HW + SW).</li> <li>Umgebung: Echtzeit-Simulation der Strecke (Fahrzeug, Sensorik) auf einem HIL-Simulator (z. B. dSpace).</li> <li>Plattform: Reale ECU.</li> <li>Ziel: Test unter Echtzeitbedingungen, Fehlerinjektion, Absicherung vor dem Feldeinsatz.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#5-test-im-realen-system","title":"5. Test im realen System","text":"<ul> <li>Abschlie\u00dfende Erprobung im realen Fahrzeug/Prototypen.</li> </ul>"},{"location":"Prozessrechentechnik/5.Modellierungstechniken/#rapid-prototyping-rp","title":"Rapid Prototyping (RP)","text":"<p>Ein \"Shortcut\" im Entwicklungsprozess, um Ideen schnell am realen Objekt zu testen.</p> <ul> <li>Vorgehen: Die klassischen Quality Gates (SIL/PIL/HIL) werden zun\u00e4chst \u00fcbersprungen.</li> <li>Hardware: Der Code l\u00e4uft nicht auf der (schwachen) Serien-ECU, sondern auf einer leistungsstarken RP-Hardware (z. B. dSpace Autobox), die im Fahrzeug verbaut wird (\"Bypass\").</li> <li>Ziele:<ul> <li>Schnelle Validierung (\"Proof of Concept\").</li> <li>Systemidentifikation (Parameter ermitteln).</li> <li>Erst nach erfolgreichem RP beginnt die Serienentwicklung mit allen Quality Gates.</li> </ul> </li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/","title":"6. SW-Entwicklung f\u00fcr ES","text":""},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#inhalte","title":"Inhalte","text":"<ul> <li>Besonderheiten eingebetteter Software</li> <li>Systemarchitekturen (Zeit- vs. Ereignisgesteuert)</li> <li>Verl\u00e4sslichkeit (Dependability) und Funktionale Sicherheit</li> <li>Reliability Engineering (Analytische und Konstruktive Ma\u00dfnahmen)</li> <li>Software-Schichten (Plattform vs. Applikationssoftware)</li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#besonderheiten-eingebetteter-software","title":"Besonderheiten eingebetteter Software","text":"<p>Eingebettete Systeme (ES) unterliegen anderen Zw\u00e4ngen als klassische PC-Software.</p> <ul> <li>Ressourcenbeschr\u00e4nkung: Da ES oft Massenprodukte sind, herrscht hoher Kostendruck. Man investiert lieber mehr Entwicklungszeit in Code-Optimierung, um an der Hardware (Speicher, CPU) Cent-Betr\u00e4ge zu sparen.</li> <li>Energieverbrauch: Kritisch, da Batteriekapazit\u00e4ten begrenzt sind und oft keine aktive K\u00fchlung (L\u00fcfter) m\u00f6glich ist.</li> <li>Robustheit: Die Software muss mit ungenauen Sensordaten, Rauschen und vereinfachten Modellen der Realit\u00e4t zuverl\u00e4ssig arbeiten.</li> <li>Echtzeit &amp; Normen: Oft m\u00fcssen harte Zeitlimits eingehalten werden, zertifiziert nach Normen wie IEC 61508 (Industrie) oder ISO 26262 (Automotive).</li> <li>Zielkonflikt: Hohe Flexibilit\u00e4t (Wartbarkeit, Abstraktion) steht meist im Widerspruch zu maximaler Performanz und minimalem Ressourcenverbrauch.</li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#systemarchitekturen","title":"Systemarchitekturen","text":"<p>Wie wird die Ausf\u00fchrung der Software gesteuert?</p>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#zeitgesteuerte-systeme-time-triggered","title":"Zeitgesteuerte Systeme (Time-Triggered)","text":"<ul> <li>Steuerung: Durch einen festen Zeittakt.</li> <li>Datenfluss: Sensoren werden aktiv abgefragt (Polling).</li> <li>Vorteil: Das zeitliche Verhalten ist vollst\u00e4ndig deterministisch und planbar. Dies ist f\u00fcr harte Echtzeitanforderungen oft zwingend notwendig.</li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#ereignisgesteuerte-systeme-event-triggered","title":"Ereignisgesteuerte Systeme (Event-Triggered)","text":"<ul> <li>Steuerung: Durch externe Ereignisse (Interrupts).</li> <li>Nachteil: Das zeitliche Verhalten ist schwer vorhersehbar. Ein Risiko sind \"Event Showers\" (Ereignisst\u00fcrme), bei denen zu viele Interrupts gleichzeitig auftreten und das System \u00fcberlasten.</li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#verlasslichkeit-dependability","title":"Verl\u00e4sslichkeit (Dependability)","text":"<p>Ein Oberbegriff f\u00fcr die Vertrauensw\u00fcrdigkeit eines Systems, unterteilt in drei Aspekte:</p>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#1-zuverlassigkeit-reliability","title":"1. Zuverl\u00e4ssigkeit (Reliability)","text":"<p>Die Wahrscheinlichkeit \\(R(t)\\), dass ein System \u00fcber einen Zeitraum \\(t\\) durchg\u00e4ngig fehlerfrei funktioniert.</p> <p>Die Badewannenkurve</p> <p>Beschreibt die Ausfallrate von Hardware \u00fcber die Lebenszeit: 1.  Fr\u00fchausfallphase: Hohe Rate durch Produktionsfehler (sinkend). 2.  Konsolidierungsphase: Niedrige, konstante Rate (Zufallsausf\u00e4lle). 3.  Sp\u00e4tausfallphase: Steigende Rate durch Verschlei\u00df/Alterung.</p>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#2-verfugbarkeit-availability","title":"2. Verf\u00fcgbarkeit (Availability)","text":"<p>Der Anteil der Zeit, in der das System funktionsbereit ist (unabh\u00e4ngig von Unterbrechungen).</p> \\[Verf\u00fcgbarkeit = \\frac{\\text{Gesamtzeit} - \\text{Ausfallzeit}}{\\text{Gesamtzeit}}\\]"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#3-funktionale-sicherheit-safety","title":"3. Funktionale Sicherheit (Safety)","text":"<p>Die Freiheit von nicht akzeptierbaren Risiken. * Risikodefinition:</p> \\[Risiko = \\text{Eintrittsh\u00e4ufigkeit} \\times \\text{Schadensausma\u00df}\\] <p></p> <ul> <li>Ziel: Das Risiko muss unter einem definierten Grenzrisiko bleiben.</li> <li>Zielkonflikt Safety vs. Availability: Eine sehr empfindliche Fehlererkennung, die das System beim kleinsten Zweifel abschaltet, erh\u00f6ht die Sicherheit (kein Schaden), aber ruiniert die Verf\u00fcgbarkeit (System steht still).</li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#reliability-engineering","title":"Reliability Engineering","text":"<p>Methoden zur Berechnung und Steigerung der Verl\u00e4sslichkeit.</p>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#analytische-verfahren","title":"Analytische Verfahren","text":"<p>Berechnung der Gesamtsystem-Zuverl\u00e4ssigkeit (\\(R\\)) aus Komponenten.</p> <p>[Image of series vs parallel reliability block diagram]</p> <ul> <li>Serielle Kopplung (Kette):<ul> <li>System f\u00e4llt aus, wenn eine Komponente versagt.</li> <li>\\(R_{Gesamt} = R_1 \\cdot R_2 \\cdot \\ldots \\cdot R_n\\)</li> <li>Ergebnis: Die Zuverl\u00e4ssigkeit ist schlechter als die der schlechtesten Komponente.</li> </ul> </li> <li>Parallele Kopplung (Redundanz):<ul> <li>System f\u00e4llt nur aus, wenn alle Komponenten versagen.</li> <li>\\(R_{Gesamt} = 1 - [(1 - R_1) \\cdot (1 - R_2) \\cdot \\ldots \\cdot (1 - R_n)]\\)</li> <li>Ergebnis: Die Zuverl\u00e4ssigkeit ist besser als die der besten Komponente.</li> </ul> </li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#konstruktive-manahmen-redundanz","title":"Konstruktive Ma\u00dfnahmen (Redundanz)","text":"<p>Einsatz zus\u00e4tzlicher Ressourcen zur Fehlertoleranz.</p>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#hardware-redundanz","title":"Hardware-Redundanz","text":"<ul> <li>Statisch (Voting): Identische Module arbeiten parallel. Ein Voter entscheidet per Mehrheit (z. B. 2-aus-3 Auswahl / Triple Modular Redundancy). Maskiert Fehler sofort.</li> </ul> <ul> <li>Dynamisch (Switching): Eine Fehlererkennung schaltet im Notfall auf ein Reserve-Modul (\"Standby\") um.</li> <li>Hybrid: Kombination aus Voting und Rekonfiguration (defekte Module werden vom Voter ignoriert und durch Reserve ersetzt).</li> </ul>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#software-redundanz","title":"Software-Redundanz","text":"<p>Da Software nicht \"verschlei\u00dft\", helfen einfache Kopien nicht gegen Designfehler (Bugs). Man ben\u00f6tigt Diversit\u00e4t. * N-Versions Programming (Statisch): Mehrere Teams entwickeln die Software unabh\u00e4ngig voneinander. Alle Versionen laufen parallel, ein Voter entscheidet. (Extrem teuer). * Recovery Blocks (Dynamisch): Ein Akzeptanztest pr\u00fcft das Ergebnis. Schl\u00e4gt dieser fehl, wird eine (einfachere) Reserve-Variante ausgef\u00fchrt.</p>"},{"location":"Prozessrechentechnik/6.SW-Entwicklung_f%C3%BCr_ES/#software-schichten-plattform-vs-applikation","title":"Software-Schichten: Plattform vs. Applikation","text":"<p>Moderne ECU-Architekturen (z. B. AUTOSAR) trennen strikt in zwei Schichten.</p> Merkmal Plattformsoftware Applikationssoftware Position Unten (Hardwarenah) Oben (Hardwareunabh\u00e4ngig) Aufgabe Abstraktion der Hardware. Stellt Treiber (ADC, CAN) und Basisdienste (Scheduling) bereit. Enth\u00e4lt die eigentliche Produktlogik (Regler, Steuerungsabl\u00e4ufe). Semantik Keine Semantik. Liefert nur Rohwerte (z.B. \"Spannungswert 102\"). Tr\u00e4gt die Semantik. Interpretiert Werte (z.B. \"102 = 5 m/s\u00b2 Beschleunigung\"). Abh\u00e4ngigkeit Plattformspezifisch (angepasst an den Chip). Anwendungsspezifisch (enth\u00e4lt das Dom\u00e4nenwissen). Beispiel Betriebssystem, Bustreiber, HAL. Tempomat-Regler, Motorsteuerung."},{"location":"Prozessrechentechnik/SolutionsExamTraining/","title":"Quiz","text":""},{"location":"Prozessrechentechnik/SolutionsExamTraining/#einleitung","title":"Einleitung","text":"<p>1. Was ist ein Eingebettetes System (ES) und was sind seine charakteristischen Eigenschaften?</p> <ul> <li>Ein Eingebettetes System (ES) ist ein Rechensystem, das in einen technischen Kontext (z.B. ein Auto, eine Waschmaschine) \"eingebettet\" ist, um dort Mess-, Steuer- oder Regelungsaufgaben zu erf\u00fcllen.</li> <li>Charakteristische Eigenschaften:<ul> <li>Enge Kopplung mit der physikalischen Umwelt (\u00fcber Sensoren und Aktuatoren).</li> <li>Reaktive Systeme: Sie reagieren kontinuierlich auf (oft asynchrone) Ereignisse aus der Umgebung, statt Daten zu transformieren.</li> <li>Echtzeitanforderungen: Die korrekte Funktion h\u00e4ngt oft von der Einhaltung zeitlicher Fristen (Deadlines) ab.</li> <li>Ressourcenbeschr\u00e4nkungen: Sie sind oft hinsichtlich Kosten, Energieverbrauch, Speicher und Rechenleistung stark optimiert (effizient).</li> <li>Verl\u00e4sslichkeit: Sie m\u00fcssen hohe Anforderungen an Zuverl\u00e4ssigkeit und Funktionale Sicherheit erf\u00fcllen (z.B. ISO 26262).</li> </ul> </li> </ul> <p>2. Nennen Sie einige wichtige Unterschiede zwischen ES- und IT-Systemen.</p> <ul> <li>IT-Systeme (z.B. Buchhaltungsserver) sind prim\u00e4r transformationelle Systeme: Sie verarbeiten einen Stapel Daten (Input) zu einem Ergebnis (Output).</li> <li>Eingebettete Systeme (ES) sind prim\u00e4r reaktive Systeme, die kontinuierlich mit ihrer Umwelt interagieren und auf Stimuli reagieren.</li> <li>ES haben eine enge HW/SW-Verzahnung und unterliegen harten Echtzeitanforderungen sowie strengen Ressourcen- und Energiebeschr\u00e4nkungen, was bei IT-Systemen seltener der Fall ist.</li> </ul> <p>3. Wann funktioniert ein Echtzeitsystem korrekt?</p> <ul> <li>Ein Echtzeitsystem funktioniert korrekt, wenn seine Berechnungen nicht nur logisch korrekt sind, sondern auch innerhalb der vorgegebenen Zeitfristen (Deadlines) erfolgen. Ein richtiges Ergebnis zur falschen Zeit ist ein Fehler.</li> </ul> <p>4. Was ist der Unterschied zwischen weichen und harten Echtzeit-Bedingungen?</p> <ul> <li>Harte Echtzeit (Hard Real-Time): Das Verpassen einer Deadline kann katastrophale Folgen haben (z.B. Airbag-Ausl\u00f6sung). Der Nutzen des Ergebnisses f\u00e4llt nach der Deadline sofort auf null oder wird negativ.</li> <li>Weiche Echtzeit (Soft Real-Time): Das Verpassen einer Deadline ist tolerierbar und f\u00fchrt z.B. nur zu Komfortverlust oder Qualit\u00e4tsminderung (z.B. Ruckeln beim Video-Streaming). Der Nutzen des Ergebnisses sinkt nach der Deadline allm\u00e4hlich.</li> </ul> <p>5. Nennen Sie einige wichtige nicht-funktionale Anforderungen an ES.</p> <ul> <li>Effizienz (Preis, Gewicht, Energieverbrauch)</li> <li>Verl\u00e4sslichkeit (Reliability)</li> <li>Funktionale Sicherheit (Safety)</li> <li>Echtzeitf\u00e4higkeit (Rechtzeitigkeit)</li> <li>Robustheit</li> </ul>"},{"location":"Prozessrechentechnik/SolutionsExamTraining/#begriffe-und-grundlagen","title":"Begriffe und Grundlagen","text":"<p>6. Was ist ein Signal?</p> <ul> <li>Ein Signal ist der Tr\u00e4ger von Information, dargestellt als eine physikalische Gr\u00f6\u00dfe, die sich zeitlich \u00e4ndert (z.B. Spannung).</li> </ul> <p>7. Nach welchen Kriterien lassen sich Signale klassifizieren?</p> <ul> <li>Nach dem Zeitbereich (zeitkontinuierlich oder zeitdiskret).</li> <li>Nach dem Wertebereich (wertkontinuierlich oder wertdiskret).</li> </ul> <p>8. Was ist der Unterschied zwischen zeitdiskreten und wertdiskreten Signalen?</p> <ul> <li>Zeitdiskret: Das Signal ist nur zu bestimmten, diskreten Zeitpunkten definiert (z.B. ein abgetastetes Signal).</li> <li>Wertdiskret: Das Signal kann nur eine endliche (abz\u00e4hlbare) Anzahl von Werten annehmen (z.B. ein quantisiertes Signal).</li> </ul> <p>9. Was ist ein digitales Signal?</p> <ul> <li>Ein digitales Signal ist sowohl zeitdiskret als auch wertdiskret.</li> </ul> <p>10. Welche Art von Signalen kann ein reales \u00dcbertragungsmedium \u00fcbertragen?</p> <ul> <li>Reale physikalische \u00dcbertragungsmedien \u00fcbertragen immer analoge Signale (zeit- und wertkontinuierliche Signale).</li> </ul>"},{"location":"Prozessrechentechnik/SolutionsExamTraining/#aufbau-es","title":"Aufbau ES","text":"<p>11. Was ist der MSR-Kreislauf? Skizzieren Sie ihn gedanklich.</p> <ul> <li>Der MSR-Kreislauf (Messen, Steuern, Regeln) beschreibt den geschlossenen Regelkreis in eingebetteten Systemen.</li> <li>Sensorik erfasst den Prozesszustand (Messen), die Verarbeitungseinheit (\\(\\mu P\\)) trifft Entscheidungen (Verarbeiten) und die Aktorik beeinflusst den Prozess (Stellen/Regeln).</li> </ul> <p>12. Was versteht man unter dem Begriff \u201eSensor\u201c (bei ES)? Zu was dienen sie und was ist i. A. bei Sensorsignalen zu beachten?</p> <ul> <li>Sensoren sind Bauteile, die nichtelektrische (z.B. mechanische, thermische) Gr\u00f6\u00dfen aus dem Prozesszustand erfassen und in elektrische Signale umwandeln.</li> <li>Bei Sensorsignalen ist zu beachten, dass sie oft verrauscht, fehlerbehaftet oder von St\u00f6rungen \u00fcberlagert sind.</li> </ul> <p>13. Nach welchen Eigenschaften lassen sich Sensoren klassifizieren?</p> <ul> <li>Extrinsisch (erfassen die Umgebung, z.B. Kamera) vs. Intrinsisch (erfassen den internen Systemzustand, z.B. Gyroskop).</li> <li>Nach Integrationsstufen: Elementarsensor (reiner Wandler), Integrierter Sensor (mit Signalaufbereitung), Intelligenter Sensor (mit Vorverarbeitung).</li> </ul> <p>14. Beschreiben Sie das Messprinzip eines mechanischen, kapazitiven Beschleunigungssensors.</p> <ul> <li>Eine tr\u00e4ge Masse ist federnd aufgeh\u00e4ngt (\\(F = m \\cdot a = k \\cdot \\Delta d\\)). Bei Beschleunigung wird diese Masse ausgelenkt (\\(\\Delta d\\)).</li> <li>Die Masse ist als mittlere Elektrode eines Differentialkondensators (\\(C_1\\), \\(C_2\\)) realisiert. Die Auslenkung \u00e4ndert die Abst\u00e4nde und damit die Kapazit\u00e4ten \\(C_1\\) und \\(C_2\\) gegenl\u00e4ufig. Diese Kapazit\u00e4ts\u00e4nderung wird gemessen.</li> </ul> <p>15. Beschreiben Sie die Funktionsweise eines inkrementellen Positions-/Winkelsensors mit Lichtschranken.</p> <ul> <li>Ein Optischer Encoder (Inkrementalgeber) verwendet eine rotierende Scheibe mit einem feinen Strichmuster (hell/dunkel).</li> <li>Zwei leicht versetzte Lichtschranken (Detektor A, B) tasten das Muster ab. Aus der Anzahl der Impulse wird die Position/Winkel\u00e4nderung berechnet, aus der Phasenverschiebung von A zu B die Bewegungsrichtung.</li> </ul> <p>16. Was ist die Aufgabe eines Aktuators?</p> <ul> <li>Aktuatoren (oder Aktoren) beeinflussen den technischen Prozess, indem sie elektrische Energie (das Steuersignal) in eine andere Energieform, meist mechanische Arbeit, umwandeln (z.B. Motorbewegung, Kraft).</li> </ul> <p>17. Gleichstrommotoren werden meist mit einer H-Br\u00fccke und einem PWM-Signal angesteuert. Beschreiben Sie den Vorgang. Was kann alles damit gesteuert werden?</p> <ul> <li>Eine H-Br\u00fccke ist eine Schaltung aus vier Schaltern (Transistoren). Durch paarweises Schlie\u00dfen der diagonalen Schalter kann die Polung am Motor umgekehrt werden.</li> <li>Ein PWM-Signal (Pulsweiten-Modulation) wird an die H-Br\u00fccke angelegt. Das Tastverh\u00e4ltnis (Duty Cycle) der PWM bestimmt die mittlere Spannung am Motor.</li> <li>Gesteuert werden:<ol> <li>Drehrichtung (durch Umpolen der H-Br\u00fccke).</li> <li>Drehzahl / Drehmoment (durch das Tastverh\u00e4ltnis der PWM).</li> </ol> </li> </ul> <p>18. Was sind die Vorteile und Nachteile von Schrittmotoren?</p> <ul> <li>Vorteile: Sie k\u00f6nnen in diskreten Winkelschritten angesteuert werden und erm\u00f6glichen eine Positionierung im \"Open-Loop\"-Betrieb (Steuerung) ohne Sensorik (R\u00fcckf\u00fchrung).</li> <li>Nachteile: Sie haben ein geringeres Drehmoment, sind ineffizienter und k\u00f6nnen bei \u00dcberlast \"Schritte verlieren\" (die Position ist dann unbekannt).</li> </ul> <p>19. Welche 3 Schritte sind bei der Abtastung eines analogen Eingangssignals notwendig? 1.  Filterung: Entfernung von Frequenzen oberhalb der halben Abtastrate mittels Anti-Aliasing-Filter (analoger Tiefpass). 2.  Halten: Festhalten des analogen Spannungswertes w\u00e4hrend der Wandlung mittels Sample &amp; Hold (S&amp;H)-Schaltung. 3.  Wandlung: Diskretisierung von Zeit und Wert mittels A/D-Wandler (ADC).</p> <p>20. Welche 3 Schritte sind bei der R\u00fcckf\u00fchrung eines digitalen Ausgangssignals zu einem analogen Ausgangssignal notwendig? 1.  Wandlung: Umwandlung des digitalen Werts in eine analoge (oft gestufte) Spannung mittels D/A-Wandler (DAC) (oder Erzeugung eines PWM-Signals). 2.  Entst\u00f6rung (Deglitching): (Nur bei DACs n\u00f6tig) Entfernen von Umschalt-Spitzen (Glitches) mittels Deglitcher (S&amp;H-Schaltung). 3.  Gl\u00e4ttung: Entfernen der \"Treppenstufen\" (bei DAC) bzw. Gl\u00e4ttung der Pulse (bei PWM) mittels Tiefpassfilter (Rekonstruktionsfilter).</p> <p>21. Was besagt das Nyquist-Shannon-Abtasttheorem?</p> <ul> <li>Die Abtastfrequenz (\\(f_a\\)) muss mindestens doppelt so hoch sein wie die h\u00f6chste im Signal enthaltene Frequenz (\\(f_g\\)), um das Signal exakt rekonstruieren zu k\u00f6nnen.</li> </ul> \\[f_a &gt; 2 \\cdot f_g\\] <p>22. Was sind Alias-Effekte, wann entstehen sie und was muss man zu deren Vermeidung beachten?</p> <ul> <li>Alias-Effekte entstehen, wenn das Nyquist-Shannon-Theorem verletzt wird (die Abtastrate zu gering ist).</li> <li>Hohe Frequenzen im Signal \"tarnen\" sich als niedrigere Frequenzen und verf\u00e4lschen die Messung.</li> <li>Vermeidung: Man muss zwingend ein Anti-Aliasing-Filter (einen analogen Tiefpassfilter) vor der Abtastung verwenden, um alle Frequenzen oberhalb \\(f_a/2\\) abzuschneiden.</li> </ul> <p>23. Was ist die Aufgabe einer Sample&amp;Hold-Schaltung vor einem A/D-Wandler?</p> <ul> <li>Ein ADC ben\u00f6tigt eine endliche Wandlungszeit. Die S&amp;H-Schaltung \"friert\" den analogen Spannungswert am Abtastzeitpunkt ein und h\u00e4lt ihn w\u00e4hrend der Dauer der A/D-Wandlung konstant.</li> </ul> <p>24. Was sind Hazards (Glitches) und wie werden sie bei der D/A-Wandlung vermieden?</p> <ul> <li>Hazards (Glitches) sind unerw\u00fcnschte, kurze Spannungsspitzen (Spikes) am Ausgang eines D/A-Wandlers. Sie entstehen, wenn die Bits des digitalen Worts nicht exakt gleichzeitig umschalten (z.B. beim \u00dcbergang <code>0111</code> \\(\\to\\) <code>1000</code> k\u00f6nnte kurz <code>0000</code> anliegen).</li> <li>Sie werden durch einen nachgeschalteten Deglitcher (eine S&amp;H-Schaltung) vermieden, der den letzten stabilen Wert h\u00e4lt, bis der DAC den neuen Wert stabil ausgegeben hat.</li> </ul> <p>25. Welche Typen von A/D-Wandlern unterscheidet man und was sind die wichtigsten Eigenschaften?</p> <ul> <li>W\u00e4geverfahren (Successive Approximation, SAR): Schrittweiser Vergleich (Bit f\u00fcr Bit). Guter Kompromiss zwischen Geschwindigkeit und Kosten, sehr verbreitet.</li> <li>Parallele Wandler (Flash): Extrem schnell (eine Taktperiode). Ben\u00f6tigen aber \\(2^n-1\\) Komparatoren, daher teuer und meist auf niedrige Aufl\u00f6sungen (z.B. 8 Bit) beschr\u00e4nkt.</li> <li>Integrierende Wandler (z.B. Dual-Slope): Langsam, aber sehr genau und robust gegen St\u00f6rfrequenzen (z.B. 50/60Hz-Brummen).</li> </ul> <p>26. Was versteht man unter Pulsweiten-Modulation (PWM-Modulation)? Wof\u00fcr wird sie verwendet?</p> <ul> <li>PWM ist ein digitales (Rechteck-)Signal mit konstanter Frequenz, aber variablem Tastverh\u00e4ltnis (Verh\u00e4ltnis von \"EIN\"-Zeit zu \"AUS\"-Zeit).</li> <li>Verwendung:<ol> <li>Effiziente Ansteuerung von Aktuatoren (z.B. Motor-Drehzahlsteuerung, LED-Dimmung).</li> <li>Als energiesparende Alternative zu einem D/A-Wandler (wenn ein Tiefpassfilter nachgeschaltet wird).</li> </ol> </li> </ul> <p>27. Welche 3 Technologien gibt es bei den Verarbeitungseinheiten von ES und was sind deren Vor- und Nachteile?</p> <ol> <li>Prozessoren (\\(\\mu P\\), \\(\\mu C\\), DSPs):<ul> <li>Vorteil: H\u00f6chste Flexibilit\u00e4t (Software).</li> <li>Nachteil: Geringste Energieeffizienz (Operationen/Watt).</li> </ul> </li> <li>ASICs (Application-Specific Integrated Circuits):<ul> <li>Vorteil: H\u00f6chste Energieeffizienz (fest verdrahtet).</li> <li>Nachteil: Unflexibel, extrem hohe Entwicklungskosten.</li> </ul> </li> <li>Rekonfigurierbare Logik (FPGAs):<ul> <li>Vorteil: Ein Kompromiss zwischen Effizienz und Flexibilit\u00e4t.</li> <li>Nachteil: Komplex in der Programmierung (z.B. VHDL).</li> </ul> </li> </ol> <p>28. Was sind ASICs und wann kommen sie zum Einsatz?</p> <ul> <li>ASICs (Application-Specific Integrated Circuits) sind anwendungsspezifische, fest verdrahtete Schaltungen.</li> <li>Sie kommen bei sehr hohen St\u00fcckzahlen zum Einsatz, bei denen maximale Energieeffizienz und minimale Kosten pro St\u00fcck wichtiger sind als Flexibilit\u00e4t (z.B. in Mobiltelefonen).</li> </ul> <p>29. Was versteht man unter dem Effizienz-/Flexibilit\u00e4tskonflikt?</p> <ul> <li>Es ist der Zielkonflikt, dass Bauteile mit hoher Flexibilit\u00e4t (wie Prozessoren) meist eine niedrige Energieeffizienz haben, w\u00e4hrend Bauteile mit hoher Energieeffizienz (wie ASICs) meist unflexibel sind. FPGAs liegen dazwischen.</li> </ul> <p>30. Warum ist ein minimaler Energieverbrauch bei mobilen Ger\u00e4ten so wichtig?</p> <ul> <li>Ein minimaler Energieverbrauch ist der Schl\u00fcsselfaktor f\u00fcr die Akkulaufzeit mobiler Ger\u00e4te.</li> </ul> <p>31. Auf was alles wirkt sich die Leistungsaufnahme eines Ger\u00e4tes aus?</p> <ul> <li>Akkulaufzeit (bei mobilen Ger\u00e4ten).</li> <li>W\u00e4rmeentwicklung (erfordert ggf. K\u00fchlung, was Gr\u00f6\u00dfe, Gewicht und Kosten erh\u00f6ht).</li> <li>Betriebskosten (Stromverbrauch).</li> </ul> <p>32. Wie k\u00f6nnen Prozessoren f\u00fcr ES hinsichtlich Effizienz optimiert werden?</p> <ul> <li>Durch spezialisierte Hardware (z.B. Co-Prozessoren).</li> <li>Durch intelligentes Energiemanagement, z.B. verschiedene Energiesparzust\u00e4nde (Run, Idle, Sleep) und das Abschalten ungenutzter Peripherie (Clock Gating).</li> </ul> <p>33. Was sind rekonfigurierbare Logiken und wann kommen sie zum Einsatz?</p> <ul> <li>Dies sind Bauteile wie FPGAs (Field-Programmable Gate Arrays).</li> <li>Ihre interne Logikstruktur ist nicht fest verdrahtet, sondern kann (neu) konfiguriert werden. Sie kommen als Kompromiss zum Einsatz, wenn ASICs zu teuer (geringe St\u00fcckzahl) und Prozessoren zu langsam oder ineffizient sind.</li> </ul> <p>34. Was sind FPGAs und wie sind diese aufgebaut?</p> <ul> <li>FPGAs (Field-Programmable Gate Arrays) sind rekonfigurierbare Logiken.</li> <li>Sie bestehen aus einem gro\u00dfen Array von konfigurierbaren Logikbl\u00f6cken (CLBs) \u2013 diese enthalten z.B. Look-Up Tables (LUTs) und Flip-Flops \u2013 die durch ein programmierbares Verbindungsnetzwerk (Routing) miteinander verschaltet werden.</li> </ul>"},{"location":"Prozessrechentechnik/SolutionsExamTraining/#steuerung-und-regelung","title":"Steuerung und Regelung","text":"<p>35. Zu was werden Filter in ES eingesetzt?</p> <ul> <li>Signalverbesserung: z.B. Rauschen entfernen (Tiefpass).</li> <li>Signalvorbereitung: z.B. Anti-Aliasing (Tiefpass) oder Gleichanteile entfernen (Hochpass).</li> <li>Signaltrennung: z.B. eine bestimmte St\u00f6rfrequenz (Netzbrummen) entfernen (Bandsperre).</li> <li>Signalrekonstruktion: Gl\u00e4ttung von DAC- oder PWM-Signalen (Tiefpass).</li> </ul> <p>36. Was sind die Eigenschaften eines idealen Filters? Wie kann man sich diesen bei digitalen Filtern n\u00e4hern?</p> <ul> <li>Ein ideales Filter h\u00e4tte eine Verst\u00e4rkung von 1 im Durchlassbereich, 0 im Sperrbereich und einen unendlich steilen Abfall (\u00dcbergangsbereich = 0).</li> <li>Ann\u00e4herung bei digitalen Filtern: Durch Erh\u00f6hung der Filterordnung (mehr Koeffizienten/Verz\u00f6gerungsglieder), was die Flanke steiler macht.</li> </ul> <p>37. Was ist bei einem Filter die Grenzfrequenz?</p> <ul> <li>Die Frequenz (\\(f_g\\)), bei der die Signal-Amplitude am Ausgang um -3 dB (also auf ca. 70,7% des Eingangswerts bzw. die halbe Leistung) abgefallen ist.</li> </ul> <p>38. Nennen Sie Anwendungsf\u00e4lle f\u00fcr Hochpass-, Tiefpass-, Bandpass- und Bandsperren-Filter.</p> <ul> <li>Tiefpass: Rauschen filtern, Anti-Aliasing, Gl\u00e4ttung von PWM/DAC-Signalen.</li> <li>Hochpass: Gleichanteile oder langsame Drifts entfernen (z.B. bei Audio- oder Biosignalen).</li> <li>Bandpass: Ein bestimmtes Frequenzband isolieren (z.B. ein Funksignal).</li> <li>Bandsperre (Notch-Filter): Eine einzelne St\u00f6rfrequenz gezielt entfernen (z.B. 50/60 Hz Netzbrummen).</li> </ul> <p>39. Aus welchen Bauteilen bestehen analoge, passive Filter?</p> <ul> <li>Sie bestehen nur aus passiven Bauteilen: Widerst\u00e4nde (R), Kondensatoren (C) und Spulen (L).</li> </ul> <p>40. Was sind die Nachteile analoger Filter?</p> <ul> <li>Sie sind anf\u00e4llig f\u00fcr Bauteiltoleranzen, Alterung und Temperaturdrift.</li> <li>Komplexe Filter (hoher Ordnung) sind schwer zu realisieren; Spulen (L) sind oft gro\u00df und teuer.</li> </ul> <p>41. Was sind die Vorteile digitaler Filter?</p> <ul> <li>Perfekt reproduzierbar (da sie auf Berechnungen basieren), keine Alterung oder Drift.</li> <li>Flexibel: Parameter k\u00f6nnen per Software ge\u00e4ndert werden (adaptive Filter).</li> <li>Komplexe Filter (z.B. FIR-Filter mit linearer Phase) sind realisierbar, die analog unm\u00f6glich w\u00e4ren.</li> </ul> <p>42. Durch was wird die max. Frequenz digitaler Filter begrenzt?</p> <ul> <li>Durch das Nyquist-Theorem: Ein digitaler Filter kann nur Frequenzen bis maximal zur halben Abtastfrequenz (\\(f_a / 2\\)) sinnvoll verarbeiten.</li> </ul> <p>43. Ein digitales System (Filter) kann durch eine Differenzengleichung beschrieben werden. Was ist das?</p> <ul> <li>Eine Differenzengleichung beschreibt, wie der n\u00e4chste Ausgangswert (\\(y_k\\)) aus aktuellen (\\(x_k\\)) und vergangenen (\\(x_{k-1}, y_{k-1}\\)) Ein- und Ausgangswerten berechnet wird.</li> <li>Beispiel (IIR): \\(y_k = 0.1 \\cdot x_k + 0.9 \\cdot y_{k-1}\\)</li> </ul> <p>44. Was sind die Unterschiede zw. einem FIR-Filter und einem IIR-Filter?</p> <ul> <li>FIR (Finite Impulse Response):<ul> <li>Nicht-rekursiv (keine R\u00fcckkopplung des Ausgangs). Formel: \\(y_n = \\sum b_k \\cdot x_{n-k}\\)</li> <li>Die Impulsantwort hat eine endliche L\u00e4nge.</li> <li>Sind immer stabil und k\u00f6nnen linearphasig (konstante Gruppenlaufzeit) sein.</li> </ul> </li> <li>IIR (Infinite Impulse Response):<ul> <li>Rekursiv (verwendet vergangene Ausgangswerte). Formel: \\(y_n = \\sum b_k \\cdot x_{n-k} + \\sum a_j \\cdot y_{n-j}\\)</li> <li>Die Impulsantwort ist unendlich lang.</li> <li>Ben\u00f6tigen viel weniger Rechenaufwand (Ordnung) f\u00fcr dieselbe Steilheit, k\u00f6nnen aber instabil werden.</li> </ul> </li> </ul> <p>45. Was ist die Ordnung eines digitalen Filters? Was beeinflusst die Ordnung?</p> <ul> <li>Die Ordnung ist die Anzahl der ben\u00f6tigten Verz\u00f6gerungsglieder (Speicherpl\u00e4tze f\u00fcr \\(x_{k-n}\\) oder \\(y_{k-n}\\)).</li> <li>Die Ordnung beeinflusst die Steilheit der Filterflanke (\u00dcbergangsbereich): Eine h\u00f6here Ordnung ergibt einen steileren, \"besseren\" Filter, erfordert aber mehr Rechenleistung.</li> </ul> <p>46. Was ist der Unterschied zwischen einer Steuerung und einer Regelung?</p> <ul> <li>Steuerung (Open-Loop): Eine offene Wirkkette. Die Stellgr\u00f6\u00dfe wird ohne Kenntnis der tats\u00e4chlichen Ausgangsgr\u00f6\u00dfe (Ist-Wert) gesetzt. St\u00f6rungen werden nicht erkannt und nicht korrigiert.</li> <li>Regelung (Closed-Loop): Eine geschlossene Wirkkette (Regelkreis). Die Ausgangsgr\u00f6\u00dfe (Ist-Wert) wird gemessen und vom Soll-Wert abgezogen (Regelabweichung). Der Regler korrigiert basierend auf dieser Abweichung.</li> </ul> <p>47. Skizzieren Sie einen allgemeinen Regelkreis.</p> <ul> <li>Ein Regelkreis besteht aus:<ul> <li>Summierstelle: Bildet die Regelabweichung \\(e = w - x\\) (Soll-Wert \\(w\\), Ist-Wert \\(x\\)).</li> <li>Regler: Erzeugt die Stellgr\u00f6\u00dfe \\(y\\) aus \\(e\\).</li> <li>Regelstrecke: Der Prozess, der von \\(y\\) (und St\u00f6rgr\u00f6\u00dfe \\(z\\)) beeinflusst wird und den Ist-Wert \\(x\\) liefert.</li> <li>R\u00fcckf\u00fchrung: F\u00fchrt \\(x\\) (oft \u00fcber einen Sensor) zur Summierstelle zur\u00fcck.</li> </ul> </li> </ul> <p>48. Welche Kenngr\u00f6\u00dfen gibt es f\u00fcr die dynamische Regelg\u00fcte?</p> <ul> <li>Dynamische Regelg\u00fcte beschreibt das Zeitverhalten beim \u00dcbergang in einen neuen Zustand.</li> <li>Kenngr\u00f6\u00dfen sind z.B. die Anregelzeit (wie schnell der Wert erstmals erreicht wird), die Ausregelzeit (bis der Wert dauerhaft im Toleranzband bleibt) und die \u00dcberschwingweite (wie stark das System \u00fcber das Ziel hinausschie\u00dft).</li> </ul> <p>49. Was beschreibt die station\u00e4re Regelg\u00fcte?</p> <ul> <li>Die station\u00e4re Regelg\u00fcte beschreibt die Genauigkeit im eingeschwungenen Zustand, d.h. die bleibende Regelabweichung (den Fehler, der \"\u00fcbrig bleibt\").</li> </ul> <p>50. Durch welches \u00dcbertragungsglied im Regler kann man die station\u00e4re Regelabweichung zu Null bekommen?</p> <ul> <li>Durch einen I-Anteil (Integral-Anteil). Nur Regler mit I-Anteil (I-, PI-, PID-Regler) k\u00f6nnen die bleibende Regelabweichung vollst\u00e4ndig eliminieren.</li> </ul> <p>51. Ein Regelkreis kann stabil oder instabil sein. Was hei\u00dft das?</p> <ul> <li>Stabil: Nach einer St\u00f6rung oder einer Sollwert\u00e4nderung kehrt die Regelgr\u00f6\u00dfe (Ist-Wert) in einen stabilen Endzustand zur\u00fcck.</li> <li>Instabil: Die Regelgr\u00f6\u00dfe schwingt sich unkontrolliert auf (Amplitude w\u00e4chst) oder w\u00e4chst unbegrenzt an. Dies kann zur Zerst\u00f6rung der Strecke f\u00fchren.</li> </ul> <p>52. Ein Regelkreisverhalten sollte robust ausgelegt werden. Was hei\u00dft das?</p> <ul> <li>Robustheit bedeutet, dass die Regelung (z.B. Stabilit\u00e4t und Regelg\u00fcte) auch dann erhalten bleibt, wenn sich die Parameter der Regelstrecke leicht \u00e4ndern (z.B. durch Alterung, Temperatur oder unterschiedliche Beladung).</li> </ul>"},{"location":"Prozessrechentechnik/SolutionsExamTraining/#modellierungstechniken","title":"Modellierungstechniken","text":"<p>53. Beschreiben Sie mit eigenen Worten das Grundprinzip des modellbasierten Entwicklungsansatzes.</p> <ul> <li>Beim Modellbasierten Design (MBD) ist das Modell (z.B. ein Simulink-Blockschaltbild) das zentrale Entwicklungsartefakt.</li> <li>Statt manuell Code (z.B. in C) zu schreiben, wird die Logik grafisch modelliert. Aus diesem Modell wird der finale Quellcode automatisch generiert (mittels Auto-Coder).</li> <li>Dieser Ansatz erm\u00f6glicht fr\u00fche Tests und Simulationen (MIL, SIL) und eine klare Trennung von Funktion und Implementierung.</li> </ul> <p>54. Warum sind bei ES Funktionsmodelle mit nachgelagerter Code-Generierung oft geeigneter als fertige Softwarebibliotheken?</p> <ul> <li>Eine fertige Softwarebibliothek ist oft generisch und muss alle Eventualit\u00e4ten abdecken, was zu unn\u00f6tigem Overhead f\u00fchrt (Effizienz-Flexibilit\u00e4ts-Konflikt).</li> <li>Ein Auto-Coder generiert aus einem Modell (z.B. einem Fuzzy-Regler-Modell) hochoptimierten, spezifischen Code, der nur die ben\u00f6tigte Variante implementiert und daher effizienter (schneller, speichersparender) ist.</li> </ul> <p>55. Nennen Sie Anforderungen, die man an Modellierungssprachen stellen kann. 1.  Abbildung von Hierarchie (Strukturierung). 2.  Abbildung von Nebenl\u00e4ufigkeit (Parallelit\u00e4t). 3.  Abbildung von Zeitverhalten (Deadlines, Perioden). 4.  Abbildung von reaktivem Verhalten (z.B. Zustandsautomaten). 5.  Abbildung von Datenfluss. 6.  Ausf\u00fchrbarkeit/Simulierbarkeit. 7.  M\u00f6glichkeit zur Code-Generierung. 8.  Formale Verifizierbarkeit. 9.  Wiederverwendbarkeit. 10. Eindeutige Syntax und Semantik.</p> <p>56. Was sind die Nachteile des Ausf\u00fchrungsmodells \u201eVon-Neumann\u201c?</p> <ul> <li>Das Von-Neumann-Modell ist rein sequenziell (Control Flow).</li> <li>Nebenl\u00e4ufigkeit (z.B. durch Threads) muss manuell verwaltet werden und ist extrem fehleranf\u00e4llig (z.B. Race Conditions, Deadlocks). Edward Lee nannte es \"unverst\u00e4ndlich f\u00fcr Menschen\".</li> </ul> <p>57. Nennen Sie 3 alternative Ausf\u00fchrungsmodelle und ihren Fokus. 1.  Datenflussmodell (Data Flow): Fokus auf dem Datenfluss; die Ausf\u00fchrung wird durch die Verf\u00fcgbarkeit von Daten getriggert. 2.  Endliche Zustandsautomaten (FSM): Fokus auf reaktivem Verhalten und Zustands\u00fcberg\u00e4ngen. 3.  Diskretes Ereignismodell: Fokus auf einer zeitlich sortierten Warteschlange von Ereignissen.</p> <p>58. Beschreiben Sie die Eigenschaften (reiner) Datenflussmodelle.</p> <ul> <li>Die Ausf\u00fchrung (die \"Feuerreihenfolge\" der Bl\u00f6cke) wird durch die Verf\u00fcgbarkeit von Daten bestimmt (Data Flow Order), nicht durch einen sequenziellen Programmz\u00e4hler (Control Flow). Sie sind inh\u00e4rent parallel.</li> </ul> <p>59. Beschreiben Sie die Eigenschaften des Ausf\u00fchrungsmodells \u201eEndlichen Zustandsautomaten\u201c.</p> <ul> <li>Das System befindet sich immer in einem definierten Zustand.</li> <li>Ereignisse (Events) l\u00f6sen \u00dcberg\u00e4nge (Transitionen) von einem Zustand in einen anderen aus.</li> <li>Gut geeignet f\u00fcr die Modellierung von reaktivem Verhalten (z.B. Steuerung von Benutzeroberfl\u00e4chen oder Protokollen).</li> </ul> <p>60. Was ist das zentrale Modellierungselement beim Ausf\u00fchrungsmodell diskrete Ereignisse?</p> <ul> <li>Das zentrale Element ist eine zeitlich sortierte Warteschlange von Ereignissen (Zeit-Aktions-Paare).</li> <li>Die Simulation \"springt\" von einem Ereigniszeitpunkt direkt zum n\u00e4chsten, die Zeit dazwischen wird \u00fcbersprungen.</li> </ul> <p>61. Was ist das Testobjekt bei Modell-in-the-Loop-Simulationen (MIL) und was ist der Zweck?</p> <ul> <li>Testobjekt: Das Modell selbst (z.B. das Simulink-Modell).</li> <li>Zweck: Test der Funktion und Algorithmenlogik auf dem Host-PC (Entwicklungsrechner), losgel\u00f6st von der Hardware.</li> </ul> <p>62. Was ist das Testobjekt bei Software-in-the-Loop-Simulationen (SIL) und was ist der Zweck?</p> <ul> <li>Testobjekt: Der automatisch generierte Code, der aus dem Modell erstellt wurde.</li> <li>Zweck: Test auf Konsistenz zwischen Modell und Code. Der Code l\u00e4uft (kompiliert) auf dem Host-PC.</li> </ul> <p>63. Was ist das Testobjekt bei Processor-in-the-Loop-Simulationen (PIL) und was ist der Zweck?</p> <ul> <li>Testobjekt: Der automatisch generierte Code, der f\u00fcr den Ziel-Prozessor (den realen Mikrocontroller) kompiliert wurde.</li> <li>Zweck: Test des Codes auf der realen Hardware (Prozessor). Testet den Compiler, das Laufzeitverhalten und den Ressourcenbedarf (z.B. Speicher, CPU-Zeit).</li> </ul> <p>64. Was ist das Testobjekt bei Hardware-in-the-Loop-Simulationen (HIL) und was ist der Zweck?</p> <ul> <li>Testobjekt: Das finale Steuerger\u00e4t (ECU) (komplette Hardware mit finaler Software).</li> <li>Zweck: Test des Steuerger\u00e4ts in Echtzeit. Die Umgebung (z.B. das Auto, der Motor) wird von einem HIL-Simulator in Echtzeit simuliert. Dient dem Test von kritischen Zust\u00e4nden und Diagnosefunktionen.</li> </ul> <p>65. Was ist der wesentliche Unterschied zwischen SIL und PIL?</p> <ul> <li>SIL: Der generierte Code l\u00e4uft auf dem Host-PC (Entwicklungsrechner).</li> <li>PIL: Der generierte Code l\u00e4uft auf dem realen Ziel-Prozessor (\\(\\mu C\\)).</li> </ul> <p>66. Was ist der wesentliche Unterschied zwischen PIL und HIL?</p> <ul> <li>PIL: Testet nur den Prozessor (oder ein Evaluationsboard) oft ohne Echtzeit-Anbindung an die Umgebung.</li> <li>HIL: Testet das komplette, finale Steuerger\u00e4t (ECU) unter Echtzeitbedingungen an einem Simulator, der die reale Umgebung (Prozess) nachbildet.</li> </ul> <p>67. Was ist Rapid Prototyping? Welche Ziele verfolgt man damit?</p> <ul> <li>Rapid Prototyping (RP) ist ein Ansatz, bei dem der generierte Code auf einem sehr leistungsf\u00e4higen, universellen Prototyping-Steuerger\u00e4t (z.B. dSpace Autobox) ausgef\u00fchrt wird.</li> <li>Dieses Steuerger\u00e4t wird direkt im realen System (z.B. im echten Fahrzeug) getestet, um die \"Quality Gates\" (SIL/PIL/HIL) zun\u00e4chst zu \u00fcberspringen.</li> <li>Ziel: Schnelle Validierung der Funktion im realen Umfeld und Identifikation von Streckenparametern.</li> </ul>"},{"location":"Prozessrechentechnik/SolutionsExamTraining/#sw-entwicklung-fur-es","title":"SW-Entwicklung f\u00fcr ES","text":"<p>68. Was sind die Eigenschaften und Anforderungen an die Software eingebetteter Systeme?</p> <ul> <li>Eigenschaften: Muss mit begrenzten Ressourcen (Speicher, Energie) auskommen, muss robust gegen fehlerhafte Eingaben (Sensordaten) sein.</li> <li>Anforderungen: Muss oft harten Echtzeitanforderungen, hohen Zuverl\u00e4ssigkeitsanforderungen und Anforderungen an die Funktionale Sicherheit (z.B. ISO 26262) gen\u00fcgen.</li> </ul> <p>69. In welche 3 klar definierbare, unterschiedliche und teils sogar widerspr\u00fcchlichen Systemeigenschaften l\u00e4sst sich der Begriff Verl\u00e4sslichkeit unterteilen? 1.  Zuverl\u00e4ssigkeit (Reliability): Kontinuierlich fehlerfreie Funktion \u00fcber einen Zeitraum. 2.  Verf\u00fcgbarkeit (Availability): Anteil der Zeit, in der das System funktioniert. 3.  Funktionale Sicherheit (Safety): Freiheit von nicht akzeptierbaren Risiken.</p> <p>70. Wie ist Zuverl\u00e4ssigkeit definiert? Ist sie wichtig f\u00fcr ES?</p> <ul> <li>Definition: Die Wahrscheinlichkeit (\\(R(t)\\)), dass das System eine Funktion \u00fcber einen festgelegten Zeitraum durchg\u00e4ngig fehlerfrei erf\u00fcllt.</li> <li>Wichtigkeit: Ja, sie ist extrem wichtig, da ein Ausfall (z.B. der Bremse) katastrophale Folgen haben kann.</li> </ul> <p>71. Wie ist Verf\u00fcgbarkeit definiert? Spielt sie bei sicherheitskritischen Systemen eine Rolle?</p> <ul> <li>Definition: Der Anteil der Zeit, in der das System funktioniert (\\(Verf\u00fcgbarkeit = \\frac{Gesamtzeit - Ausfallzeit}{Gesamtzeit}\\)).</li> <li>Rolle: Sie spielt eine untergeordnete Rolle. Ein System kann sicher, aber nicht verf\u00fcgbar sein (z.B. ein Zug, der im \"Not-Aus\" sicher steht), was besser ist als unsicher, aber verf\u00fcgbar (z.B. ein Zug mit defekten Bremsen, der f\u00e4hrt).</li> </ul> <p>72. Was ist der typische Verlauf der Ausfallrate als Funktion der Nutzungszeit? Begr\u00fcnden Sie den Verlauf.</p> <ul> <li>Dies ist die \"Badewannenkurve\":<ol> <li>Fr\u00fchausf\u00e4lle: Hohe, aber sinkende Ausfallrate (Produktionsfehler).</li> <li>Konsolidierungsphase: Konstante, niedrige Ausfallrate (Zufallsausf\u00e4lle).</li> <li>Altersausf\u00e4lle: Steigende Ausfallrate (Verschlei\u00df, Alterung).</li> </ol> </li> </ul> <p>73. Erkl\u00e4ren Sie die Begriffe Risiko und Grenzrisiko.</p> <ul> <li>Risiko: Das Produkt aus der Eintrittswahrscheinlichkeit eines Schadens und dem Schadensausma\u00df (Schwere des Schadens).</li> <li>Grenzrisiko: Das maximal gesellschaftlich oder normativ (z.B. in der ISO 26262) akzeptierte Restrisiko.</li> </ul> <p>74. Was ist Funktionale Sicherheit?</p> <ul> <li>Die Freiheit von nicht akzeptierbaren Risiken, die durch Fehlfunktionen des ES selbst entstehen (z.B. ein Airbag, der f\u00e4lschlicherweise ausl\u00f6st).</li> </ul> <p>75. Wie wirken sich empfindliche Fehlererkennungsmechanismen auf Zuverl\u00e4ssigkeit und Funktionale Sicherheit tendenziell aus.</p> <ul> <li>Sie erh\u00f6hen die Funktionale Sicherheit (Safety), da gef\u00e4hrliche Zust\u00e4nde erkannt und vermieden werden (z.B. durch Abschalten).</li> <li>Sie senken potenziell die Zuverl\u00e4ssigkeit (Reliability) / Verf\u00fcgbarkeit (Availability), da das System bei (vielleicht harmlosen) Fehlern \u00f6fter ausf\u00e4llt oder abgeschaltet wird.</li> </ul> <p>76. Welche Besonderheiten gelten f\u00fcr die Entwicklung sicherheitskritischer Systeme?</p> <ul> <li>Es m\u00fcssen strenge Normen (z.B. ISO 26262) befolgt werden.</li> <li>Es ist eine intensive Gefahren- und Risikoanalyse erforderlich.</li> <li>Redundanz (Hardware oder Software) wird oft eingesetzt.</li> <li>Es ist ein extrem rigoroser Verifikations- und Validierungsprozess notwendig.</li> </ul> <p>77. Was ist das Ziel von Reliability Engineering?</p> <ul> <li>Das Ziel ist die Gew\u00e4hrleistung der Verl\u00e4sslichkeit eines Systems durch den Einsatz von konstruktiven (Redundanz) und analytischen (Berechnungs) Ma\u00dfnahmen.</li> </ul> <p>78. Was ist das Ziel von analytischen Verfahren beim Reliability Engineering?</p> <ul> <li>Das Ziel ist die Berechnung oder Absch\u00e4tzung der Gesamtsystem-Zuverl\u00e4ssigkeit, basierend auf den Zuverl\u00e4ssigkeiten der einzelnen Komponenten.</li> </ul> <p>79. Wie berechnet sich die Zuverl\u00e4ssigkeit eines seriell/parallel gekoppelten Systems?</p> <ul> <li>(Mit \\(R_i\\) = Zuverl\u00e4ssigkeit der Komponente i)</li> <li>Serielle Kopplung (System f\u00e4llt aus, wenn 1 Komponente ausf\u00e4llt):</li> </ul> \\[R_{ges} = R_1 \\cdot R_2 \\cdot \\ldots \\cdot R_n\\] <ul> <li>Parallele Kopplung (System funktioniert, wenn mind. 1 Komponente funktioniert):</li> </ul> \\[R_{ges} = 1 - [(1-R_1) \\cdot (1-R_2) \\cdot \\ldots \\cdot (1-R_n)]\\] <p>80. Welche konstruktiven Ma\u00dfnahmen gibt es beim Reliability Engineering?</p> <ul> <li>Die wichtigste Ma\u00dfnahme ist der Einsatz von Redundanz:<ul> <li>Hardware-Redundanz</li> <li>Software-Redundanz</li> <li>Informations-Redundanz (z.B. Parit\u00e4tsbits, Pr\u00fcfsummen)</li> </ul> </li> </ul> <p>81. Was ist der Unterschied zw. statischer und dynamischer Redundanz bei Hardware?</p> <ul> <li>Statische Redundanz: Alle Komponenten sind parallel aktiv. Ein Mehrheitsentscheider (Voter) filtert fehlerhafte Ergebnisse heraus (z.B. 2-aus-3-System).</li> <li>Dynamische Redundanz: Es gibt aktive Komponenten und passive Reserve-Komponenten (Standby). Eine Fehlererkennung schaltet im Fehlerfall auf die Reservekomponente um.</li> </ul> <p>82. Wie schaut (statische, dynamische) Redundanz bei der eingebetteten Software aus?</p> <ul> <li>Statisch (N-Versions Programming): Mehrere (z.B. 3) unabh\u00e4ngige Teams entwickeln dieselbe Software. Alle Versionen laufen parallel, ein Voter entscheidet (sehr teuer).</li> <li>Dynamisch (Recovery Blocks): Eine Fehlererkennung (Plausibilisierung) pr\u00fcft das Ergebnis. Ist es fehlerhaft, wird eine alternative (anders implementierte) Software-Routine ausgef\u00fchrt.</li> </ul> <p>83. Warum sind der flexiblen Gestaltung der Software bei ES engere Grenzen gesetzt als bei IT-Systemen?</p> <ul> <li>Wegen der harten nicht-funktionalen Anforderungen: Strenge Echtzeit-Deadlines, limitierte Ressourcen (Speicher, CPU), hohe Anforderungen an Sicherheit und Verl\u00e4sslichkeit sowie die enge Verzahnung mit der Hardware (Treiber) schr\u00e4nken die Flexibilit\u00e4t ein.</li> </ul> <p>84. Was ist bei ES der Unterschied zwischen Plattformsoftware und Applikationssoftware?</p> <ul> <li>Plattformsoftware: Der hardwarenahe und anwendungsunabh\u00e4ngige Teil. Sie stellt Treiber (z.B. f\u00fcr CAN, ADC) und Basisdienste (z.B. Betriebssystem, Scheduling) bereit und abstrahiert die Hardware (z.B. AUTOSAR). Sie hat keine Semantik (liefert nur Rohwerte).</li> <li>Applikationssoftware: Der hardwareunabh\u00e4ngige Teil, der die eigentliche Funktion (z.B. Tempomat, Motorsteuerung) implementiert. Hier liegt das Dom\u00e4nenwissen und der Wettbewerbsvorteil. Sie tr\u00e4gt die Semantik (wei\u00df, was der Rohwert bedeutet).</li> </ul>"},{"location":"Prozessrechentechnik/SolutionsExamTraining/#fragen-zum-praktikum-freescale-videos","title":"Fragen zum Praktikum (Freescale-Videos)","text":"<p>85. Warum hat das im Praktikum verwendete Board (z.B. MPC560xB) mehrere Taktquellen?</p> <ul> <li>Es hat mehrere Quellen f\u00fcr unterschiedliche Zwecke:<ol> <li>Einen internen RC-Oszillator (FIRC) (16 MHz), der als schneller, aber ungenauer Standard-Takt nach dem Reset dient.</li> <li>Einen externen Oszillator (FXOSC) (4-16 MHz), der als pr\u00e4zise Basis f\u00fcr die PLL dient.</li> <li>Low-Power-Oszillatoren (SIRC/SXOSC) f\u00fcr Sleep-Modi.</li> </ol> </li> </ul> <p>86. Was ist der Vorteil des Externen Oszillators (Quarz-Kristall) gegen\u00fcber dem Internen RC-Oszillator?</p> <ul> <li>Ein externer Oszillator (Kristall) ist signifikant pr\u00e4ziser und stabiler (weniger Drift durch Temperatur oder Spannung) als ein interner RC-Oszillator. Der RC-Oszillator ist daf\u00fcr billiger und startet schneller.</li> </ul> <p>87. Warum ist eine genaue Taktquelle wichtig?</p> <ul> <li>Eine genaue Taktquelle (wie ein Kristall) ist unerl\u00e4sslich f\u00fcr:<ul> <li>Synchrone Kommunikation: Bussysteme wie CAN oder LIN ben\u00f6tigen exakte Baudraten.</li> <li>Pr\u00e4zise Zeitmessung: Alle Timer-Funktionen (EMIOS, PIT) h\u00e4ngen von der Genauigkeit des Taktes ab.</li> <li>Echtzeit-Verhalten: Die Einhaltung von Deadlines erfordert eine deterministische Zeitbasis.</li> </ul> </li> </ul> <p>88. Was ist die Phase-Locked Loop (PLL)? Wof\u00fcr wird sie verwendet?</p> <ul> <li>Die PLL (Phase-Locked Loop) ist eine Schaltung, die den Takt des externen Oszillators (FXOSC) als Referenz nutzt, um dessen Frequenz mit einem w\u00e4hlbaren Faktor zu multiplizieren.</li> <li>Sie wird verwendet, um den hohen Systemtakt (SYSCLK) zu erzeugen (z.B. 64 MHz aus einem 8 MHz Kristall).</li> </ul> <p>89. Zu was dient die Clock Monitorung Unit (CMU)?</p> <ul> <li>Die CMU (Clock Monitoring Unit) \u00fcberwacht die Funktionsf\u00e4higkeit der Taktquellen.</li> <li>Sie vergleicht Taktquellen miteinander. Bei einer Inkonsistenz (Fehler) kann sie einen Reset, einen Interrupt Request oder den \u00dcbergang in den SAFE Mode ausl\u00f6sen.</li> </ul> <p>90. Warum gibt es beim MPC560xB-Board verschiedene Run Modes?</p> <ul> <li>Aus Energiespargr\u00fcnden.</li> <li>Verschiedene Aufgaben (Tasks) ben\u00f6tigen unterschiedliche Ressourcen (z.B. Taktquellen, Peripherie). Die Run Modes (z.B. RUN0..3, HALT, STOP) erlauben es, nur die Komponenten zu aktivieren, die f\u00fcr die aktuelle Aufgabe ben\u00f6tigt werden, und den Rest abzuschalten (Clock Gating).</li> </ul> <p>91. Was ist der SAFE-Mode?</p> <ul> <li>Der SAFE-Mode ist ein System-Modus.</li> <li>Bei einem Hardware-Fehler (z.B. Ausfall einer Taktquelle erkannt durch die CMU) wechselt die MCU automatisch in diesen Modus.</li> <li>In diesem Modus kann Code ausgef\u00fchrt werden, um den Fehler zu diagnostizieren und das System in einen sicheren Zustand zu bringen.</li> </ul> <p>92. Warum ist das Cookbook (AN2865) ein wichtiges Dokument f\u00fcr den Entwickler?</p> <ul> <li>Das \"Qorivva Simple Cookbook\" (AN2865) ist wichtig, da es praktische Code-Beispiele (\"Hello World Programs\") f\u00fcr die g\u00e4ngigsten Funktionen und Peripherie-Initialisierungen (wie PLL- und Run-Mode-Konfiguration) enth\u00e4lt.</li> </ul> <p>93. F\u00fcr was ist der sogenannte Watch Dog gut?</p> <ul> <li>Der Watch Dog (Software Watchdog Timer, SWT) ist eine Sicherheitsfunktion, die nach dem Reset aktiv ist.</li> <li>Er muss vom laufenden Programm periodisch bedient (zur\u00fcckgesetzt) werden (durch Schreiben von <code>0xA602</code> und <code>0xB480</code>).</li> <li>Wenn das Programm \"h\u00e4ngenbleibt\" (z.B. in einer Endlosschleife), wird der Watchdog nicht mehr bedient, l\u00e4uft \u00fcber und l\u00f6st einen Reset aus, um das System wieder in einen definierten Zustand zu bringen.</li> </ul> <p>94. Die Abk\u00fcrzung EMIOS steht f\u00fcr Enhanced Modular Input/Output System. F\u00fcr was ist das Modul gut?</p> <ul> <li>EMIOS (Enhanced Modular Input/Output System) ist ein leistungsf\u00e4higes Timer-Modul.</li> <li>Es stellt Dutzende von Kan\u00e4len bereit, um zeitgesteuerte I/O-Funktionalit\u00e4ten (z.B. komplexe PWM-Signale erzeugen oder Input-Flanken exakt messen) unabh\u00e4ngig von der CPU zu realisieren.</li> </ul> <p>95. Nennen Sie 3 Beispiele f\u00fcr m\u00f6gliche I/O-Funktionalit\u00e4ten eines EMIOS-Kanals. 1.  MCB (Modulus Counter): Dient als Z\u00e4hler (Up oder Up/Down), der als (ggf. gemeinsame) Zeitbasis (\u00fcber einen Counter Bus) f\u00fcr andere Kan\u00e4le genutzt werden kann. 2.  SAIC (Single Action Input Capture): Erfasst den exakten Z\u00e4hlerstand (Zeitpunkt), zu dem eine Input-Signalflanke (steigend oder fallend) eintritt. 3.  OPWMB (Output Pulse Width Modulation): Erzeugt ein PWM-Signal, das auf einer externen Zeitbasis (einem anderen Counter Bus) basiert.</p> <p>96. Im Praktikum haben wir die Output-Funktionalit\u00e4t \u201ePulse Width Modulation Buffered\u201c verwendet.</p> <ul> <li>Frage 1: Woraus ergibt sich die Periodenl\u00e4nge T des PWM-Signals?<ul> <li>Im Modus \"Pulse Width Modulation Buffered\" (OPWMB) wird als Taktquelle ein externer Modulo-Counter (ein anderer EMIOS-Kanal, der als MCB konfiguriert ist) verwendet. Dieser Modulo-Counter definiert die feste Periodenl\u00e4nge des PWM-Signals.</li> </ul> </li> <li>Frage 2: Wie wird der Duty-Cycle tein des PWM-Signals eingestellt?<ul> <li>Der Duty-Cycle wird durch zwei Registerwerte innerhalb der Periode frei positioniert:<ul> <li>Register A1 (bzw. UCA[n]) definiert den Startpunkt (z.B. die steigende Flanke).</li> <li>Register B1 (bzw. UCB[n]) definiert den Endpunkt (z.B. die fallende Flanke).</li> </ul> </li> </ul> </li> <li>Frage 3: Wo wurde ein PWM-Signal im Praktikum verwendet?<ul> <li>(Typischerweise wird PWM im NXP-Cup-Praktikum f\u00fcr die Ansteuerung der Motoren (\u00fcber die H-Br\u00fccke) und des Lenk-Servos verwendet.)</li> </ul> </li> </ul> <p>97. Im Praktikum haben wir die Output-Funktionalit\u00e4t \u201ePulse Width Modulation with Trigger\u201c verwendet. Zu welchem Zweck wurde diese Output-Funktionalit\u00e4t verwendet?</p> <ul> <li>Der Modus OPWMT (PWM with Trigger) wird verwendet, um Ereignisse exakt zu synchronisieren.</li> <li>Er erzeugt nicht nur einen PWM-Puls (\u00fcber Register A1 und B1), sondern setzt auch zu einem dritten, frei w\u00e4hlbaren Zeitpunkt (definiert durch Register A2) ein FLAG (einen Trigger).</li> <li>Zweck: Dieses Flag kann (z.B. \u00fcber die CTU) genutzt werden, um eine A/D-Wandlung zu einem exakten Zeitpunkt innerhalb des PWM-Zyklus anzusto\u00dfen (z.B. zur Strommessung oder zur Synchronisation der Kamera).</li> </ul> <p>98. Ein EMIOS-Kanal hat auch einen Programmable Input Filter (in Hardware). F\u00fcr was ist dieser gut?</p> <ul> <li>Er dient zur Entprellung (Debouncing) von digitalen Eingangssignalen.</li> <li>Eine Signalflanke wird erst dann erkannt (weitergegeben), wenn das Signal f\u00fcr eine programmierbare Anzahl von Clock-Zyklen (z.B. 2, 4, 8 oder 16 Takte) stabil anliegt.</li> </ul> <p>99. Was ist ein Interrupt?</p> <ul> <li>Ein Interrupt ist eine asynchrone Unterbrechung des \"normalen\" Programmablaufs, die typischerweise durch Hardware (Peripherie) ausgel\u00f6st wird.</li> </ul> <p>100. Wo kommen die Interrupt-Requests einer Applikation i. d. R. her?</p> <ul> <li>Von den Peripherieelementen (z.B. ADC, EMIOS, PIT oder CAN), wenn diese ein Ereignis melden (z.B. \"Wandlung fertig\", \"Timer abgelaufen\", \"Nachricht empfangen\").</li> </ul> <p>101. Welche Zuordnung findet im Interrupt Controller statt?</p> <ul> <li>Der Interrupt Controller (INTC) ordnet jeder Interrupt-Request-Quelle (IR-Quelle) einen eigenen IR-Vektor (die Adresse der zugeh\u00f6rigen Behandlungsroutine/ISR) zu.</li> </ul> <p>102. Was hat die Verwendung von Interrupt f\u00fcr einen Vorteil?</p> <ul> <li>Effizienz. Statt die CPU durch \"Polling\" (st\u00e4ndiges Abfragen, z.B. \"Ist die Wandlung fertig?\") zu blockieren, kann die CPU andere Aufgaben erledigen oder in einen stromsparenden Modus wechseln. Sie wird nur dann aktiv (unterbrochen), wenn ein Peripherie-Ereignis dies erfordert.</li> </ul> <p>103. Was ist beim MPC560xB der Unterschied zwischen dem Software Vector Mode und dem Hardware Vector Mode?</p> <ul> <li>Software Vector Mode:<ul> <li>Optimiert f\u00fcr minimale Code-Gr\u00f6\u00dfe.</li> <li>Alle IRs landen in einem gemeinsamen Handler (z.B. IVOR 4). Die Software muss dann manuell (durch Lesen des IACKR-Registers) die genaue Quelle ermitteln und \u00fcber eine Sprungtabelle zur richtigen ISR springen.</li> </ul> </li> <li>Hardware Vector Mode:<ul> <li>Optimiert f\u00fcr minimale Latenz (Reaktionszeit).</li> <li>Jede IR-Quelle hat einen eigenen Vektor (Einsprungadresse) in der Hardware-Tabelle. Die Hardware springt direkt zur richtigen ISR, ohne dass die Software die Quelle suchen muss.</li> </ul> </li> </ul> <p>104. Was ist beim ADC-Modul der Scan Mode?</p> <ul> <li>Der Scan Mode ist eine Konvertierungsoption (im Gegensatz zum \"One shot mode\").</li> <li>Er dient der periodischen Konvertierung einer Gruppe (Maske) von Kan\u00e4len.</li> </ul> <p>105. Was macht der sogenannte Programmable Analog Watchdog des ADC-Moduls?</p> <ul> <li>Er erm\u00f6glicht die Definition eines Wertebereichs (eines programmierbaren oberen und unteren Schwellenwerts, THRH und THRL).</li> <li>Er \u00fcberwacht einen ADC-Kanal ohne CPU-Beteiligung.</li> <li>Wenn der Messwert diesen Bereich verl\u00e4sst, kann er einen Interrupt ausl\u00f6sen.</li> </ul> <p>106. Was ist die sogenannte Cross Trigger Unit (CTU)?</p> <ul> <li>Die CTU (Cross Trigger Unit) ist eine Hardware-Verbindungseinheit.</li> <li>Sie dient dazu, ein Timer-Event (von einem EMIOS-Kanal oder einem PIT) in einen ADC-Konvertierungs-Trigger umzuwandeln.</li> <li>Dies geschieht ohne CPU-Beteiligung und garantiert Synchronizit\u00e4t.</li> </ul> <p>107. F\u00fcr was wurde die CTU im Praktikum verwendet?</p> <ul> <li>Im Anwendungsbeispiel \"Einlesen der analogen Pixelwerte\" der Zeilenkamera (TSL1401).</li> <li>Ein EMIOS-Kanal (im OPWMT-Modus) erzeugt ein Trigger-Flag, das synchron zum Kamera-Takt (CAM CLK) ist.</li> <li>Dieses Flag l\u00f6st \u00fcber die CTU bei jedem Takt eine ADC-Wandlung aus, um den analogen Pixelwert einzulesen.</li> </ul> <p>108. Wie wurde bei unserem Fahrzeug die Belichtungsdauer der Kamera eingestellt?</p> <ul> <li>(Basierend auf dem TSL1401-Kamera-Timing):</li> <li>Die Belichtungsdauer (\"Integration\") ist die Zeit, in der die Pixel Licht sammeln.</li> <li>Diese Zeit wird durch den Zeitabstand zwischen dem Start-Impuls (SI) (der die Belichtung startet) und dem ersten Takt-Impuls (CLK) (der das Auslesen startet und die Belichtung beendet) gesteuert.</li> <li>Im Praktikum wurde dieser Zeitabstand durch die Konfiguration der EMIOS-Timer eingestellt.</li> </ul> <p>109. Was wurde bei unserem Fahrzeug mit einem SI-Signal alles ausgel\u00f6st/beeinflusst?</p> <ul> <li>(Basierend auf dem TSL1401-Kamera-Timing):</li> <li>Das SI-Signal (Serial Input) ist ein einzelner Puls.</li> <li>Er l\u00f6st zwei Dinge aus:<ol> <li>Er startet den Belichtungszyklus (Integration) der 128 Pixel.</li> <li>Er startet den Auslesevorgang (Vorbereitung zur Ausgabe von Pixel 1 beim n\u00e4chsten Takt).</li> </ol> </li> </ul> <p>110. Was kann man mit einem DMA-Request erreichen?</p> <ul> <li>Einen Datentransfer (Kopierauftrag) zwischen Speicher und Peripherie (oder RAM zu RAM) ausf\u00fchren, ohne dass die CPU beteiligt ist.</li> </ul> <p>111. Was kann man mit DMA (h\u00e4ufig) vermeiden?</p> <ul> <li>Eine CPU-Beteiligung. Die CPU wird nicht durch Kopierroutinen (z.B. in einer ISR) blockiert und hat Zeit f\u00fcr andere Aufgaben.</li> </ul> <p>112. Was kann alles einen DMA-Request ausl\u00f6sen? 1.  Peripherieelemente (z.B. ADC-Konvertierung fertig, EMIOS-Event, DSPI-Empfangspuffer voll). 2.  Software (durch Setzen eines Bits in einem Register). 3.  Ein Periodical Interval Timer (PIT) (f\u00fcr periodische DMA-Transfers).</p> <p>113. Welche M\u00f6glichkeiten bietet DMA noch mit Bezug auf die Konfiguration von Peripherieelementen?</p> <ul> <li>DMA kann Peripherieelemente automatisch rekonfigurieren.</li> <li>Beispiel: Ein DMA-Transfer (ausgel\u00f6st durch ein EMIOS-Event) kann neue Werte (f\u00fcr den n\u00e4chsten Puls) aus dem RAM direkt in die EMIOS-Register (CADR/CBDR) schreiben.</li> <li>Dies erm\u00f6glicht Verkettungen (Chaining) von Peripherie-Aktionen ohne CPU-Beteiligung.</li> </ul> <p>114. Was ist das Scatter-Gather Feature des DMA-Moduls?</p> <ul> <li>Es erlaubt einem DMA-Kanal, nach Abschluss eines Transfers automatisch einen neuen Transfer Control Descriptor (TCD) (der die Parameter f\u00fcr den n\u00e4chsten Transfer enth\u00e4lt) aus dem Speicher zu laden.</li> <li>Dies erm\u00f6glicht es, Daten von mehreren, nicht zusammenh\u00e4ngenden Quellen zu sammeln (Gather) oder Daten an mehrere, nicht zusammenh\u00e4ngende Ziele zu verteilen (Scatter).</li> </ul> <p>115. Erl\u00e4utern Sie die Begriffe Regelstrecke, F\u00fchrungsgr\u00f6\u00dfe, Regelgr\u00f6\u00dfe, Regelabweichung u. Stellgr\u00f6\u00dfe.</p> <ul> <li>Regelstrecke: Der zu beeinflussende Prozess oder Teil des Systems, der geregelt werden soll (z.B. der Motor, die Heizung).</li> <li>F\u00fchrungsgr\u00f6\u00dfe (w): Der vorgegebene Wert, den die Regelgr\u00f6\u00dfe erreichen soll (der Soll-Wert).</li> <li>Regelgr\u00f6\u00dfe (x): Die Ausgangsgr\u00f6\u00dfe der Strecke, die gemessen wird (der Ist-Wert).</li> <li>Regelabweichung (e): Die Differenz zwischen Soll- und Ist-Wert (\\(e = w - x\\)). Sie ist die Eingangsgr\u00f6\u00dfe des Reglers.</li> <li>Stellgr\u00f6\u00dfe (y): Die Ausgangsgr\u00f6\u00dfe des Reglers, die auf die Regelstrecke einwirkt, um die Regelabweichung zu korrigieren.</li> </ul> <p>116. Die Glieder der Regelstrecke werden entsprechend ihrem Zeitverhalten charakterisiert. Wie kann man das Zeitverhalten herausfinden?</p> <ul> <li>Indem man die Sprungantwort der Regelstrecke aufnimmt.</li> <li>Dazu legt man am Eingang der (ge\u00f6ffneten) Strecke ein Testsignal (eine sprunghafte \u00c4nderung der Eingangsgr\u00f6\u00dfe) an und zeichnet die Reaktion (Antwort) am Ausgang auf. Die Form dieser Antwort (z.B. S-f\u00f6rmig) charakterisiert die Strecke.</li> </ul> <p>117. Nennen Sie 4 unterschiedliche Typen von \u00dcbertragungsverhalten. Nenne Sie zu jedem auch ein Beispiel. 1.  P-Glied (Proportional): Ausgang folgt dem Eingang sofort.   * Beispiel: Hebel, Getriebe, Spannungsteiler. 2.  I-Glied (Integrierend): Ausgang ist das Integral des Eingangs (rampt auf).   * Beispiel: Strom, der einen Kondensator l\u00e4dt (Eingang: Strom, Ausgang: Spannung). 3.  \\(PT_1\\)-Glied (Verz\u00f6gerungsglied 1. Ordnung): Sprung am Eingang f\u00fchrt zu exponentiellem Anstieg am Ausgang.   * Beispiel: RC-Glied (Spannung), Gleichstrommotor (Eingang: Spannung, Ausgang: Drehzahl). 4.  \\(PT_2\\)-Glied (Verz\u00f6gerungsglied 2. Ordnung): Kann schwingen.   * Beispiel: Mechanischer Schwinger (Feder-Masse-D\u00e4mpfer-System), elektrischer RLC-Schwingkreis.</p> <p>118. Was ist das Problem beim P-Regler?</p> <ul> <li>Er hat eine bleibende Regelabweichung. Er wird den Soll-Wert (bei Strecken ohne I-Anteil) nie exakt erreichen; es bleibt immer ein kleiner Fehler bestehen.</li> </ul> <p>119. Was sind die Eigenschaften eines I-Reglers?</p> <ul> <li>Er summiert die Regelabweichung \u00fcber die Zeit auf (Integral).</li> <li>Vorteil: Er kann die bleibende Regelabweichung vollst\u00e4ndig eliminieren.</li> <li>Nachteil: Er ist langsam und neigt zum Schwingen (instabil).</li> </ul> <p>120. Was sind die Vor- und Nachteile eines PD-Reglers?</p> <ul> <li>Vorteile:<ul> <li>Er reagiert auf die \u00c4nderung der Abweichung (D-Anteil) und ist dadurch sehr schnell (er \"h\u00e4lt vor\").</li> <li>Der D-Anteil wirkt d\u00e4mpfend und stabilisierend.</li> </ul> </li> <li>Nachteile:<ul> <li>Er hat eine bleibende Regelabweichung (da der I-Anteil fehlt).</li> <li>Er verst\u00e4rkt Rauschen im Sensorsignal (durch die Differenziation), was zu Unruhe im Stellglied f\u00fchrt.</li> </ul> </li> </ul> <p>121. Welchen Typ von Regler implementieren diese Codezeilen?: <code>esum = esum + e; y = Kp*e + Ki*Ta*esum;</code></p> <ul> <li>Dies ist ein PI-Regler (Proportional-Integral-Regler).<ul> <li><code>Kp*e</code> ist der P-Anteil.</li> <li><code>Ki*Ta*esum</code> ist der I-Anteil (wobei <code>esum</code> die Summe \\(e_i\\) ist und \\(T_a\\) die Abtastzeit).</li> </ul> </li> </ul> <p>122. Welchen Typ von Regler implementieren diese Codezeilen?: <code>y = Kp*e + Kd*(e - ealt)/Ta; ealt = e;</code></p> <ul> <li>Dies ist ein PD-Regler (Proportional-Differential-Regler).<ul> <li><code>Kp*e</code> ist der P-Anteil.</li> <li><code>Kd*(e - ealt)/Ta</code> ist der D-Anteil (gen\u00e4hert durch die Differenz zum \"alten e\" geteilt durch die Abtastzeit \\(T_a\\)).</li> </ul> </li> </ul> <p>123. In welchen (2) F\u00e4llen reicht f\u00fcr einfache Regelaufgaben ein einfacher P-Regler aus?</p> <ol> <li>Wenn die bleibende Regelabweichung klein genug ist und toleriert (vernachl\u00e4ssigt) werden kann.</li> <li>Wenn die Regelstrecke selbst bereits einen I-Anteil besitzt (z.B. Regelung der Position bei einem Motor, der \u00fcber die Geschwindigkeit gestellt wird).</li> </ol> <p>124. Welche Vorteile haben digitale Regler?</p> <ul> <li>Sie arbeiten driftfrei (im Gegensatz zu analogen Bauteilen, die altern oder temperaturabh\u00e4ngig sind).</li> <li>Es lassen sich komplexe, nichtlineare oder adaptive Regler leichter realisieren.</li> <li>Der Regler kann bei Bedarf einfach per Software neu konfiguriert und parametriert werden.</li> </ul> <p>125. Nennen Sie 3 prinzipielle Vorgehensweisen, wie man die Reglerparameter eines PID-Reglers ermitteln kann.</p> <ol> <li>Empirisches Einstellen (systematisches Probieren/Tuning von \\(K_p\\), \\(K_i\\), \\(K_d\\) an der realen Strecke).</li> <li>Verwendung von Einstellregeln (z.B. nach Ziegler/Nichols):<ul> <li>Schwingungsmethode: \\(K_p\\) wird bis zur Stabilit\u00e4tsgrenze (Dauerschwingung) erh\u00f6ht (\\(K_{pkrit}\\), \\(T_{krit}\\)).</li> <li>Sprungantwort-Methode: Aufnahme der Sprungantwort (Ermittlung von \\(T_u\\) und \\(T_g\\)).</li> </ul> </li> <li>Physikalische Modellierung: Mathematisches Modell der Strecke erstellen und die Reglerparameter in der Simulation optimieren.</li> </ol> <p>126. Wann kann ein digitaler Regler wie ein analoger Regler parametrisiert/dimensioniert werden?</p> <ul> <li>Wenn die Abtastzeit (\\(T_a\\)) sehr viel kleiner ist (z.B. Faktor 10-20) als die dominierende Zeitkonstante der Regelstrecke.</li> <li>In diesem Fall verh\u00e4lt sich das System \"quasi-kontinuierlich\" und die Effekte der digitalen Abtastung k\u00f6nnen vernachl\u00e4ssigt werden.</li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/","title":"Praktikum","text":""},{"location":"Prozessrechentechnik/SummaryExercises/#1-uberblick-automotive-mcus","title":"1. \u00dcberblick: Automotive MCUs","text":"<p>Das Dokument gibt einen \u00dcberblick \u00fcber das 32-bit PowerPC Automotive Mikrocontroller (MCU) Portfolio von Freescale, sortiert nach Anwendungsbereichen wie Powertrain, Chassis &amp; Safety, Body &amp; Gateways sowie Kommunikation (CAN, LIN, FlexRay).</p> <p>Zwei MCUs werden exemplarisch detaillierter vorgestellt: * MPC5604B: Basiert auf dem Power Architecture e200z0 Core (48-64MHz), ausgestattet mit 512KB Flash, 48K SRAM, 3 FlexCAN-Modulen, 4 LINFlex-Modulen und einem 36-Kanal 10-bit ADC. * MPC5607B: Ein gr\u00f6\u00dferer Bruder mit 1.5MB Flash, 96K SRAM, einem 16-Kanal DMA, 6 FlexCAN, 10 LINFlex und einem 52-Kanal ADC (kombiniert 10-bit und 12-bit Kan\u00e4le).</p>"},{"location":"Prozessrechentechnik/SummaryExercises/#2-byte-reihenfolge-endianness","title":"2. Byte-Reihenfolge (Endianness)","text":"<p>Die PowerPC-Architektur verwendet von Natur aus die Big Endian Byte-Ordnung. Das bedeutet, das signifikanteste Byte (Most Significant Byte, MSb) wird an der niedrigsten Speicheradresse abgelegt.</p>"},{"location":"Prozessrechentechnik/SummaryExercises/#3-siul-system-integration-unit-lite","title":"3. SIUL (System Integration Unit Lite)","text":"<p>Die SIUL ist eine zentrale \"Glue Logic\"-Einheit, die die Konfiguration und das Multiplexing (IOMux) der Pins steuert.</p> <ul> <li>Funktionen:<ul> <li>Pad Control: Konfiguriert die elektrischen Parameter jedes Pins (z.B. Output Buffer, Open Drain, Pull-up/Pull-down).</li> <li>IOMux: Weist den Pins Signale zu. Jedem Pin k\u00f6nnen mehrere Funktionen (Alternate Functions, z.B. AF0-AF3) zugewiesen werden.</li> <li>GPIO: Erm\u00f6glicht die Nutzung von Pins als allgemeine digitale Ein- oder Ausg\u00e4nge.</li> <li>External Interrupt Management: Verwaltet externe Interrupt-Signale, inklusive digitaler Glitch-Filter.</li> </ul> </li> <li>Wichtige Register:<ul> <li>PCR (Pad Configuration Register): Konfiguriert jeden Pin individuell. Wichtige Felder sind:<ul> <li><code>PA</code> (Pad Assignment): W\u00e4hlt die Alternate Function (z.B. GPIO, CAN, EMIOS) f\u00fcr den Pin.</li> <li><code>OBE</code> (Output Buffer Enable): Aktiviert den Pin als Ausgang.</li> <li><code>IBE</code> (Input Buffer Enable): Aktiviert den Pin als Eingang.</li> <li><code>WPE</code> / <code>WPS</code>: Aktivieren und w\u00e4hlen eines Weak Pull-Up oder Pull-Down Widerstands.</li> </ul> </li> <li>PSMI (Pad Select Multiplexed Inputs): W\u00e4hlt bei Peripherie-Eing\u00e4ngen, die mit mehreren Pins verbunden sind, aus, welcher Pin tats\u00e4chlich als Quelle genutzt wird.</li> </ul> </li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#4-clocks-taktquellen","title":"4. Clocks (Taktquellen)","text":"<p>Das System-Timing ist hochkonfigurierbar und essenziell f\u00fcr das Power-Management.</p> <ul> <li>Taktquellen:<ul> <li>FIRC (16 MHz Internal RC): Der interne RC-Oszillator. Dies ist der Standard-Takt nach einem Reset.</li> <li>FXOSC (4-16 MHz External): Ein externer Kristall/Oszillator (im Praktikum 8 MHz).</li> <li>FMPLL (Phase Lock Loop): Multipliziert eine Eingangsfrequenz (meist FXOSC), um den Hochgeschwindigkeits-Systemtakt (z.B. 64 MHz) zu erzeugen.<ul> <li>Formel: \\(FMPLL = \\frac{FXOSC \\cdot NDIV}{IDF \\cdot ODF}\\)</li> </ul> </li> <li>Low Power Quellen: SIRC (128 KHz) und SXOSC (32 KHz) f\u00fcr RTC (Real-Time Clock) und Watchdog im Sleep-Modus.</li> </ul> </li> <li>CMU (Clock Monitoring Unit): \u00dcberwacht die Takte auf Konsistenz (z.B. Vergleich FIRC mit FXOSC). Bei Fehlern kann die CMU einen Reset, einen Interrupt oder den \u00dcbergang in den <code>SAFE</code> Mode ausl\u00f6sen.</li> <li>CGM (Clock Generation Module) Struktur:<ul> <li>Der System Clock Selector (ME) w\u00e4hlt die Hauptquelle f\u00fcr die <code>SYSCLK</code> (FIRC, FXOSC oder FMPLL).</li> <li>Diese <code>SYSCLK</code> wird auf den Core und auf 3 \"Peripheral Sets\" verteilt.</li> <li>Der Takt f\u00fcr jedes Peripherie-Set kann durch einen eigenen Teiler (1-16) im <code>CGM_SC_DCx</code>-Register verlangsamt werden, um Energie zu sparen.</li> </ul> </li> <li>CLKOUT: Ein ausgew\u00e4hlter Takt (FIRC, FXOSC, FMPLL) kann zur \u00dcberpr\u00fcfung auf einen externen Pin (GPIO[0]) ausgegeben werden.</li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#5-run-modes-betriebsmodi","title":"5. Run Modes (Betriebsmodi)","text":"<p>Die Run Modes sind das Kernkonzept des Power-Managements. Sie definieren, welche Systemkomponenten (Takte, Peripherie, Flash) aktiv sind.</p> <ul> <li>Modi-Typen:<ul> <li>System Modes: <code>RESET</code>, <code>DRUN</code> (Default Run), <code>SAFE</code>, <code>TEST</code>.</li> <li>User Modes: <code>RUN0</code>...<code>RUN3</code> (normale Betriebsmodi), <code>HALT</code>, <code>STOP</code>, <code>STANDBY</code> (Low-Power-Modi).</li> </ul> </li> <li>Ablauf: Nach einem Reset startet der MCU im <code>DRUN</code>-Modus. In diesem Modus wird typischerweise die Konfiguration f\u00fcr die User Modes (z.B. <code>RUN0</code>) vorgenommen.</li> <li>Konfiguration:<ul> <li><code>ME_xxx_MC</code> Register: F\u00fcr jeden Modus (z.B. <code>ME_RUN0_MC</code>) gibt es ein Konfigurationsregister. Dieses legt fest:<ul> <li>Welche Taktquellen aktiv sind (<code>PLLON</code>, <code>OSCON</code>, <code>IRCON</code>).</li> <li>Welche Quelle f\u00fcr die <code>SYSCLK</code> verwendet wird.</li> <li>Ob das Flash (<code>CFLAON</code>, <code>DFLAON</code>) oder der Spannungsregler (<code>MVRON</code>) aktiv sind.</li> </ul> </li> </ul> </li> <li>Peripheral Clock Gating: Das Aktivieren von Takten f\u00fcr Peripherieger\u00e4te ist ein zweistufiger Prozess:<ol> <li><code>ME_RUN_PCx</code> (Peripheral Configuration): 8 Register (<code>PC0</code>...<code>PC7</code>) definieren 8 \"Policies\", die festlegen, in welchen Modi (RUN0, RUN1, DRUN...) eine Policy aktiv ist.</li> <li><code>ME_PCTLx</code> (Peripheral Control): F\u00fcr jedes Peripherieger\u00e4t (z.B. <code>PCTL[68]</code> f\u00fcr SIUL) gibt es ein Register, das eine der 8 Policies (<code>PC0</code>...<code>PC7</code>) ausw\u00e4hlt.</li> </ol> </li> <li>Mode-\u00dcbergang (Transition):<ul> <li>Ein Wechsel (z.B. von <code>DRUN</code> zu <code>RUN0</code>) wird durch Schreiben eines Schl\u00fcssels in das <code>ME_MCTL.R</code>-Register eingeleitet.</li> <li>Das System muss danach warten, bis der \u00dcbergang abgeschlossen ist (z.B. durch Polling des <code>ME.GS.B.S_MTRANS</code>-Bits), da Taktquellen (insb. die PLL) Zeit zum Einschwingen ben\u00f6tigen.</li> </ul> </li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#6-timed-io-zeitgesteuerte-ein-ausgabe","title":"6. Timed I/O (Zeitgesteuerte Ein-/Ausgabe)","text":"<p>Dieser Abschnitt umfasst den Watchdog, den PIT und das extrem wichtige EMIOS-Modul.</p> <ul> <li>Watch Dog (SWT): Ist nach dem Reset standardm\u00e4\u00dfig aktiv. Er muss entweder periodisch \"bedient\" (durch Schreiben von <code>0xA602</code> und <code>0xB480</code> in <code>SWT_SR</code>) oder explizit deaktiviert werden, um einen Reset zu verhindern.</li> <li>PIT (Periodical Interrupt Timer): Stellt 32-bit-Z\u00e4hler bereit, die vom Systemtakt getrieben werden. Sie sind voneinander unabh\u00e4ngig und k\u00f6nnen Interrupts, DMA-Anfragen oder ADC-Konvertierungen (direkt oder via CTU) ausl\u00f6sen.</li> <li>EMIOS (Enhanced Modular Input/Output System): Ein leistungsf\u00e4higes, CPU-unabh\u00e4ngiges Timer-Modul zur Erzeugung und Messung von zeitbasierten Signalen.<ul> <li>Struktur: Besteht aus \"Unified Channels\". Jeder Kanal kann f\u00fcr eine spezifische Funktion konfiguriert werden. Die Taktung wird von der <code>SYSCLK</code> abgeleitet und kann mehrfach geteilt werden (Common Divider \\(\\to\\) Global Prescaler \\(\\to\\) Channel Prescaler).</li> <li>Counter Buses: 5 interne Busse (A-E) erlauben es, einen Kanal als Z\u00e4hler (Zeitbasis) zu konfigurieren und dieses Signal an andere Kan\u00e4le im selben Modul zu verteilen (z.B. Ch 23 \u00fcber Bus A an alle).</li> <li>Doppelte Pufferung (Double Buffering): Die Register A und B (die Zeitpunkte oder Schwellen definieren) sind doppelt gepuffert (A1/A2, B1/B2). Dies erm\u00f6glicht \"sichere\" Updates: Ein neuer Wert wird in A2 geschrieben, wird aber erst zu Beginn des n\u00e4chsten Zyklus in A1 (das aktive Register) \u00fcbernommen.</li> </ul> </li> </ul> <ul> <li>Wichtige EMIOS-Modi:<ul> <li>Counter-Modi:<ul> <li><code>MCB</code> (Modulus Counter Buffered): Ein Z\u00e4hler, der bis zum Wert in Register A1 z\u00e4hlt und dann zur\u00fcckgesetzt wird. Dient oft als Zeitbasis f\u00fcr andere Kan\u00e4le.</li> </ul> </li> <li>Input-Modi:<ul> <li><code>SAIC</code> (Single Action Input Capture): Bei einer definierten Signalflanke (steigend/fallend) wird der aktuelle Z\u00e4hlerstand im Register A2 gespeichert und ein Flag gesetzt.</li> <li><code>IPWM</code> (Input Pulse Width Measurement): Misst die Pulsbreite. Speichert den Z\u00e4hlerstand der f\u00fchrenden Flanke in B2 und den der folgenden Flanke in A2. Die Software berechnet die Differenz (<code>A2 - B1</code>).</li> <li><code>IPM</code> (Input Period Measurement): \u00c4hnlich wie IPWM, misst aber die Zeit zwischen zwei Flanken gleicher Richtung (z.B. steigend zu steigend).</li> </ul> </li> <li>Output-Modi:<ul> <li><code>DAOC</code> (Double Action Output Compare): Erzeugt einen Puls. Bei Erreichen von A1 wird die f\u00fchrende Flanke, bei Erreichen von B1 die folgende Flanke ausgel\u00f6st.</li> <li><code>OPWMB</code> (Output Pulse Width Modulation Buffered): Nutzt eine externe Zeitbasis (von einem MCB-Kanal). A1 und B1 definieren die f\u00fchrende und folgende Flanke des PWM-Pulses innerhalb dieser Periode.</li> <li><code>OPWMT</code> (OPWM with Trigger): Der wichtigste Modus f\u00fcr den Freescale Cup. Wie OPWMB, f\u00fcgt aber einen dritten Zeitpunkt (Register A2) hinzu. Wenn der Z\u00e4hler A2 erreicht, wird ein FLAG gesetzt. Dieses Flag wird genutzt, um die CTU (und damit den ADC) zu einem exakten Zeitpunkt innerhalb des PWM-Pulses zu triggern.</li> </ul> </li> </ul> </li> <li>EMIOS Input Filter: Ein digitaler Filter (5-bit Z\u00e4hler), der Eingangssignale \"entprellt\". Ein Signal wird erst als ge\u00e4ndert erkannt, wenn es f\u00fcr eine definierte Anzahl von Takten (z.B. 2, 4, 8 oder 16) stabil anliegt.</li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#7-interrupts-intc","title":"7. Interrupts (INTC)","text":"<p>Der Interrupt Controller (INTC) verwaltet Peripherie-Interrupts.</p> <ul> <li>Core vs. Peripherie: Der CPU-Core hat eigene Exceptions (z.B. Machine Check). Alle Interrupts von Peripherieger\u00e4ten (ADC, CAN, EMIOS, PIT etc.) werden vom INTC verwaltet und an den Core \u00fcber die \"External Input Exception\" (IVOR 4) gemeldet.</li> <li>Verhalten (Ablauf): Bei einem Interrupt sichert die Hardware automatisch den Befehlsz\u00e4hler (in <code>SRR0</code>) und das Maschinenstatusregister (in <code>SRR1</code>). Der Programmzeiger springt zur Vektoradresse. Die Interrupt-Service-Routine (ISR) wird ausgef\u00fchrt. Das <code>rfi</code> (Return from Interrupt) Kommando am Ende stellt <code>SRR0</code> und <code>SRR1</code> wieder her.</li> <li>Handshaking-Modi:<ul> <li>Software Vector Mode: (Standard) Alle INTC-Interrupts landen im selben Handler (IVOR 4). Die Software muss dann das <code>IACKR</code>-Register des INTC lesen, um die eigentliche Quelle (z.B. PIT-Kanal 2) zu identifizieren und \u00fcber eine Sprungtabelle zur richtigen ISR zu springen. Optimiert f\u00fcr Codegr\u00f6\u00dfe.</li> <li>Hardware Vector Mode: Jeder Interrupt-Quelle wird ein eigener Vektor zugewiesen, der direkt zur ISR springt. Optimiert f\u00fcr Latenz.</li> </ul> </li> <li>Priorit\u00e4ten:<ul> <li>Es gibt 16 Priorit\u00e4tsstufen (15 = h\u00f6chste, 0 = niedrigste, wird nie erkannt).</li> <li>Jede IR-Quelle erh\u00e4lt eine Priorit\u00e4t im <code>INTC_PSRx</code>-Register.</li> <li>Das <code>INTC_CPR</code> (Current Priority Register) speichert die Priorit\u00e4t der aktuell laufenden ISR. Nur Interrupts mit einer h\u00f6heren Priorit\u00e4t als der im <code>INTC_CPR</code> k\u00f6nnen diese unterbrechen (Preemption).</li> <li>WICHTIG: Nach einem Reset steht das <code>INTC_CPR</code> auf 15 (h\u00f6chste Priorit\u00e4t). Das bedeutet, alle Interrupts sind maskiert. Um Interrupts zu aktivieren, muss das <code>INTC_CPR</code> manuell auf 0 (oder eine andere Basispriorit\u00e4t) gesetzt werden.</li> </ul> </li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#8-adc-und-ctu-analog-digital-converter-cross-trigger-unit","title":"8. ADC und CTU (Analog-Digital-Converter &amp; Cross Trigger Unit)","text":"<ul> <li>ADC: Wandelt analoge Spannungen (0-5V) in digitale Werte um. Der MPC5607B hat sowohl 10-bit als auch pr\u00e4zisere 12-bit Kan\u00e4le. Jeder Kanal hat ein eigenes Datenregister (<code>CDR</code>), das den Wert (<code>CDATA</code>) und Statusbits (<code>VALID</code>, <code>OVERWrite</code>) enth\u00e4lt.</li> <li>Trigger-Optionen: Eine ADC-Wandlung kann auf drei Arten ausgel\u00f6st werden, die sich gegenseitig unterbrechen (pr\u00e4emptiv):<ol> <li>Normal Conversion: (Niedrigste Priorit\u00e4t) Ausgel\u00f6st durch Software (Setzen des <code>NSTART</code>-Bits).</li> <li>Injected Conversion: (Mittlere Priorit\u00e4t) Ausgel\u00f6st durch Software (<code>JSTART</code>-Bit) oder <code>PIT2</code>. Unterbricht eine laufende \"Normal\"-Kette.</li> <li>CTU (Cross Trigger Unit): (H\u00f6chste Priorit\u00e4t) Ausgel\u00f6st durch <code>PIT3</code>, <code>PIT7</code> oder <code>EMIOS</code>-Kan\u00e4le. Unterbricht \"Normal\" und \"Injected\".</li> </ol> </li> <li>Analog Watchdog: Erm\u00f6glicht eine CPU-unabh\u00e4ngige Bereichs\u00fcberwachung (<code>THRL</code>, <code>THRH</code>) eines Analogkanals und kann bei Verletzung einen Interrupt ausl\u00f6sen.</li> <li>CTU (Cross Trigger Unit):<ul> <li>Die CTU ist die Hardware-Verbindung zwischen den Timern (EMIOS, PIT) und dem ADC.</li> <li>Sie erm\u00f6glicht es, eine ADC-Wandlung ohne CPU-Beteiligung und mit exaktem Timing durch ein Timer-Ereignis auszul\u00f6sen.</li> </ul> </li> <li>Anwendungsbeispiele:<ol> <li>Induktivit\u00e4tsmessung: Ein EMIOS-Kanal im <code>OPWMT</code>-Modus schaltet einen PWM-Puls (Match A1, Match B1). Ein dritter Zeitpunkt (Match A2) ist so gesetzt, dass der Einschwingstrom (Inrush Current) der Spule abgeklungen ist. Dieser A2-Match triggert \u00fcber die CTU die ADC-Messung zum exakt richtigen Zeitpunkt.</li> <li>Zeilenkamera (TSL1401): Die Kamera ben\u00f6tigt ein Start-Impuls (SI) und einen Takt (CLK) und liefert pro Takt einen analogen Pixelwert (AO). EMIOS-Kan\u00e4le erzeugen CPU-unabh\u00e4ngig die SI- und CLK-Signale. Der EMIOS-Kanal, der den CLK erzeugt, ist im <code>OPWMT</code>-Modus und triggert (via Match A2) \u00fcber die CTU bei jeder Taktflanke eine ADC-Wandlung, um den analogen Pixelwert einzulesen.</li> </ol> </li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#9-dma-direct-memory-access","title":"9. DMA (Direct Memory Access)","text":"<p>DMA erm\u00f6glicht Datentransfers zwischen Peripherie und Speicher (oder Peripherie zu Peripherie) ohne CPU-Beteiligung.</p> <ul> <li>TCD (Transfer Control Descriptor): Das \"Gehirn\" jedes DMA-Kanals. Definiert die Quelle (<code>saddr</code>), das Ziel (<code>daddr</code>), die Transfergr\u00f6\u00dfe (<code>ssize</code>, <code>dsize</code>), die Anzahl der Bytes pro Request (<code>nbytes</code>, minor loop) und die Gesamtzahl der Requests (<code>citer</code>, major loop).</li> <li>DMA Mux: Ein Multiplexer verbindet die 16 DMA-Kan\u00e4le mit Dutzenden von m\u00f6glichen Anforderungs-Quellen (DSPI, eMIOS, ADC, IIC oder \"Always Enabled\" f\u00fcr PIT/Software-Trigger).</li> <li>Features:<ul> <li>Modulo: N\u00fctzlich f\u00fcr Ringpuffer (Circular Buffers). Erm\u00f6glicht das automatische \"Umbrechen\" (Wraparound) der Quell- oder Zieladresse, indem nur die unteren Adressbits inkrementiert werden.</li> <li>Scatter-Gather: Erm\u00f6glicht das Verketten von TCDs. Ein TCD kann nach Abschluss die Adresse eines neuen TCDs (gespeichert in <code>sga</code>) laden und diesen aktivieren. Dies erlaubt komplexe Sequenzen.</li> <li>Channel Linking: Ein DMA-Kanal kann nach Abschluss (minor oder major loop) einen anderen DMA-Kanal starten.</li> </ul> </li> <li>Arbitrierung: Die DMA-Kan\u00e4le haben eine feste Priorit\u00e4t (Fixed-Priority Arbitration), um zu entscheiden, welcher Kanal bei gleichzeitigen Anfragen den Buszugriff erh\u00e4lt.</li> <li>Beispiele:<ol> <li>Wellenform erfassen (EMIOS \\(\\to\\) RAM): Ein EMIOS-Kanal (im IPWM-Modus) misst Pulsbreiten. Jede Messung (z.B. fallende Flanke) l\u00f6st einen DMA-Request aus. Der DMA-Kanal liest die Zeitstempel aus den EMIOS-Registern (<code>CADR</code>, <code>CBDR</code>) und schreibt sie in einen Puffer im RAM. Wenn der Puffer voll ist (major loop complete), wird ein einziger Interrupt (<code>INT_MAJ</code>) ausgel\u00f6st, damit die CPU die gesammelten Daten verarbeiten kann.</li> <li>Wellenform generieren (RAM \\(\\to\\) EMIOS): Ein Array im RAM enth\u00e4lt eine Sequenz von Zeitstempeln. Ein EMIOS-Kanal ist im <code>DAOC</code>-Modus. Ein DMA-Request (ausgel\u00f6st durch den Abschluss des vorherigen Pulses) kopiert das n\u00e4chste Zeitstempel-Paar aus dem RAM in die EMIOS-Register (<code>CADR</code>, <code>CBDR</code>). Dies erzeugt eine komplexe, vordefinierte Wellenform komplett ohne CPU-Last.</li> </ol> </li> </ul>"},{"location":"Prozessrechentechnik/SummaryExercises/#10-regelungstechnik-control-systems","title":"10. Regelungstechnik (Control Systems)","text":"<p>Der letzte Abschnitt behandelt die Grundlagen der digitalen Regelung.</p> <ul> <li>Grundlagen:<ul> <li>Steuern (Open-loop): Ein Prozess ohne R\u00fcckkopplung.</li> <li>Regeln (Closed-loop): Ein Prozess mit R\u00fcckkopplung in einem geschlossenen Regelkreis. Der Kreis besteht aus den Schritten: Messen (des Istwerts), Vergleichen (mit dem Sollwert), Stellen (Anpassen der Stellgr\u00f6\u00dfe).</li> </ul> </li> <li>Begriffe:<ul> <li><code>w</code>: F\u00fchrungsgr\u00f6\u00dfe (Sollwert)</li> <li><code>x</code>: Regelgr\u00f6\u00dfe (Istwert)</li> <li><code>e</code>: Regelabweichung (\\(e = w - x\\))</li> <li><code>y</code>: Stellgr\u00f6\u00dfe (Ausgang des Reglers)</li> <li><code>z</code>: St\u00f6rgr\u00f6\u00dfe</li> <li>Regelstrecke: Der zu regelnde Prozess (z.B. Motor, Heizung).</li> </ul> </li> <li>Streckentypen: Das Verhalten einer Regelstrecke wird durch ihre Sprungantwort (Reaktion auf einen Eingangssprung) charakterisiert. G\u00e4ngige Typen sind:<ul> <li>P-Glied: Proportionale, sofortige Reaktion. \\(G(s) = K\\)</li> <li>I-Glied: Integrierend, Ausgang rampenf\u00f6rmig. \\(G(s) = K/s\\)</li> <li>\\(PT_1\\)-Glied: Verz\u00f6gerung 1. Ordnung (z.B. RC-Glied, DC-Motor). \\(G(s) = \\frac{K}{1+Ts}\\)</li> <li>\\(PT_2\\)-Glied: Verz\u00f6gerung 2. Ordnung (kann schwingen, z.B. Feder-Masse-System). \\(G(s) = \\frac{K}{1+\\frac{2D}{\\omega_0}s+\\frac{1}{\\omega_0^2}s^2}\\)</li> <li>\\(PT_t\\)-Glied: Totzeit (reine Laufzeitverz\u00f6gerung). \\(G(s) = e^{-T_t s}\\)</li> </ul> </li> <li> <p>Reglertypen:</p> <ul> <li>P-Regler: \\(y(t) = K_p \\cdot e(t)\\). Schnell, hat aber eine bleibende Regelabweichung.</li> <li>I-Regler: \\(y(t) = K_i \\int e(\\tau)d\\tau\\). Langsam, aber eliminiert die bleibende Regelabweichung.</li> <li>PI-Regler: \\(y(t) = K_p \\cdot e(t) + K_i \\int e(\\tau)d\\tau\\). Mittelschnell, keine bleibende Abweichung.</li> <li>PD-Regler: \\(y(t) = K_p \\cdot e(t) + K_d \\frac{de(t)}{dt}\\). Sehr schnell (D-Anteil \"prognostiziert\"), aber empfindlich gegen Rauschen und hat eine bleibende Abweichung.</li> <li>PID-Regler: Universell. Kombiniert die Vorteile aller Typen (schnell und genau).</li> </ul> \\[y(t) = K_p \\cdot e(t) + K_i \\int e(\\tau)d\\tau + K_d \\frac{de(t)}{dt}\\] </li> </ul> <ul> <li> <p>Digitale Realisierung (PID):</p> <ul> <li>Ein digitaler Regler ben\u00f6tigt einen ADU (ADC) zum Messen und einen DAU (z.B. PWM \u00fcber EMIOS) zum Stellen.</li> <li>Die Differentialgleichung des PID-Reglers wird in eine zeitdiskrete Differenzengleichung (Stellungs-Algorithmus) umgerechnet, die periodisch (mit Abtastzeit \\(T_a\\)) berechnet wird:</li> </ul> \\[y_k = K_p \\cdot e_k + K_i \\cdot T_a \\sum_{i=0}^{k} e_i + \\frac{K_d}{T_a} (e_k - e_{k-1})\\] <ul> <li>Achtung: Der I-Anteil (Summe) muss gegen \u00dcberlauf (Windup-Effekt) begrenzt werden.</li> <li>Regler-Dimensionierung (Tuning): 1.  Empirisches Einstellen: Manuelles \"Herantasten\" (z.B. erst \\(K_p\\) erh\u00f6hen bis es schwingt, dann \\(K_i\\) f\u00fcr Genauigkeit, dann \\(K_d\\) f\u00fcr Stabilit\u00e4t). 2.  Einstellregeln nach Ziegler/Nichols (Schwingungsmethode): \\(K_i\\) und \\(K_d\\) auf 0 setzen. \\(K_p\\) so lange erh\u00f6hen, bis die Strecke dauerhaft schwingt (Stabilit\u00e4tsgrenze). Aus diesem \\(K_{pkrit}\\) und der Schwingungsperiode \\(T_{krit}\\) werden die PID-Parameter \u00fcber eine Tabelle berechnet. 3.  Einstellregeln nach Ziegler/Nichols (Sprungantwort): Den Regelkreis \u00f6ffnen und eine S-f\u00f6rmige Sprungantwort aufnehmen. Aus der Wendetangente die Verzugszeit \\(T_u\\) (Verz\u00f6gerung) und die Ausgleichszeit \\(T_g\\) (Anstieg) sowie die Streckenverst\u00e4rkung \\(K_s\\) ermitteln und die Parameter \u00fcber eine Tabelle berechnen.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/","title":"1. Praktikum","text":""},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#1-architektur-aufbau-die-blueprints","title":"1. Architektur &amp; Aufbau (Die \"Blueprints\")","text":"<p>Das System ist eine klassische Client-Server-Anwendung auf Basis von RMI (Remote Method Invocation).</p> <ul> <li>Der Server: Ist die <code>Bank</code>. Sie \"bietet\" Dienste an (wie<code>einzahlen</code>).</li> <li>Die Clients: Sind <code>Kunde</code> und <code>Finanzamt</code>. Sie \"nutzen\"diese Dienste.</li> <li>Die RMI-Registry: Ist das \"Telefonbuch\". Der Server (dieBank) tr\u00e4gt sich hier unter einem Namen ein (z.B.\"Sparkasse\"), und die Clients suchen nach diesem Namen, um dieBank zu finden.</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#server-seite","title":"Server-Seite","text":"<ul> <li><code>BankServer.java</code>: Die Start-Klasse (mit <code>main</code>). Siet der \"Portier\".<ul> <li>Startet die RMI-Registry (das Telefonbuch) auf Port 1099.</li> <li>Erstellt eine Instanz von <code>Bank</code> (z.B. <code>new Bank()</code>).</li> <li>Registriert diese Instanz unter einem Namen (z.B. \"Sparkasse\") mit <code>Naming.rebind()</code>.</li> </ul> </li> <li><code>Bank.java</code>: Das Herzst\u00fcck der Anwendung.<ul> <li><code>extends UnicastRemoteObject</code>: Macht sie zu einem RMI-f\u00e4higen Server-Objekt.</li> <li><code>implements KundenInterface, FinanzamtInterface</code>: Sie verspricht, alle Methoden aus beiden Vertr\u00e4gen zu implementieren.</li> <li>Enth\u00e4lt die Gesch\u00e4ftslogik (Passw\u00f6rter pr\u00fcfen, Saldo berechnen).</li> <li>Enth\u00e4lt die Datenhaltung (z.B. eine <code>Map&lt;Integer, Konto&gt;</code>, die Kontonummern auf Konto-Objekte abbildet).</li> <li><code>Konto</code> (als innere Klasse in <code>Bank</code>): Ein einfacher Datencontainer (POJO), der Name, Passwort und Kontostand h\u00e4lt. Wichtig: Dieses Objekt verl\u00e4sst nie den Server.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#client-seite","title":"Client-Seite","text":"<ul> <li><code>BankClient.java</code>: Die Kunden-Anwendung (mit <code>main</code>).<ul> <li>Fragt den Benutzer, mit welcher Bank er sich verbinden will (z.B. \"Sparkasse\").</li> <li>Sucht die Bank mit <code>Naming.lookup(\"rmi://localhost/Sparkasse\")</code>.</li> <li>WICHTIG: Castet das Ergebnis auf das <code>KundenInterface</code>. Dadurch kann dieser Client die Finanzamt-Methoden gar nicht sehen oder aufrufen.</li> <li>Startet die interaktive Schleife (\"Was m\u00f6chten Sie tun?\").</li> </ul> </li> <li><code>FinanzamtClient.java</code>: Die Finanzamt-Anwendung (mit<code>main</code>).<ul> <li>Sucht die gleiche Bank (z.B. \"Sparkasse\") mit <code>Naming.lookup()</code>.</li> <li>WICHTIG: Castet das Ergebnis auf das <code>FinanzamtInterface</code>.</li> <li>Startet seine eigene interaktive Schleife.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#geteilte-komponenten-der-vertrag","title":"Geteilte Komponenten (Der \"Vertrag\")","text":"<p>Das sind die <code>.java</code>-Dateien, die sowohl Server als auch Client kennen m\u00fcssen. Sie sind die gemeinsame Sprache.</p> <ul> <li><code>KundenInterface.java</code>:<ul> <li><code>extends java.rmi.Remote</code></li> <li>Definiert Methoden wie <code>abheben(...)</code>, <code>einzahlen(...)</code>.</li> <li>Alle Methoden werfen <code>java.rmi.RemoteException</code>.</li> </ul> </li> <li><code>FinanzamtInterface.java</code>:<ul> <li><code>extends java.rmi.Remote</code></li> <li>Definiert Methoden wie <code>getSummeKontostaende(...)</code>.</li> <li>Alle Methoden werfen <code>java.rmi.RemoteException</code>.</li> </ul> </li> <li><code>Kontostand.java</code>:<ul> <li><code>implements java.io.Serializable</code></li> <li>Ein DTO (Data Transfer Object), um Kontonummer und Saldo vom Server zum Client zu schicken.</li> </ul> </li> <li><code>KontoZugriffsException.java</code> &amp; <code>KontoNichtGedecktExceptionjava</code>:<ul> <li><code>extends Exception</code> (und ist damit automatisch <code>Serializable</code>).</li> <li>Eigene Fehler-Objekte, die vom Server zum Client geschickt (geworfen) werden k\u00f6nnen.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#2-konzeptuelle-sachen-need-to-knows","title":"2. Konzeptuelle Sachen &amp; Need-to-Knows","text":"<ul> <li>Interface vs. Implementierung: Das ist das Kernkonzept. Der Client programmiert nur gegen das Interface (den \"Vertrag\"). Er wei\u00df nicht (und es ist ihm egal), wie die Bank intern die Konten speichert (ob in einer <code>Map</code>, einer <code>List</code> oder einer Datenbank).</li> </ul> <ul> <li>RMI (Remote Method Invocation): Erm\u00f6glicht es dem Client, <code>bank.abheben(...)</code> aufzurufen, als ob das <code>bank</code>-Objekt bei ihm lokal im Speicher l\u00e4ge. In Wirklichkeit wird der Aufruf \u00fcber das Netzwerk an den Server geschickt, dort ausgef\u00fchrt, und das Ergebnis (oder die Exception) kommt zur\u00fcck.</li> </ul> <ul> <li>Stub &amp; Skeleton: Der Client erh\u00e4lt beim <code>lookup()</code> nicht das echte <code>Bank</code>-Objekt, sondern einen Stub (einen Stellvertreter). Dieser Stub wei\u00df, wie man die Daten verpackt und an den Server (das Skeleton) schickt.</li> </ul> <ul> <li>Serialisierung: Damit Objekte wie <code>Kontostand</code> oder <code>KontoZugriffsException</code> \u00fcber das Netzwerk reisen k\u00f6nnen, m\u00fcssen sie \"serialisiert\" (in einen Bytestrom umgewandelt) werden. Das passiert automatisch, wenn die Klasse <code>implements Serializable</code> implementiert.</li> </ul> <ul> <li>Security durch Interfaces: Der st\u00e4rkste Teil des Designs. Obwohl die <code>Bank</code>-Klasse beide Interfaces implementiert, kann der <code>BankClient</code> (der nur das <code>KundenInterface</code> kennt) unm\u00f6glich die <code>FinanzamtInterface</code>-Methoden aufrufen.</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#3-implementierungs-highlights","title":"3. Implementierungs-Highlights","text":"<ul> <li>Datenhaltung: Eine <code>Map&lt;Integer, Konto&gt;</code> (oder besser <code>ConcurrentHashMap</code> f\u00fcr Thread-Sicherheit) in der <code>Bank</code>-Klasse ist ideal, weil die Kontonummer der perfekte, eindeutige Schl\u00fcssel ist.</li> </ul> <ul> <li>Fehlerbehandlung: Statt nur <code>true</code>/<code>false</code> oder Fehlercodes zur\u00fcckzugeben, werfen wir spezifische, eigene Exceptions. Der <code>BankClient</code> kann diese in einem <code>try-catch</code>-Block fangen und dem Benutzer eine saubere Fehlermeldung (\"Passwort falsch!\", \"Konto nicht gedeckt!\") anzeigen.</li> </ul> <ul> <li>Mehrere Banken: Der Trick war, den <code>BankServer</code> so umzubauen, dass er den Banknamen als Kommandozeilen-Argument (<code>String[] args</code>) entgegennimmt.</li> </ul> <ul> <li>Registry-Start: Der verbesserte <code>BankServer</code> versucht, die Registry zu starten (<code>LocateRegistry.createRegistry(1099)</code>). Wenn das fehlschl\u00e4gt (weil sie schon l\u00e4uft), f\u00e4ngt er die <code>ExportException</code> ab und macht einfach weiter. So kann der erste Server die Registry starten und alle weiteren (z.B. \"Postbank\") h\u00e4ngen sich einfach dran.</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#4-readme-so-wirds-ausgefuhrt","title":"4. \"README\" \u2013 So wird's ausgef\u00fchrt","text":"<p>So testest du das System mit zwei Banken, einem Kunden und dem Finanzamt.</p> <p>Voraussetzung: Alle <code>.java</code>-Dateien sind kompiliert (z.B. liegen als <code>.class</code>-Dateien im selben Ordner-Layout).</p> <p>WICHTIG: Alle Befehle m\u00fcssen aus dem Stammverzeichnis ausgef\u00fchrt werden (dem Ordner \u00fcber deinem <code>Praktikum</code>-Ordner).</p>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#schritt-1-terminal-1-sparkasse-starten","title":"Schritt 1: Terminal 1 - \"Sparkasse\" starten","text":"<pre><code># Gehe ins Stammverzeichnis (z.B. /.../Verteilte Systeme/)\ncd /pfad/zum/stammverzeichnis/\n\n# Starte den Server und gib ihm den Namen \"Sparkasse\"\njava Praktikum.Praktikum_1.Banken.BankServer Sparkasse\n</code></pre> <p>Ausgabe: <code>RMI Registry auf Port 1099 gestartet.</code> <code>Sparkasse-Server ist bereit.</code></p>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#schritt-2-terminal-2-postbank-starten","title":"Schritt 2: Terminal 2 - \"Postbank\" starten","text":"<p>Lass Terminal 1 offen!</p> <pre><code># Gehe ins selbe Stammverzeichnis\ncd /pfad/zum/stammverzeichnis/\n\n# Starte einen zweiten Server unter dem Namen \"Postbank\"\njava Praktikum.Praktikum_1.Banken.BankServer Postbank\n</code></pre> <p>Ausgabe: <code>RMI Registry l\u00e4uft bereits auf Port 1099.</code> <code>Postbank-Server ist bereit.</code></p>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#schritt-3-terminal-3-kunden-client-starten","title":"Schritt 3: Terminal 3 - Kunden-Client starten","text":"<p>Lass Terminal 1 &amp; 2 offen!</p> <pre><code># Gehe ins selbe Stammverzeichnis\ncd /pfad/zum/stammverzeichnis/\n\n# Starte den Kunden-Client\njava Praktikum.Praktikum_1.Banken.BankClient\n</code></pre> <p>Ausgabe: <code>Mit welcher Bank verbinden (z.B. Sparkasse, Postbank)?</code> <code>Sparkasse</code> <code>Erfolgreich mit Bank 'Sparkasse' verbunden.</code> <code>--- Kunden-Terminal ---</code> <code>Was m\u00f6chten Sie tun?</code> <code>...</code></p> <p>Jetzt kannst du Konten bei der \"Sparkasse\" anlegen, Geld einzahlen usw. Wenn du den Client neu startest und \"Postbank\" eingibst, bist du mit der anderen Bank verbunden.</p>"},{"location":"Verteilte%20Systeme/Praktikum/1.%20Praktikum/#schritt-4-terminal-4-finanzamt-client-starten","title":"Schritt 4: Terminal 4 - Finanzamt-Client starten","text":"<p>Lass alle Terminals offen!</p> <pre><code># Gehe ins selbe Stammverzeichnis\ncd /pfad/zum/stammverzeichnis/\n\n# Starte den Finanzamt-Client\njava Praktikum.Praktikum_1.Banken.FinanzamtClient\n</code></pre> <p>Ausgabe: <code>Mit welcher Bank verbinden (z.B. Sparkasse, Postbank)?</code> <code>Sparkasse</code> <code>Erfolgreich mit Bank 'Sparkasse' verbunden.</code> <code>--- Finanzamt-Terminal ---</code> <code>...</code></p> <p>Jetzt kann das Finanzamt die Summe aller Konten von \"Anna\" bei der \"Sparkasse\" abfragen.</p>"},{"location":"Verteilte%20Systeme/Praktikum/2.%20Praktikum/","title":"2. Praktikum","text":""},{"location":"Verteilte%20Systeme/Praktikum/2.%20Praktikum/#takeaway-zusammenfassung-rpc-worterbuch","title":"Takeaway-Zusammenfassung: RPC-W\u00f6rterbuch","text":"<p>Dieses Projekt implementiert ein Remote-W\u00f6rterbuch mithilfe von RPC (Remote Procedure Call). Das System besteht aus einem Server (<code>rdictd</code>), der die Daten h\u00e4lt, und einem Client (<code>rdict</code>), der Funktionen auf dem Server aufruft, als w\u00e4ren sie lokal.</p>"},{"location":"Verteilte%20Systeme/Praktikum/2.%20Praktikum/#1-architektur-build-prozess","title":"1. Architektur &amp; Build-Prozess","text":"<p>Die gesamte Architektur wird durch <code>rpcgen</code> aus einer einzigen Definitionsdatei generiert.</p> <ol> <li> <p>Definitionsdatei (<code>rdict.x</code>):</p> <ul> <li>Dies ist die \"Schnittstellendefinitionsdatei\" (Interface Definition Language, IDL).</li> <li>Sie legt alle Datenstrukturen (<code>struct upd</code>, <code>manywords</code>) und die Signaturen der Remote-Funktionen (<code>INITW</code>, <code>INSERTW</code>, etc.) fest.</li> </ul> </li> <li> <p>Code-Generierung (<code>rpcgen</code>):</p> <ul> <li>Das Tool <code>rpcgen</code> liest die <code>rdict.x</code>-Dateiv.</li> <li>Es generiert automatisch die \"Stub\"-Dateien (Client- und Server-Stubs), die den gesamten Netzwerk-Code enthalten.</li> <li>Wichtige generierte Dateien:<ul> <li><code>rdict.h</code>: Header-Datei mit allen Definitionen.</li> <li><code>rdict_clnt.c</code>: Der Client-Stub. Er wandelt lokale Aufrufe in Netzwerk-Calls um.</li> <li><code>rdict_svc.c</code>: Der Server-Stub. Enth\u00e4lt die <code>main()</code>-Funktion des Servers, einen \"Dispatcher\" (der Aufrufe verteilt) und den Code zur Registrierung beim Portmapper.</li> <li><code>rdict_xdr.c</code>: Code f\u00fcr die XDR-Konvertierung (eXternal Data Representation), der sicherstellt, dass Daten zwischen verschiedenen Systemen korrekt serialisiert werden.</li> </ul> </li> </ul> </li> <li> <p>Benutzerdefinierter Code (Logik):</p> <ul> <li>Dies ist der Code, den Sie schreiben. Er wird \"zwischen\" die Stubs eingef\u00fcgt:</li> <li>Server-Logik (<code>rdict_srp.c</code>): Enth\u00e4lt die tats\u00e4chliche Implementierung der Funktionen (z.B. <code>insertw</code>, <code>countw</code>). Die Daten werden hier in einem globalen Array (<code>char dict[][]</code>) und einem Z\u00e4hler (<code>int nwords</code>) gespeichert.</li> <li>Client-UI (<code>rdict.c</code>): Das <code>main()</code>-Programm des Clients, das Benutzereingaben entgegennimmt und die (scheinbar lokalen) Funktionen aufruft.</li> <li>Interface-Dateien (<code>_cif.c</code>, <code>_sif.c</code>): Diese \"Klebedateien\" verbinden die benutzerfreundlichen Funktionsnamen (z.B. <code>insertw</code>) mit den RPC-konformen Stub-Funktionsnamen (z.B. <code>insertw_1_svc</code>).</li> </ul> </li> <li> <p>Kompilierung:</p> <ul> <li>Alle <code>.c</code>-Dateien (generierte und benutzerdefinierte) werden zu <code>.o</code>-Objektdateien kompiliert.</li> <li>Der Linker f\u00fcgt sie zu zwei finalen Programmen zusammen:<ul> <li><code>rdict</code> (Der Client)</li> <li><code>rdictd</code> (Der Server-Daemon)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Verteilte%20Systeme/Praktikum/2.%20Praktikum/#2-kommunikations-fluss","title":"2. Kommunikations-Fluss","text":"<p>Die Client-Server-Kommunikation wird durch den Portmapper (auch <code>rpcbind</code> genannt) verwaltet.</p> <ol> <li> <p>Server-Start:</p> <ul> <li><code>./rdictd</code> wird gestartet.</li> <li>Die <code>main()</code>-Funktion (in <code>rdict_svc.c</code>) registriert das Programm (<code>RDICTPROG</code>) beim Portmapper des Betriebssystems und teilt ihm mit, an welchem Port es lauscht.</li> </ul> </li> <li> <p>Client-Start &amp; Aufruf:</p> <ul> <li><code>./rdict</code> wird gestartet.</li> <li>Der Client kontaktiert zuerst den Portmapper auf dem Server-Host (<code>RMACHINE</code>).</li> <li>Er fragt den Portmapper: \"An welchem Port lauscht Programm <code>RDICTPROG</code> (Version <code>RDICTVERS</code>)?\".</li> <li>Der Portmapper antwortet mit der Portnummer.</li> </ul> </li> <li> <p>RPC-Aufruf (Beispiel <code>countw()</code>):</p> <ul> <li>Client: Der Benutzer gibt <code>n</code> ein.<ol> <li><code>rdict.c</code> (<code>main</code>) ruft <code>countw()</code> auf.</li> <li><code>rdict_cif.c</code> (Stub) ruft <code>countw_1(0, handle)</code> auf.</li> <li><code>rdict_clnt.c</code> (generiert) f\u00fchrt den RPC-Netzwerkaufruf <code>clnt_call()</code> zum Server-Port durch.</li> </ol> </li> <li>Server:<ol> <li><code>rdict_svc.c</code> (generiert) empf\u00e4ngt den Aufruf. Der Dispatcher (<code>switch</code>-Statement) sieht, dass Prozedur <code>6</code> (<code>COUNTW</code>) aufgerufen wurde.</li> <li>Er ruft die Wrapper-Funktion <code>countw_1_svc()</code> in <code>rdict_sif.c</code> auf.</li> <li>Diese ruft schlie\u00dflich Ihre Logik-Funktion <code>countw()</code> in <code>rdict_srp.c</code> auf.</li> <li><code>rdict_srp.c</code> gibt <code>nwords</code> zur\u00fcck.</li> </ol> </li> <li>R\u00fcckweg: Der R\u00fcckgabewert (<code>int nwords</code>) wird den gesamten Weg \u00fcber XDR zur\u00fcck zum Client serialisiert, wo er in <code>rdict.c</code> von <code>printf</code> ausgegeben wird.</li> </ul> </li> </ol>"},{"location":"Verteilte%20Systeme/Praktikum/2.%20Praktikum/#3-fragen-aus-der-pdf","title":"3. Fragen aus der PDF","text":"<p>Frage: \"Was bedeutet die Zahl am Ende der Programmdefinition?\"</p> <p>Antwort: Die Zahl <code>0x30090949</code> ist die eindeutige Programm-Nummer des <code>RDICTPROG</code>.</p> <ul> <li>Sie dient als universelle ID f\u00fcr diesen Dienst.</li> <li>Der Server (<code>rdictd</code>) registriert sich mit dieser Nummer beim Portmapper.</li> <li>Der Client (<code>rdict</code>) findet den Server, indem er den Portmapper nach genau dieser Nummer fragt.</li> <li>Der <code>0x3...</code>-Nummernkreis ist f\u00fcr benutzerdefinierte, nicht-offiziell registrierte Programme vorgesehen.</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/3.%20Praktikum/","title":"3. Praktikum","text":""},{"location":"Verteilte%20Systeme/Praktikum/3.%20Praktikum/#zusammenfassung-takeaways-praktikum-3-thrift","title":"Zusammenfassung &amp; Takeaways: Praktikum 3 (Thrift)","text":"<p>Dieses Praktikum diente als Einf\u00fchrung in sprachunabh\u00e4ngige Remote-Services mithilfe einer Interface Description Language (IDL).</p>"},{"location":"Verteilte%20Systeme/Praktikum/3.%20Praktikum/#kern-learnings","title":"Kern-Learnings","text":"<ul> <li>Zweck von IDLs: Der Hauptzweck ist die \u00dcberwindung von sprachabh\u00e4ngigen RPC-Formen. Mit einer IDL wie Thrift definieren Sie einen Service einmal und k\u00f6nnen ihn sprachunabh\u00e4ngig nutzen.</li> <li>Der Thrift-Workflow: Der Prozess besteht im Wesentlichen aus drei Schritten: <ol> <li>Definieren: Sie erstellen eine <code>.thrift</code>-Datei (z. B. <code>SteganoService.thrift</code>), die alle Datenstrukturen (<code>structs</code>) und Service-Funktionen (<code>service</code>) beschreibt.</li> <li>Generieren: Sie verwenden den Thrift-Compiler, um aus dieser einen Datei \"Stubs\" (Code-Ger\u00fcste) f\u00fcr verschiedene Zielsprachen (z. B. Java, Python) zu generieren.</li> <li>Implementieren: Sie verwenden die generierten Stubs, um die eigentliche Serverlogik (was die Funktionen tun sollen) und die Client-Aufrufe in den jeweiligen Sprachen zu implementieren.</li> </ol> </li> <li>Datentypen: Thrift stellt eine Reihe von Basis-Typen (wie <code>i32</code>, <code>string</code>) und auch komplexe Typen wie <code>binary</code> (f\u00fcr Rohdaten wie Bilder oder Audio) zur Verf\u00fcgung.</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/3.%20Praktikum/#wichtige-anmerkungen-punkte-aus-der-pdf","title":"Wichtige Anmerkungen &amp; Punkte aus der PDF","text":"<p>Dies sind die wichtigsten Punkte, die im Dokument explizit hervorgehoben oder angemerkt wurden:</p> <ul> <li>Visuelle \u00dcberpr\u00fcfung (Graphviz): Thrift ist nicht nur ein Code-Generator. Sie k\u00f6nnen damit auch eine <code>.gv</code> (Graphviz) Datei erstellen (<code>--gen gv</code>). Diese kann mit dem <code>dot</code>-Tool in ein PDF umgewandelt werden, um die definierte Service-Struktur visuell zu \u00fcberpr\u00fcfen. Dies ist ein n\u00fctzlicher Schritt zur Verifizierung.</li> <li>Der \"n\u00e4chste Schritt\" (Java-Hinweis): F\u00fcr diejenigen, die weitermachen m\u00f6chten, gibt die PDF einen klaren Hinweis: Die Implementierung eines Java-Servers erfordert \"lediglich\" (ein Wort, das hier oft den Kern der Arbeit beschreibt) die Erstellung einer Implementierung des generierten <code>SteganoService.IFace</code>. Das ist der Punkt, an dem die generierten Stubs mit echtem Code gef\u00fcllt werden.</li> <li>Die eigentliche Herausforderung (Die \"Schwierigkeiten\"): Die PDF stellt explizit die Frage: \"Wo liegen die Schwierigkeiten?\". <ul> <li>Das Learning hier ist, dass das Schreiben der <code>.thrift</code>-Datei (die Definition) der einfache Teil ist.</li> <li>Die wahre Schwierigkeit liegt im Verstehen des generierten Quellcodes. Dieser Code ist oft komplex, da er die gesamte Serialisierung, Deserialisierung und die Transportlogik (das \"RPC-Protokoll\") kapselt, um die Daten zwischen Client und Server \u00fcber das Netzwerk zu senden \u2013 alles, was Thrift Ihnen abnimmt.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/","title":"4. Praktikum","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#projektziel","title":"Projektziel","text":"<p>Entwicklung eines verteilten Systems ohne Frameworks/IDL f\u00fcr eine Produktionshalle mit mehreren Anlagen (Clients) und Leitrechnern (Servern).</p>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#systemarchitektur","title":"Systemarchitektur","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#drei-komponenten-modell","title":"Drei-Komponenten-Modell","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     ServerManager (Port 5000)               \u2502\n\u2502              Zentrale Registrierungsstelle                  \u2502\n\u2502    \u2022 Speichert Server-Namen \u2192 IP:Port Mappings              \u2502\n\u2502    \u2022 Erm\u00f6glicht Service Discovery                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502                            \u2502\n       1. Register                  2. Lookup \"Leitrechner 1\"\n               \u2502                            \u2502\n               \u2193                            \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 ProductionServer \u2502         \u2502     Client      \u2502\n    \u2502  (Leitrechner)   \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   (SPS/Anlage)  \u2502\n    \u2502   Port: 6000+    \u2502  3. Direct Communication  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#kommunikationsfluss","title":"Kommunikationsfluss","text":"<ol> <li>Server startet \u2192 Registriert sich beim ServerManager mit Name, IP, Port</li> <li>Client braucht Server \u2192 Fragt ServerManager nach Server-Name</li> <li>ServerManager antwortet \u2192 Gibt IP und Port des Servers zur\u00fcck</li> <li>Client verbindet direkt \u2192 Kommuniziert ab jetzt direkt mit Server</li> </ol>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#komponenten-im-detail","title":"Komponenten im Detail","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#1-servermanager-registryname-service","title":"1. ServerManager (Registry/Name Service)","text":"<p>Rolle: Telefonbuch f\u00fcr Server</p> <p>Funktionen:</p> <ul> <li>Funktion 1: Server suchen (Lookup by Name)</li> <li>Funktion 2: Server registrieren (Register)</li> <li>Funktion 3: Alle Server auflisten (List All)</li> </ul> <p>Warum wichtig?</p> <ul> <li>Clients m\u00fcssen keine festen IP-Adressen kennen</li> <li>Server k\u00f6nnen dynamisch hinzugef\u00fcgt werden</li> <li>Flexibilit\u00e4t: Server k\u00f6nnen auf anderen Ports/Maschinen laufen</li> <li>\u00c4hnlich wie DNS im Internet</li> </ul> <p>Implementierung:</p> <pre><code>HashMap&lt;String, ServerInfo&gt; servers;  // Name \u2192 ServerInfo Mapping\n</code></pre>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#2-productionserver-leitrechner","title":"2. ProductionServer (Leitrechner)","text":"<p>Rolle: Empf\u00e4ngt und verarbeitet Produktionsdaten</p> <p>Funktionen:</p> <ul> <li>Funktion 1: Daten visualisieren (Swing GUI)</li> <li>Funktion 2: Daten persistent speichern (Datei)</li> </ul> <p>Features:</p> <ul> <li>Multi-threaded (jeder Client = eigener Thread)</li> <li>Grafisches Echtzeit-Dashboard</li> <li>Activity Log f\u00fcr Nachverfolgbarkeit</li> <li>Automatische Registrierung beim Start</li> </ul> <p>Warum GUI?</p> <ul> <li>Echtzeit\u00fcberwachung in Produktionshallen</li> <li>Sofortige visuelle R\u00fcckmeldung</li> <li>Typisch f\u00fcr SCADA-Systeme</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#3-client-spsanlage","title":"3. Client (SPS/Anlage)","text":"<p>Rolle: Sendet Produktionsdaten (Sensoren, Maschinen)</p> <p>Ablauf:</p> <ol> <li>Fragt ServerManager nach Server</li> <li>Erh\u00e4lt IP:Port</li> <li>Verbindet direkt zum Server</li> <li>Sendet Daten (Nachricht + Prozesswert)</li> </ol> <p>Multi-Language Support:</p> <ul> <li>Java-Client</li> <li>Python-Client</li> <li>\u2192 Zeigt Sprachunabh\u00e4ngigkeit des Protokolls</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#netzwerkprotokoll","title":"Netzwerkprotokoll","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#warum-eigenes-protokoll","title":"Warum eigenes Protokoll?","text":"<p>Lernziel: Verstehen, wie Frameworks intern arbeiten</p> <ul> <li>Keine \"Magic\" von gRPC, REST, etc.</li> <li>Direktes Arbeiten mit Sockets und Bytes</li> <li>Volle Kontrolle \u00fcber Format</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#protokoll-design","title":"Protokoll-Design","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#serverinfo-format-servermanager-alle","title":"ServerInfo-Format (ServerManager \u2194 Alle)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 nameLength \u2502   name   \u2502  ipLength  \u2502    ip    \u2502  port  \u2502\n\u2502   4 Bytes  \u2502 variable \u2502  4 Bytes   \u2502 variable \u2502 4 Bytes\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Warum variable L\u00e4ngen?</p> <ul> <li>Namen k\u00f6nnen unterschiedlich lang sein</li> <li>Effizienter als feste Gr\u00f6\u00dfe (kein Platz-Verschwendung)</li> <li>Length-Prefix Pattern: Standard in vielen Protokollen</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#productiondata-format-client-server","title":"ProductionData-Format (Client \u2192 Server)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 function \u2502       message         \u2502  value  \u2502\n\u2502  1 Byte  \u2502      100 Bytes        \u2502 4 Bytes \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Design-Entscheidungen:</p> <ul> <li>Function Byte: Command Pattern - Server wei\u00df, was zu tun ist</li> <li>Fixed 100 Bytes: Einfaches Parsing, kein Length-Prefix n\u00f6tig</li> <li>32-Bit Integer: Standard f\u00fcr Prozessdaten (Temperatur, Druck, etc.)</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#byte-order-endianness","title":"Byte-Order (Endianness)","text":"<p>Problem: Intel (Little-Endian) vs. ARM/Network (Big-Endian)</p> <p>L\u00f6sung: Network Byte Order (Big-Endian)</p> <pre><code>ByteBuffer.putInt(value);  // Java: Always Big-Endian in network I/O\nstruct.pack('&gt;i', value)   # Python: '&gt;' = Big-Endian\n</code></pre>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#wichtige-konzepte","title":"Wichtige Konzepte","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#1-service-discovery-diensterkennung","title":"1. Service Discovery (Diensterkennung)","text":"<p>Problem: Wie finden Clients Server in verteilten Systemen?</p> <p>L\u00f6sungsans\u00e4tze:</p> <ul> <li>Feste IP-Adressen: Unflexibel, nicht skalierbar</li> <li>DNS: Nur f\u00fcr Internet-Domains</li> <li>Registry (unsere L\u00f6sung): Zentrale Registrierungsstelle</li> </ul> <p>Real-World Beispiele:</p> <ul> <li>Kubernetes: etcd (Service Registry)</li> <li>Microservices: Consul, Eureka</li> <li>Cloud: AWS Service Discovery</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#2-client-server-architektur","title":"2. Client-Server Architektur","text":"<p>Charakteristik:</p> <ul> <li>Server = Passiv, wartet auf Anfragen</li> <li>Client = Aktiv, initiiert Kommunikation</li> <li>Server kann mehrere Clients bedienen (Multi-Threading)</li> </ul> <p>Vorteile:</p> <ul> <li>Klare Rollentrennung</li> <li>Zentrale Datenverwaltung</li> <li>Einfache Wartung</li> </ul> <p>Nachteile:</p> <ul> <li>Single Point of Failure (Server f\u00e4llt aus \u2192 System tot)</li> <li>Skalierbarkeit begrenzt</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#3-multi-threading","title":"3. Multi-Threading","text":"<p>Warum?</p> <pre><code>new Thread(() -&gt; handleClient(socket)).start();\n</code></pre> <ul> <li>Ohne Threads: Server blockiert bei einem Client, andere warten</li> <li>Mit Threads: Jeder Client wird parallel bedient</li> <li>Alternative: Asynchrone I/O (NIO, async/await)</li> </ul> <p>Wichtig:</p> <ul> <li>Jeder Socket = eigene Verbindung</li> <li>Thread-Safety bei shared resources (HashMap)</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#4-serialisierung-marshalling","title":"4. Serialisierung (Marshalling)","text":"<p>Problem: Objekte \u00fcber Netzwerk senden</p> <p>Unsere L\u00f6sung: Manuelle Byte-Konvertierung</p> <pre><code>public byte[] toByteArray() {\n    ByteBuffer buffer = ByteBuffer.allocate(...);\n    buffer.putInt(nameBytes.length);\n    buffer.put(nameBytes);\n    return buffer.array();\n}\n</code></pre> <p>Alternativen:</p> <ul> <li>Java Serializable (sprachspezifisch)</li> <li>JSON (text, menschenlesbar, gr\u00f6\u00dfer)</li> <li>Protocol Buffers (effizient, braucht Schema)</li> <li>XML (veraltet, sehr gro\u00df)</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#5-protokoll-versionierung","title":"5. Protokoll-Versionierung","text":"<p>Unser System: Keine Versionierung</p> <p>In der Praxis wichtig:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 version \u2502 function \u2502  data   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Warum?</p> <ul> <li>Server/Client Updates ohne Downtime</li> <li>Backwards Compatibility</li> <li>Neue Features schrittweise einf\u00fchren</li> </ul>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#kommunikationsablauf-schritt-fur-schritt","title":"Kommunikationsablauf - Schritt f\u00fcr Schritt","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#szenario-client-sendet-daten-an-leitrechner-1","title":"Szenario: Client sendet Daten an \"Leitrechner 1\"","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#phase-1-server-registrierung","title":"Phase 1: Server-Registrierung","text":"<pre><code>ProductionServer                    ServerManager\n     |                                   |\n     |----(1) TCP Connect---------------&gt;|\n     |                                   |\n     |----(2) Function=2 (Register)-----&gt;|\n     |----(3) ServerInfo Bytes----------&gt;|\n     |                                   | [Speichert: \"Leitrechner 1\" \u2192 127.0.0.1:6000]\n     |&lt;---(4) Success=true---------------|\n     |                                   |\n     |----(5) TCP Close-----------------&gt;|\n</code></pre>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#phase-2-client-lookup","title":"Phase 2: Client-Lookup","text":"<pre><code>Client                              ServerManager\n  |                                       |\n  |----(1) TCP Connect-------------------&gt;|\n  |                                       |\n  |----(2) Function=1 (Lookup)-----------&gt;|\n  |----(3) \"Leitrechner 1\" Bytes---------&gt;|\n  |                                       | [Sucht in HashMap]\n  |&lt;---(4) ServerInfo Bytes---------------|\n  |       (IP=127.0.0.1, Port=6000)       |\n  |                                       |\n  |----(5) TCP Close---------------------&gt;|\n</code></pre>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#phase-3-direkte-kommunikation","title":"Phase 3: Direkte Kommunikation","text":"<pre><code>Client                           ProductionServer\n  |                                    |\n  |----(1) TCP Connect (Port 6000)----&gt;|\n  |                                    |\n  |----(2) Function=1 (Display)-------&gt;|\n  |----(3) Message (100 Bytes)--------&gt;|\n  |----(4) Value (4 Bytes)------------&gt;|\n  |                                    | [Zeigt Daten in GUI]\n  |                                    | [Speichert in Datei]\n  |                                    |\n  |----(5) TCP Close------------------&gt;|\n</code></pre>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#was-haben-wir-gelernt","title":"Was haben wir gelernt?","text":""},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#technisch","title":"Technisch","text":"<ol> <li> <p>Socket-Programmierung </p> <ul> <li>TCP vs. UDP</li> <li>ServerSocket vs. Socket</li> <li>Blocking I/O</li> </ul> </li> <li> <p>Bin\u00e4re Protokolle</p> <ul> <li>Byte-Manipulation</li> <li>Serialisierung/Deserialisierung</li> <li>Endianness-Probleme</li> </ul> </li> <li> <p>Verteilte Architektur</p> <ul> <li>Service Registry Pattern</li> <li>Client-Server Kommunikation</li> <li>Loose Coupling durch Indirektion</li> </ul> </li> <li> <p>Interoperabilit\u00e4t</p> <ul> <li>Sprachunabh\u00e4ngige Protokolle</li> <li>Java \u2194 Python Kommunikation</li> <li>Network Byte Order</li> </ul> </li> <li> <p>Multi-Threading</p> <ul> <li>Parallele Client-Verarbeitung</li> <li>Thread-Safety \u00dcberlegungen</li> </ul> </li> </ol>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#konzeptionell","title":"Konzeptionell","text":"<ol> <li> <p>Separation of Concerns</p> <ul> <li>Registry \u2260 Business Logic</li> <li>Jede Komponente hat klare Aufgabe</li> </ul> </li> <li> <p>Indirektion</p> <ul> <li>Clients kennen Server-Namen, nicht IPs</li> <li>Flexibilit\u00e4t durch zus\u00e4tzliche Schicht</li> </ul> </li> <li> <p>Request-Response Pattern</p> <ul> <li>Synchrone Kommunikation</li> <li>Client initiiert, Server antwortet</li> </ul> </li> <li> <p>Protocol Design</p> <ul> <li>Trade-offs: Effizienz vs. Lesbarkeit</li> <li>Fixed vs. Variable Length Fields</li> <li>Versioning und Erweiterbarkeit</li> </ul> </li> </ol>"},{"location":"Verteilte%20Systeme/Praktikum/4.%20Praktikum/#fazit","title":"Fazit","text":"<p>Was wir erreicht haben:</p> <p>\u2705 Funktionierendes verteiltes System ohne Frameworks \u2705 Verst\u00e4ndnis f\u00fcr Low-Level Netzwerkprogrammierung \u2705 Service Discovery Pattern implementiert \u2705 Sprachunabh\u00e4ngiges Protokoll (Java \u2194 Python) \u2705 Multi-Client-Server Architektur</p>"},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/","title":"1. Einf\u00fchrung","text":""},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/#1-definitionen-und-grundlagen","title":"1. Definitionen und Grundlagen","text":"<p>Verteilte Systeme (VS) sind durch den technologischen Fortschritt bei Mikroprozessoren und Netzwerken entstanden. Sie unterscheiden sich grundlegend von dezentralen und zentralisierten Systemen und k\u00f6nnen aus verschiedenen Perspektiven betrachtet werden.</p> <ul> <li>Dezentrales System: Prozesse und Ressourcen sind notwendigerweise \u00fcber mehrere Computer verteilt (z.B. Blockchain, Flugverkehrskontrollsystem).</li> <li>Verteiltes System: Prozesse und Ressourcen sind ausreichend \u00fcber mehrere Computer verteilt (z.B. Google Gmail, CDNs).</li> <li> <p>Zentralisiertes System: Hat zwei Hauptnachteile:</p> <ol> <li>Single point of failure (einzige Schwachstelle).</li> <li>Skalierbarkeitsprobleme.</li> </ol> </li> </ul> <ul> <li>Perspektiven auf VS: Man kann sie u.a. aus den Perspektiven Architektur, Verfahren, Kommunikation, Koordination, Benennung, Konsistenz, Fehlertoleranz und Sicherheit betrachten.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/#2-entwurfsziele-fur-verteilte-systeme","title":"2. Entwurfsziele f\u00fcr Verteilte Systeme","text":"<p>Beim Entwurf von Verteilten Systemen werden sechs Hauptziele verfolgt, die sich oft gegenseitig beeinflussen und Kompromisse erfordern.</p> <ol> <li>Ressourcenteilung<ul> <li>Was: Gemeinsame Nutzung von Ressourcen (z.B. Filesharing, Google Docs) aus \u00f6konomischen oder kooperativen Gr\u00fcnden.</li> </ul> </li> <li>Transparenz<ul> <li>Was: Das Verbergen der Tatsache, dass ein System verteilt ist, vor dem Nutzer und der Anwendung.</li> <li>Wie: Wird typischerweise durch eine Middleware-Schicht (Verteilte Systemschicht) erreicht.</li> <li>Typen: Umfasst Zugriffs-, Orts-, Migrations-, Relokations-, Replikations-, Nebenl\u00e4ufigkeits- und Fehlertransparenz.</li> <li>Grenzen: V\u00f6llige Transparenz ist unm\u00f6glich (z.B. Netzwerklatenzen).</li> </ul> </li> <li>Offenheit (Openness)<ul> <li>Was: Die F\u00e4higkeit, das System einfach zu erweitern und mit anderen Systemen zu kombinieren (Interoperabilit\u00e4t).</li> <li>Wie: Basiert auf standardisierten Interfaces, oft definiert durch eine IDL (Interface Definition Language).</li> <li>Technik: Trennung von Richtlinie (Policy) (was?) und Mechanismus (Mechanism) (wie?).</li> </ul> </li> <li>Verl\u00e4sslichkeit (Dependability)<ul> <li>Was: Das System verh\u00e4lt sich wie erwartet, auch bei Teilausf\u00e4llen (eine Komponente f\u00e4llt aus, das System als Ganzes l\u00e4uft weiter).</li> <li>Anforderungen:<ul> <li>Verf\u00fcgbarkeit (availability)</li> <li>Zuverl\u00e4ssigkeit (reliability)</li> <li>Sicherheit (Safety)</li> <li>Wartbarkeit (Maintainability)</li> </ul> </li> </ul> </li> <li>Sicherheit (Security)<ul> <li>Was: Schutz vor unautorisiertem Zugriff oder \u00c4nderungen.</li> <li>Aspekte:<ul> <li>Vertraulichkeit (confidentiality): Nur autorisierte Parteien haben Zugriff.</li> <li>Integrit\u00e4t (integrity): \u00c4nderungen sind nur in erlaubter Weise m\u00f6glich.</li> <li>Autorisierung &amp; Authentifizierung.</li> </ul> </li> <li>Technik: Kryptographie (symmetrisch und asymmetrisch) erm\u00f6glicht sichere Kommunikationskan\u00e4le.</li> </ul> </li> <li>Skalierbarkeit<ul> <li>Was: Die F\u00e4higkeit des Systems, in verschiedenen Dimensionen effizient zu wachsen.</li> <li>Dimensionen:<ul> <li>Gr\u00f6\u00dfe: Mehr Nutzer und Ressourcen.</li> <li>Geographie: Nutzer und Ressourcen sind weit verteilt.</li> <li>Administrativ: Verwaltbar \u00fcber mehrere Organisationen hinweg.</li> </ul> </li> </ul> </li> </ol>"},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/#3-skalierung-ansatze-und-techniken","title":"3. Skalierung: Ans\u00e4tze und Techniken","text":"<p>Um Skalierbarkeit zu erreichen, m\u00fcssen Flaschenh\u00e4lse (begrenzte Rechen-, Speicher- oder Netzwerkkapazit\u00e4t) \u00fcberwunden werden. Dies geschieht durch gezielte Ans\u00e4tze und Techniken.</p> <ul> <li>Skalierungs-Ans\u00e4tze (Wie wachsen?)<ul> <li>Scaling up (Vertikal): Erh\u00f6hung der Kapazit\u00e4t einer einzelnen Ressource (z.B. schnellere CPU, mehr RAM).</li> <li>Scaling out (Horizontal): Hinzuf\u00fcgen von mehr Ressourcen derselben Art (z.B. mehr Server).</li> </ul> </li> <li>Skalierungs-Techniken (Welche Methoden?)<ul> <li>Latenz verbergen: Einsatz von Asynchroner Kommunikation, da die Netzwerklatenz (physikalisch begrenzt durch \\(c\\)) nicht eliminiert werden kann.</li> <li>Partitionierung: Aufteilen einer Komponente oder Ressource in kleinere Teile und deren Verteilung (z.B. das DNS-System).</li> <li>Replikation: Erstellen von Kopien von Daten/Ressourcen.<ul> <li>Caching: Eine Form der Replikation, die vom Klienten eines Dienstes durchgef\u00fchrt wird.</li> <li>Problem: Konsistenz der Kopien.</li> </ul> </li> </ul> </li> <li>Dezentralisierte Algorithmen<ul> <li>Oft zur L\u00f6sung von Skalierungsproblemen eingesetzt.</li> <li>Merkmale:<ol> <li>Kein Computer hat vollst\u00e4ndige Systeminformationen.</li> <li>Entscheidungen basieren nur auf lokalen Informationen.</li> <li>Der Ausfall eines Computers sch\u00e4digt nicht den Algorithmus.</li> <li>Es gibt keine globale Uhr.</li> </ol> </li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/#4-klassen-von-verteilten-systemen","title":"4. Klassen von Verteilten Systemen","text":"<p>Verteilte Systeme lassen sich je nach Aufbau und Anwendungszweck in drei Hauptkategorien einteilen.</p> <ol> <li>Verteilte Computersysteme (Distributed Computing Systems)<ul> <li>Fokus: Bereitstellung von Rechenleistung.</li> <li>Typen: Cluster Computingsysteme (nutzen homogene Computer) und Grid Computingsysteme (nutzen heterogene Computer).</li> </ul> </li> <li>Verteilte Informationssysteme (Distributed Information Systems)<ul> <li>Fokus: Integration von Anwendungen und Daten.</li> <li>Typen: Transaktionsverarbeitungssysteme (nutzen Primitive wie <code>BEGIN_TRANSACTION</code>) und Enterprise Application Integration (EAI).</li> </ul> </li> <li>Pervasive Systeme<ul> <li>Was: Systeme aus kleinen, batteriebetriebenen, mobilen Ger\u00e4ten mit drahtlosen Verbindungen (z.B. Sensornetze).</li> <li>Merkmal: Sie sind Teil der Umgebung und erfordern keine menschliche Administration.</li> <li>Anforderung: M\u00fcssen sich automatisch an kontextuelle Ver\u00e4nderungen anpassen.</li> </ul> </li> </ol>"},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/#die-fragen","title":"Die Fragen","text":"<ol> <li>Wie unterscheidet sich ein dezentrales System von einem verteilten System gem\u00e4\u00df der Definition im Dokument?</li> <li>Nennen Sie die zwei prinzipiellen Probleme von zentralisierten Systemen.</li> <li>Listen Sie die sechs Entwurfsziele f\u00fcr Verteilte Systeme auf.</li> <li>Was ist der Unterschied zwischen Migrations-Transparenz und Relokations-Transparenz?</li> <li>Wodurch (durch welche Schicht) wird Transparenz in verteilten Systemen typischerweise erreicht?</li> <li>Was besagt das CAP-Theorem (kurz)?</li> <li>Was ist der Zweck einer Interface Definition Language (IDL) im Kontext der Offenheit?</li> <li>Nennen Sie die vier Anforderungen an die Verl\u00e4sslichkeit (Dependability).</li> <li>Welche zwei grunds\u00e4tzlichen Anwendungen von Public-Key Kryptosystemen werden genannt?</li> <li>Erkl\u00e4ren Sie den Unterschied zwischen \"Scaling up\" (vertikale Skalierung) und \"Scaling out\" (horizontale Skalierung).</li> <li>Nennen Sie die drei Skalierungstechniken, die im Dokument vorgestellt werden, um mit Latenzen und Kapazit\u00e4tsgrenzen umzugehen.</li> <li>Nennen Sie die drei Hauptklassen von Verteilten Systemen.</li> <li>Was ist ein charakteristisches Merkmal von Pervasiven Systemen?</li> <li>Welche vier Unterscheidungsmerkmale haben dezentralisierte Algorithmen im Vergleich zu zentralisierten?</li> </ol>"},{"location":"Verteilte%20Systeme/Vorlesung/1.%20Einf%C3%BChrung/#die-antworten","title":"Die Antworten","text":"<ol> <li>Ein dezentrales System ist eines, in dem Prozesse und Ressourcen notwendigerweise \u00fcber mehrere Computer verteilt sind. Ein verteiltes System ist eines, in dem sie ausreichend \u00fcber mehrere Computer verteilt sind.</li> <li>Die zwei prinzipiellen Probleme sind: Single point of failure (einzige Schwachstelle) und Skalierbarkeitsprobleme.</li> <li>Die sechs Entwurfsziele sind:<ol> <li>Ressourcenteilung</li> <li>Transparenz</li> <li>Erweiterbarkeit &amp; Wiederverwendbarkeit (\"openness\u201d)</li> <li>Verl\u00e4sslichkeit</li> <li>Sicherheit (Security)</li> <li>Skalierbarkeit</li> </ol> </li> <li>Migrations-Transparenz verbirgt, dass eine Ressource an einen anderen Ort verschoben werden kann. Relokations-Transparenz verbirgt, dass eine Ressource an einen anderen Ort verschoben werden kann, w\u00e4hrend sie genutzt wird.</li> <li>Transparenz wird durch eine Middleware Layer (Verteilte Systemschicht) erreicht.</li> <li>Das CAP-Theorem besagt, dass ein vernetztes System, das geteilte Daten bereitstellt, nur zwei der drei Eigenschaften haben kann: Consistency (Konsistenz), Availability (Verf\u00fcgbarkeit) und Partition tolerance (Partitionstoleranz).</li> <li>Eine IDL dient dazu, Schnittstellen anzubieten. Sie definiert die Syntax eines Dienstes (z.B. Name, Argumente &amp; Ergebnis), um Standardisierung und Interoperabilit\u00e4t zu f\u00f6rdern.</li> <li>Die vier Anforderungen sind:<ul> <li>Verf\u00fcgbarkeit (availability)</li> <li>Zuverl\u00e4ssigkeit (reliability)</li> <li>Sicherheit (Safety)</li> <li>Wartbarkeit (Maintainability)</li> </ul> </li> <li>Die zwei Anwendungen sind: Das Versenden von vertraulichen Nachrichten (sicherer Kanal) und die Digitale Signatur.</li> <li>Scaling up (vertikal) ist die Erh\u00f6hung der Kapazit\u00e4t der betroffenen Ressource (z.B. schnellere CPU, mehr Speicher). Scaling out (horizontal) ist das Hinzuf\u00fcgen von mehr Ressourcen derselben Art.</li> <li>Die drei Skalierungstechniken sind:<ul> <li>Verbergen von Netzwerklatenz (durch Asynchrone Kommunikation)</li> <li>Partitionierung und Verteilung</li> <li>Replikation (bzw. Caching)</li> </ul> </li> <li>Die drei Hauptklassen sind:<ol> <li>Verteilte Computersysteme (Distributed Computing Systems)</li> <li>Verteilte Informationssysteme (Distributed Information Systems)</li> <li>Pervasive Systeme</li> </ol> </li> <li>Ein Pervasives System besteht aus kleinen, batteriebetriebenen, mobilen Computerger\u00e4ten mit drahtlosen Verbindungen. Sie sind Teil unserer Umgebung und erfordern keine menschliche Administration.</li> <li>Die vier Merkmale sind:<ol> <li>Kein Computer hat vollst\u00e4ndige Informationen \u00fcber den Systemstatus.</li> <li>Computer entscheiden nur aufgrund von lokalen Informationen.</li> <li>Der Ausfall eines Computers sch\u00e4digt nicht den Algorithmus.</li> <li>Es wird nicht implizit angenommen, dass es eine globale Uhr gibt.</li> </ol> </li> </ol>"},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/","title":"2. Architekturen","text":""},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/#1-wichtige-architekturstile","title":"1. Wichtige Architekturstile","text":"<p>Architekturstile helfen, die Komplexit\u00e4t von Verteilten Systemen durch bew\u00e4hrte Muster beherrschbar zu machen. Die drei wichtigsten Stile sind:</p> <ul> <li>Geschichtete Architekturen</li> <li>Serviceorientierte Architekturen (SOAs)</li> <li>Publish-Subscribe Architekturen</li> </ul> <p>(Veraltete, objektbasierte Modelle wie CORBA sind heute nahezu bedeutungslos.)</p>"},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/#layer-2-geschichtete-architekturen","title":"LAYER 2. Geschichtete Architekturen","text":"<p>Bei diesem Stil werden Komponenten in Schichten (Layern) organisiert. Eine Schicht \\(N\\) bietet der Schicht \\(N+1\\) einen Dienst \u00fcber eine Schnittstelle an und nutzt selbst die Dienste der Schicht \\(N-1\\).</p> <ul> <li> <p>Varianten:</p> <ul> <li>Reine Schichtenarchitektur: Nur \"Downcalls\" zur n\u00e4chsttieferen Schicht.</li> <li>Architektur mit Upcalls: Erlaubt auch Aufrufe in die h\u00f6here Schicht.</li> <li>Gemischte Architektur: Schicht \\(N\\) darf auch Schichten \\(N-K\\) (mit \\(K &gt; 1\\)) direkt ansprechen.</li> </ul> </li> </ul> <ul> <li>Beispiel Kommunikationsprotokolle: Schicht \\(N\\) auf Maschine A kommuniziert logisch mit Schicht \\(N\\) auf Maschine B \u00fcber ein festgelegtes Protokoll. Physisch nutzt sie dazu die Dienste von Schicht \\(N-1\\).</li> <li> <p>Anwendungsebenen: Auf der Anwendungsebene wird oft eine 3-stufige Schichtung verwendet:</p> <ol> <li>Anwendungsschnittstellenebene (User-interface level)</li> <li>Verarbeitungsebene (Processing level)</li> <li>Datenebene (Data level)</li> </ol> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/#3-service-orientierte-architekturen-soas","title":"3. Service-Orientierte Architekturen (SOAs)","text":"<p>SOAs bestehen aus einer losen Organisation von unabh\u00e4ngigen Einheiten (Services, Objekte oder Microservices), die miteinander kommunizieren.</p> <ul> <li>Objektbasiert: Ein Ansatz, bei dem Objekte ihren Zustand kapseln und \u00fcber \u00f6ffentliche Methoden eine Schnittstelle anbieten.</li> <li>Entfernte Objekte: F\u00fcr die Kommunikation mit entfernten Objekten wird oft ein Proxy (auch client-side stub) auf der Client-Seite und ein Skeleton (auch server-side stub) auf der Server-Seite verwendet.<ul> <li>Der Client ruft eine Methode am lokalen Proxy auf.</li> <li>Der Proxy verpackt den Aufruf (\"marshalling\") und sendet ihn \u00fcber das Netzwerk.</li> <li>Das Skeleton empf\u00e4ngt die Nachricht, entpackt sie und ruft die eigentliche Methode am Objekt auf dem Server auf.</li> </ul> </li> <li>Microservice Architektur: Eine sehr popul\u00e4re Form der SOA, bei der jeder Dienst als separater Prozess l\u00e4uft und als Ganzes gekapselt ist. Dies f\u00f6rdert die Modularisierung und Innovation.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/#4-publish-subscribe-architekturen","title":"4. Publish-Subscribe Architekturen","text":"<p>Das definierende Merkmal dieses Stils ist die Trennung von Verarbeitung (Processing) und Koordination (Coordination) ohne direkte Referenzen. Komponenten kommunizieren nicht direkt, sondern \u00fcber ein zwischengeschaltetes System.</p> <ul> <li>Koordinierungsformen:<ul> <li>Referentiell gekoppelt: Direkte Kommunikation oder \u00fcber eine Mailbox (zeitlich entkoppelt).</li> <li>Referentiell entkoppelt: Kommunikation, ohne dass sich die Partner kennen. Dies ist die Basis f\u00fcr Pub-Sub.<ul> <li>Event-basiert: (z.B. \u00fcber einen Event-Bus)</li> <li>Gemeinsamer Datenraum (Shared Data Space)</li> </ul> </li> </ul> </li> <li>Stile:<ul> <li>Content-based: Abonnenten filtern Nachrichten basierend auf deren Inhalt.</li> <li>Topic-based: Abonnenten \"abonnieren\" ein bestimmtes Thema (Topic), und Publisher senden Nachrichten an dieses Topic.</li> </ul> </li> <li>Broker: Oft wird ein Broker (Vermittler) eingesetzt, der die Kommunikation (z.B. Message Routing) zwischen Publishern und Subscribern erleichtert.</li> <li>Popul\u00e4re Plattformen:<ul> <li>Apache Kafka: Verteilte Event-Streaming-Plattform, optimiert f\u00fcr hohen Durchsatz und Dauerhaftigkeit (Speicherung auf Festplatte).</li> <li>ZeroMQ (0MQ): Leichtgewichtige Bibliothek (kein zentraler Broker), optimiert f\u00fcr geringe Latenz und direkte Knoten-Kommunikation.</li> <li>MQTT: LeichtgewichtigeS Nachrichtenprotokoll (Topic-basiert mit Broker), optimiert f\u00fcr geringen Aufwand und Zuverl\u00e4ssigkeit (3 QoS-Stufen). Sehr popul\u00e4r im IoT-Bereich.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/#5-entwurfsmuster-fur-verteilte-systeme","title":"5. Entwurfsmuster f\u00fcr Verteilte Systeme","text":"<p>Neben den Architekturstilen gibt es bew\u00e4hrte Entwurfsmuster (Patterns) f\u00fcr den Aufbau von Verteilten Systemen.</p> <ul> <li>Middleware<ul> <li>Analogie: Middleware verh\u00e4lt sich zum Verteilten System wie ein Betriebssystem zur Hardware.</li> <li>Zweck: Sie bildet eine Abstraktionsschicht \u00fcber den lokalen Betriebssystemen und dem Netzwerk.</li> <li>Funktionen: Bietet eine gleiche Schnittstelle f\u00fcr alle Anwendungen, Mechanismen zur Kommunikation, Sicherheit, Fehler-Maskierung und Buchf\u00fchrung.</li> <li>Vorteile: Sorgt f\u00fcr Portabilit\u00e4t (\u00fcber HW/SW-Grenzen) und Interoperabilit\u00e4t (zwischen Plattformen).</li> <li>Mechanismen: Nutzt oft das Adapter- oder Interceptor-Pattern.</li> </ul> </li> <li>Geschichtete Architekturen (Client-Server)<ul> <li>Server: Bietet Dienste im Zusammenhang mit einer geteilten Ressource an (z.B. Datenbank, Dateisystem, Web-Dokumente).</li> <li>Client: Greift auf die Server-Dienste zu, z.B. \u00fcber eine Programmierschnittstelle oder eine Benutzeroberfl\u00e4che.</li> <li>Mehrstufige (Multi-Tier) Architekturen: Die logischen Schichten (UI, Processing, Data) werden auf verschiedene physische Maschinen (Client und Server) verteilt.<ul> <li>Beispiel (d): Bankanwendung, UI auf Client, Application + Database auf Server.</li> <li>Beispiel (e): Typische Browser-Anwendung, UI + Application auf Client (Browser), Database auf Server, plus evtl. lokaler Cache (Database) auf Client.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/2.%20Architekturen/#6-symmetrische-verteilte-architekturen","title":"6. Symmetrische Verteilte Architekturen","text":"<p>Im Gegensatz zu Client-Server-Systemen (vertikale Verteilung) basieren symmetrische Architekturen auf einer horizontalen Verteilung.</p> <ul> <li>Horizontale Verteilung: Logisch \u00e4quivalente Teile des Systems sind \u00fcber Rechner verteilt. Jeder Teil arbeitet auf einem Teil der gesamten Datenmenge, was zu einer nat\u00fcrlichen Lastverteilung f\u00fchrt.</li> <li>Peer-to-Peer (P2P) Systeme<ul> <li>Definition: Eine besondere Klasse symmetrischer Systeme, bei der die Interaktion symmetrisch ist. Es gibt keine festen Clients oder Server; jeder Rechner ist beides.</li> <li>Kategorien:<ol> <li>Strukturiert: Basiert auf einem Overlay-Netzwerk mit einer bestimmten Topologie (z.B. Ring, Baum).</li> <li>Unstrukturiert: Kein vordefiniertes Overlay-Netzwerk.</li> </ol> </li> </ul> </li> <li>Beispiel: Chord<ul> <li>Ein strukturiertes P2P-System mit einer Ring-Topologie.</li> <li>Implementiert eine verteilte Hashtabelle (DHT).</li> <li>Ein Datenelement mit Schl\u00fcssel \\(k\\) wird dem Knoten \\(succ(k)\\) zugeordnet (der Knoten mit der kleinsten ID, die \\(\\ge k\\) ist).</li> </ul> </li> <li>Beispiel: Facebook's Cassandra<ul> <li>Ein strukturiertes Peer-to-Peer Storage System.</li> <li>Bietet extrem hohe Schreibraten und konfigurierbare Konsistenzlevel.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/3.%20Technologische%20Grundlagen/","title":"3. Technologische Grundlagen","text":""},{"location":"Verteilte%20Systeme/Vorlesung/3.%20Technologische%20Grundlagen/#1-threads","title":"1. Threads","text":"<p>Threads sind \"minimale Software-Prozessoren\", die es erm\u00f6glichen, virtuelle Prozessoren in Software zu erstellen. Ein Prozess ist dabei der Kontext (der Software-Prozessor), in dem ein oder mehrere Threads ausgef\u00fchrt werden.</p> <ul> <li>Implementierungsans\u00e4tze:<ul> <li>Benutzerebene (User-level): Die Thread-Verwaltung findet komplett im Userspace statt.<ul> <li>Vorteil: Extrem effizient, da kein Kernel-Trap f\u00fcr Thread-Operationen n\u00f6tig ist.</li> <li>Nachteil: Wenn ein Thread einen blockierenden Systemaufruf (z.B. I/O) t\u00e4tigt, blockiert der Kernel den gesamten Prozess, und damit alle anderen Threads in diesem Prozess.</li> </ul> </li> <li>Kernel-Ebene (Kernel-level): Der Kernel verwaltet die Threads. Jede Thread-Operation ist ein Systemaufruf.<ul> <li>Vorteil: Blockierende Aufrufe sind kein Problem; der Kernel kann einfach einen anderen Thread desselben Prozesses einplanen (schedulen).</li> <li>Nachteil: Geringere Effizienz, da jede Operation einen Trap in den Kernel erfordert.</li> </ul> </li> </ul> </li> <li>Lightweight Process (LWP):<ul> <li>Eine hybride L\u00f6sung, die Kernel-Ebene und Benutzerebene mischt.</li> <li>Der Kernel stellt mehrere Kernel-Threads (LWPs) f\u00fcr einen Prozess bereit.</li> <li>Die User-level Thread-Bibliothek verteilt die (vielen) User-Threads auf die (wenigeren) Kernel-Threads (N:M-Beziehung).</li> <li>Context-Switches zwischen User-Threads k\u00f6nnen im Userspace stattfinden (effizient), blockierende Aufrufe blockieren nur den LWP, nicht den ganzen Prozess.</li> </ul> </li> <li>Threads in Verteilten Systemen:<ul> <li>Multithreaded Clients: Hauptmotivation ist das Verbergen von Netzwerklatenz.<ul> <li>Beispiel Webbrowser: Ein Thread pro Datei (z.B. Bild), um mehrere Dateien parallel \u00fcber separate TCP-Verbindungen zu laden.</li> <li>Beispiel RPC: Mehrere RPCs k\u00f6nnen parallel (jeder in einem eigenen Thread) ausgef\u00fchrt werden, was bei Anfragen an verschiedene Server zu linearem Geschwindigkeitszuwachs f\u00fchren kann.</li> </ul> </li> <li>Multithreaded Server: Hauptmotivationen sind verbesserte Leistung und einfachere Softwarestruktur.<ul> <li>Leistung: Das Starten eines Threads ist \"billiger\" als das eines neuen Prozesses; Latenz kann verborgen werden, indem auf die n\u00e4chste Anfrage reagiert wird, w\u00e4hrend eine vorherige auf I/O wartet.</li> <li>Struktur: Erlaubt die Nutzung einfacher, blockierender Aufrufe, was den Kontrollfluss vereinfacht.</li> <li>Architektur: Oft als Dispatcher-Thread (nimmt Anfragen entgegen) und Pool von Worker-Threads (bearbeiten die Anfragen) implementiert.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/3.%20Technologische%20Grundlagen/#2-virtualisierung-grundlagen-konzepte","title":"2. Virtualisierung: Grundlagen &amp; Konzepte","text":"<p>Virtualisierung ist das Erweitern oder Ersetzen einer Schnittstelle, um ein anderes System zu imitieren. Ein Virtual Machine Monitor (VMM), auch Hypervisor genannt, ist die Software, die virtuelle Maschinen (VMs) erstellt und verwaltet.</p> <ul> <li>Rolle des VMM:<ul> <li>Der VMM besitzt die realen Hardwareressourcen.</li> <li>Er teilt Ressourcen zu durch Time-Sharing (z.B. CPU) oder Partitionierung (z.B. Festplatte).</li> <li>Nicht vorhandene Ressourcen werden vom VMM emuliert.</li> </ul> </li> <li>Zustandsmanagement (State Management):<ul> <li>Um zwischen VMs zu wechseln, muss der VMM den Zustand (Register) der VM sichern und den der n\u00e4chsten laden.</li> <li>Ansatz 1 (Indirektion): Der Prozessor hat nur einen \"Register Block Pointer\", der auf den Speichersatz der aktiven VM im VMM-Speicher zeigt. Umschalten = nur Pointer \u00e4ndern.</li> <li>Ansatz 2 (Kopieren): Der VMM kopiert die Registerwerte beim Umschalten explizit zwischen Prozessor und VMM-Speicher hin und her.</li> </ul> </li> <li>Native vs. Gehostete VMMs:<ul> <li>Native VM (Typ 1): Der VMM l\u00e4uft direkt auf der Hardware (z.B. VMware ESXi).</li> <li>User-mode hosted VM (Typ 2): Der VMM l\u00e4uft als normale Anwendung auf einem Host-Betriebssystem (z.B. VirtualBox).</li> <li>Dual-mode hosted VM (Typ 2): Der VMM ist als Modul im Host-Betriebssystem integriert (z.B. Parallels f\u00fcr Mac).</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/3.%20Technologische%20Grundlagen/#3-virtualisierung-kontrolle-effizienz","title":"3. Virtualisierung: Kontrolle &amp; Effizienz","text":"<p>Das Hauptproblem f\u00fcr einen VMM ist, die Kontrolle \u00fcber die Systemressourcen zu behalten, obwohl das Gast-Betriebssystem glaubt, es w\u00fcrde die Hardware direkt steuern.</p> <ul> <li>Popek &amp; Goldberg (1974) Kriterien: Ein \"echter\" VMM muss drei Kriterien erf\u00fcllen:<ol> <li>Effizienz: \"Harmlose\" (unbedenkliche) Anweisungen m\u00fcssen nativ (direkt auf der CPU) ausgef\u00fchrt werden.</li> <li>Ressourcenkontrolle: Gast-VMs d\u00fcrfen die Systemressourcen nicht \u00e4ndern k\u00f6nnen (Isolierung). Das Gast-OS muss daher im Benutzermodus laufen.</li> <li>\u00c4quivalenz: Ein Programm muss sich auf der VM (nahezu) genauso verhalten wie auf nativer Hardware (Ausnahme: Performance, Timing).</li> </ol> </li> <li>Das Virtualisierungs-Theorem:<ul> <li>Sensitive Instructions: Befehle, die die Ressourcenkonfiguration \u00e4ndern (control-sensitive) oder deren Verhalten von der Konfiguration abh\u00e4ngt (behavior-sensitive).</li> <li>Privileged Instructions: Befehle, die einen Trap (Fehler) ausl\u00f6sen, wenn sie im Benutzermodus ausgef\u00fchrt werden.</li> <li>Theorem: Ein VMM kann nur dann effizient konstruiert werden, wenn die Menge der sensitiven Instruktionen eine Teilmenge der privilegierten Instruktionen ist.</li> <li>Einfacher gesagt: Jeder Befehl, der \"gef\u00e4hrlich\" (sensitiv) ist, muss einen Trap ausl\u00f6sen, wenn das Gast-OS (im User-Mode) ihn ausf\u00fchrt. So erh\u00e4lt der VMM die Kontrolle zur\u00fcck.</li> </ul> </li> <li>Das Problem \"alter\" Architekturen (z.B. x86):<ul> <li>Die Bedingung ist nicht erf\u00fcllt.</li> <li>Es gibt \"kritische Anweisungen\": Das sind Befehle, die sensitiv, aber nicht privilegiert sind. Sie l\u00f6sen keinen Trap aus und erlauben dem Gast-OS, den VMM zu umgehen oder Systemzust\u00e4nde zu \u00e4ndern (z.B. der <code>POPF</code>-Befehl).</li> </ul> </li> <li>L\u00f6sungen f\u00fcr nicht-virtualisierbare Architekturen:<ol> <li>Bin\u00e4re \u00dcbersetzung (Binary Translation): Der VMM scannt den Code des Gast-OS zur Laufzeit. Kritische Anweisungen werden erkannt (\"Patched Program\") und durch Code ersetzt, der stattdessen den VMM aufruft (Emulation). F\u00fcr die Effizienz werden \u00fcbersetzte Code-Bl\u00f6cke in einem Code Cache gespeichert.</li> <li>Paravirtualisierung: Der Code des Gast-Betriebssystems wird im Voraus ge\u00e4ndert. Kritische Befehle werden durch explizite Aufrufe an den VMM (sog. \"Hypercalls\") ersetzt. Nachteil: Es wird ein speziell angepasstes Gast-OS ben\u00f6tigt.</li> </ol> </li> <li>Moderne Architekturen (Intel VT, ARM VHE): Diese ISAs sind nach den Popek/Goldberg-Kriterien konstruiert und beheben das Problem der \"kritischen Anweisungen\" in Hardware.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/3.%20Technologische%20Grundlagen/#4-container","title":"4. Container","text":"<p>Container (popularisiert durch Docker) sind eine Form der \"leichtgewichtigen Virtualisierung\". Der fundamentale Unterschied zu VMs ist, dass Container das zugrundeliegende Betriebssystem (Host OS) teilen.</p> <ul> <li>Isolations-Mechanismen: Anstelle von Hardware-Virtualisierung nutzen Container Kernel-Funktionen zur Isolierung:<ul> <li>Namespaces: Isolieren die \"Sicht\" des Containers auf Systemressourcen (z.B. eigene Prozess-IDs, Netzwerk-Interfaces, User-IDs).</li> <li>Union File System: Dateisysteme werden in Schichten aufgebaut. Ein \"Base Image\" (z.B. Ubuntu) ist read-only und wird geteilt; nur die \u00c4nderungen des Containers werden in eine separate, beschreibbare Schicht geschrieben.</li> <li>Control Groups (cgroups): Kontrollieren und limitieren die Ressourcennutzung (CPU, Speicher) f\u00fcr Prozessgruppen.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/3.%20Technologische%20Grundlagen/#5-vms-container-in-verteilten-systemen","title":"5. VMs &amp; Container in Verteilten Systemen","text":"<p>Die Hauptanwendung f\u00fcr Virtualisierungstechnologien in verteilten Systemen ist das Cloud Computing. Sie erm\u00f6glichen die effiziente Zuteilung von Ressourcen bei gleichzeitiger Wahrung der Isolationsanforderungen.</p> <ul> <li>IaaS (Infrastructure-as-a-Service): Bietet virtuelle Hardware-Ressourcen (z.B. virtuelle Rechner wie Amazon EC2).</li> <li>PaaS (Platform-as-a-Service): Bietet eine Plattform zur Anwendungsentwicklung und -ausf\u00fchrung (z.B. Heroku).</li> <li>SaaS (Software-as-a-Service): Bietet fertige Software-Anwendungen (z.B. Webmail).</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/","title":"4. Kommunikation","text":""},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/#1-grundlagen-der-kommunikation","title":"1. Grundlagen der Kommunikation","text":"<p>Kommunikation in verteilten Systemen basiert auf Protokollschichten. W\u00e4hrend das 7-schichtige OSI-Referenzmodell als theoretisches Modell dient, wird in der Praxis meist TCP/IP oder UDP/IP verwendet. F\u00fcr verteilte Systeme ist ein angepasstes Modell oft n\u00fctzlicher.</p> <ul> <li>Angepasstes Referenzmodell: Eine vereinfachte Schichtung:<ol> <li>Hardware (Physical/Link-level protocol)</li> <li>Operating System (Host-to-host protocol, z.B. TCP/IP)</li> <li>Middleware (Middleware protocol)</li> <li>Application (Application protocol)</li> </ol> </li> <li>Middleware-Protokolle: Diese Schicht stellt die eigentlichen Kommunikationsdienste f\u00fcr verteilte Anwendungen bereit, z.B. RPC, Authentifizierung, verteilte Sperren oder DNS.</li> <li>Kommunikationsdienste der Middleware:<ul> <li>Persistent vs. Transient:</li> <li>Persistent: Die Nachricht wird von der Middleware gespeichert (store-and-forward), bis sie erfolgreich zugestellt wird (z.B. E-Mail).</li> <li>Transient: Die Nachricht wird nur gespeichert, solange Sender und Empf\u00e4nger aktiv sind (z.B. TCP).</li> <li>Synchrone vs. Asynchrone Kommunikation:</li> <li>Synchron: Der Sender blockiert, bis seine Anfrage verarbeitet wurde. Dies kann an drei Punkten geschehen: bei der Anforderungs-\u00dcbermittlung (request submission), bei der Anforderungs-Zustellung (request delivery) oder nach der Verarbeitung durch den Server.</li> <li>Asynchron: Der Sender blockiert nicht (oder nur sehr kurz).</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/#2-remote-procedure-call-rpc","title":"2. Remote Procedure Call (RPC)","text":"<p>RPC ist eine Kerntechnologie, um Zugriffstransparenz zu erreichen. Die Idee ist, einen Aufruf an eine Prozedur auf einem entfernten Rechner (Server) genauso aussehen zu lassen wie einen normalen, lokalen Prozeduraufruf.</p> <ul> <li>RPC-Ablauf (10 Schritte):<ol> <li>Der Client-Prozess ruft die lokale Client-Stub-Funktion auf.</li> <li>Der Client-Stub \"verpackt\" die Parameter in eine Nachricht (Marshalling).</li> <li>Das Client-Betriebssystem sendet die Nachricht \u00fcber das Netzwerk.</li> <li>Das Server-Betriebssystem empf\u00e4ngt die Nachricht und \u00fcbergibt sie an den Server-Stub.</li> <li>Der Server-Stub \"entpackt\" die Parameter (Unmarshalling) und ruft die eigentliche, lokale Server-Prozedur auf.</li> <li>Die Server-Prozedur wird ausgef\u00fchrt und gibt ihr Ergebnis an den Server-Stub zur\u00fcck.</li> <li>Der Server-Stub verpackt das Ergebnis in eine Antwortnachricht (Marshalling).</li> <li>Das Server-Betriebssystem sendet die Antwort zur\u00fcck.</li> <li>Das Client-Betriebssystem empf\u00e4ngt die Antwort und \u00fcbergibt sie dem Client-Stub.</li> <li>Der Client-Stub entpackt das Ergebnis (Unmarshalling) und gibt es als R\u00fcckgabewert an den aufrufenden Client-Prozess zur\u00fcck.</li> </ol> </li> <li>Herausforderung: Parameter\u00fcbergabe (Marshalling):<ul> <li>Computer haben unterschiedliche Datenrepr\u00e4sentationen (z.B. Little-Endian vs. Big-Endian).</li> <li>Marshalling wandelt daher alle Daten in ein maschinen-unabh\u00e4ngiges Format um, damit der Empf\u00e4nger sie korrekt interpretieren kann.</li> </ul> </li> <li>Herausforderung: Pointer / Referenzen:<ul> <li>Speicheradressen (Pointer) haben nur lokale Bedeutung und k\u00f6nnen nicht \u00fcber das Netzwerk gesendet werden.</li> <li>L\u00f6sung 1: Das referenzierte Objekt wird kopiert (meist nur \"shallow copy\") und auf dem Server eine Referenz auf die Kopie verwendet. Bei Objekten nennt man dies Serialisierung und Deserialisierung.</li> <li>L\u00f6sung 2: Es werden globale Referenzen wie URIs verwendet.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/#3-rpc-implementierung-und-varianten","title":"3. RPC Implementierung und Varianten","text":"<p>Um die RPC-Komplexit\u00e4t zu verbergen, werden Stubs meist automatisch generiert. Au\u00dferdem kann das blockierende Verhalten von RPCs angepasst werden.</p> <ul> <li>Stub-Generierung:<ul> <li>Stubs werden nicht manuell geschrieben, sondern von einem Stub-Compiler automatisch generiert.</li> <li>Als Eingabe dient eine Interface Definition Language (IDL)-Datei, welche die Prozeduren, Parameter und R\u00fcckgabetypen maschinenunabh\u00e4ngig beschreibt.</li> <li>Popul\u00e4re IDLs sind Google Protobufs und Apache Thrift.</li> </ul> </li> <li>Synchrone vs. Asynchrone RPCs:<ul> <li>Synchron (Standard): Der Client ruft die Prozedur auf und blockiert (wartet), bis der Server die Ausf\u00fchrung beendet hat und das Ergebnis (Reply) zur\u00fcckschickt.</li> <li>Asynchron (mit ACK): Der Client ruft auf und blockiert nur, bis der Server den Empfang der Anfrage best\u00e4tigt hat (Acknowledge). Der Client wartet nicht auf das Endergebnis.</li> <li>Deferred Synchronous RPC (mit Callback): Der Client macht einen asynchronen Aufruf und \u00fcbergibt einen Callback-Handler. Der Client-Stub kehrt sofort zur\u00fcck. Wenn der Server sp\u00e4ter das Ergebnis hat, ruft er den Client \u00fcber einen separaten RPC zur\u00fcck und l\u00f6st den Callback-Handler aus.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/#4-nachrichtenorientierte-kommunikation","title":"4. Nachrichtenorientierte Kommunikation","text":"<p>Als Alternative zu RPC (das versucht, Kommunikation zu verbergen) gibt es explizite nachrichtenorientierte Kommunikation, bei der Sender und Empf\u00e4nger Nachrichten bewusst austauschen.</p> <ul> <li>Sockets (z.B. TCP):<ul> <li>Bietet transiente (nicht-persistente) und verbindungsorientierte Kommunikation.</li> <li>Der Server nutzt <code>socket()</code>, <code>bind()</code>, <code>listen()</code> und blockiert bei <code>accept()</code>.</li> <li>Der Client nutzt <code>socket()</code> und <code>connect()</code>.</li> <li>Sobald die Verbindung steht (Synchronisationspunkt), k\u00f6nnen beide \u00fcber <code>read()</code> und <code>write()</code> kommunizieren.</li> </ul> </li> <li>Message-Queuing (MOM - Message-Oriented Middleware):<ul> <li>Bietet persistente, asynchrone Kommunikation \u00fcber Warteschlangen (Queues).</li> <li>Dies ist oft die Basis f\u00fcr Publish-Subscribe-Systeme.</li> <li>AMQP (Advanced Message Queuing Protocol): Ein offener Standard hierf\u00fcr, der auf Sicherheit und Zuverl\u00e4ssigkeit ausgelegt ist (eingesetzt z.B. im Finanzwesen und Telekommunikation).</li> </ul> </li> <li>Message Passing Interface (MPI):<ul> <li>Eine Abstraktionsebene \u00fcber Sockets, die speziell f\u00fcr High-Performance Computing (HPC) und wissenschaftliches Rechnen entwickelt wurde.</li> <li>Bietet transienten Nachrichtenaustausch mit verschiedenen Synchronisationsmodi (z.B. blockierend, asynchron).</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/#5-multicast-kommunikation","title":"5. Multicast Kommunikation","text":"<p>Multicast ist der Prozess, Informationen an alle Mitglieder einer definierten Gruppe zu verteilen. Die Herausforderung ist, dies skalierbar (f\u00fcr tausende Knoten) und fehlertolerant (gegen Paketverlust und Knotenausf\u00e4lle) zu gestalten.</p> <ul> <li>Zentralisierter Ansatz: Ein Sender schickt die Nachricht an alle \\(N\\) Empf\u00e4nger. Dies ist einfach, aber nicht skalierbar und langsam.</li> <li>Baum-basierte Protokolle:<ul> <li>Die Knoten bilden einen Spanning Tree. Nachrichten werden entlang des Baums verteilt.</li> <li>Verlorene Pakete werden durch ACKs (Best\u00e4tigungen) oder NAKs (Negative Best\u00e4tigungen) \"repariert\".</li> <li>RMTP (Reliable Multicast Transport Protocol): Verwendet ACKs.</li> <li>SRM (Scalable Reliable Multicast): Verwendet NAKs, nutzt aber zuf\u00e4llige Verz\u00f6gerungen, um \"NAK-St\u00fcrme\" (wenn alle gleichzeitig ein NAK senden) zu vermeiden.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/4.%20Kommunikation/#6-gossip-protokolle-epidemischer-multicast","title":"6. Gossip Protokolle (Epidemischer Multicast)","text":"<p>Gossip ist eine popul\u00e4re, dezentrale und sehr robuste Alternative f\u00fcr Multicast. Die Verbreitung von Nachrichten wird wie eine Epidemie modelliert.</p> <ul> <li>Grundprinzip (Push-Gossip):<ol> <li>Ein Knoten (der \"infiziert\" ist) m\u00f6chte eine Nachricht verbreiten.</li> <li>Er w\u00e4hlt k zuf\u00e4llige Zielknoten aus und sendet ihnen die Nachricht (per UDP).</li> <li>Jeder Knoten, der die Nachricht neu empf\u00e4ngt, wiederholt diesen Vorgang in der n\u00e4chsten \"Runde\".</li> </ol> </li> <li>Varianten:<ul> <li>Push-Gossip (Epidemisch): Aktives Verbreiten (infizieren) von Nachrichten.</li> <li>Pull-Gossip: Knoten fragen periodisch k zuf\u00e4llige Knoten, ob sie neue Nachrichten haben.</li> <li>Hybrid: Eine Kombination aus beidem.</li> </ul> </li> <li>Analyse &amp; Effizienz:<ul> <li>Gossip ist leichtgewichtig, sehr fehlertolerant und verbreitet sich schnell.</li> <li>Mit nur \\(c \\cdot log(n)\\) Runden (sehr geringe Latenz) erreicht die Nachricht fast alle Knoten.</li> <li>Die Last pro Knoten ist gering (jeder sendet nur \\(c \\cdot k \\cdot log(n)\\) Nachrichten).</li> </ul> </li> <li>Fehlertoleranz:<ul> <li>Paketverlust: Selbst bei 50% Paketverlust funktioniert das Protokoll zuverl\u00e4ssig, wenn man die Anzahl der Runden verdoppelt.</li> <li>Knotenausfall: Selbst wenn 50% der Knoten ausfallen, funktioniert das Protokoll (mit Anpassung der Runden).</li> </ul> </li> <li>Topologie-Ber\u00fccksichtigung:<ul> <li>Naives Gossip (Auswahl irgendeines Knotens im Internet) kann Core-Router \u00fcberlasten.</li> <li>L\u00f6sung: Hierarchisches Gossip. W\u00e4hle zuerst ein Subnetz zuf\u00e4llig aus, dann einen Knoten innerhalb dieses Subnetzes. Dies h\u00e4lt die Router-Last minimal (\\(O(1)\\)).</li> </ul> </li> <li>Anwendung: Gossip wird in vielen Key-Value Stores (z.B. Cassandra), Sensornetzen und dem Network News Transport Protocol (NNTP) verwendet.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/","title":"5. Koordination","text":""},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#1-aufgaben-koordination-synchronisation","title":"1. Aufgaben: Koordination &amp; Synchronisation","text":"<p>Koordination in verteilten Systemen befasst sich mit der Organisation von Interaktionen und der Synchronisation von Prozessen und Daten.</p> <ul> <li>Prozesssynchronisation: Ein Prozess wartet auf einen anderen, um eine Operation abzuschlie\u00dfen.</li> <li>Datensynchronisation: Sicherstellen, dass zwei Datenmengen identisch sind.</li> <li>Koordination: Organisation von Interaktionen und Abh\u00e4ngigkeiten im System.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#2-physikalische-uhrensynchronisation","title":"2. Physikalische Uhrensynchronisation","text":"<p>Das Hauptproblem ist, dass jeder Computer eine eigene, ungenaue Hardware-Uhr hat. Ohne Synchronisation k\u00f6nnen Fehler entstehen (z.B. beim <code>make</code>-Kommando). Das Ziel ist, die Uhren an die \"exakte\" UTC (Universal Coordinated Time) anzugleichen.</p> <ul> <li>UTC: Basiert auf Atomuhren (TAI - Internationale Atomzeit), wird aber durch Schaltsekunden an die Erdrotation (Sonnentag) angepasst.</li> <li>Problem (Drift): Lokale Uhren sind nicht ideal. Ihre Geschwindigkeit (\\(dC/dt\\)) weicht von 1 ab. Die Abweichung wird durch die Driftrate \\(\\rho\\) (rho) beschrieben.</li> <li>Ziel: Die Abweichung zwischen zwei Uhren soll nie gr\u00f6\u00dfer als \\(\\delta\\) (delta) sein.</li> <li>L\u00f6sung: Uhren m\u00fcssen mindestens alle \\(\\Delta t \\le \\delta / (2\\rho)\\) Sekunden neu synchronisiert werden.</li> <li>Regel: Die Zeit darf niemals r\u00fcckw\u00e4rts laufen. Schnelle Uhren m\u00fcssen stattdessen verlangsamt werden (ihre Taktrate wird angepasst).</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#3-network-time-protocol-ntp","title":"3. Network Time Protocol (NTP)","text":"<p>NTP (basierend auf Cristians Algorithmus) ist ein praktisches Verfahren zur Synchronisation physikalischer Uhren. Ein Client fragt einen Zeitserver nach der Zeit.</p> <ul> <li>Messung: Der Client misst vier Zeitstempel: \\(T_1\\) (Anfrage gesendet), \\(T_2\\) (Anfrage empfangen), \\(T_3\\) (Antwort gesendet), \\(T_4\\) (Antwort empfangen).</li> <li>Berechnung (Offset): Der Client berechnet den Zeit-Offset \\(\\Theta\\) (theta) seiner Uhr relativ zum Server: \\(\\Theta = ((T_2 - T_1) + (T_3 - T_4)) / 2\\).</li> <li>Berechnung (Verz\u00f6gerung): Er berechnet auch die durchschnittliche Einweg-Verz\u00f6gerung \\(\\delta\\) (delta): \\(\\delta = ((T_4 - T_1) - (T_3 - T_2)) / 2\\).</li> <li>Auswahl: Es werden mehrere Paare \\((\\Theta, \\delta)\\) berechnet, und das Paar mit der kleinsten Verz\u00f6gerung \\(\\delta\\) wird zur Korrektur verwendet.</li> <li>NTP Strata: Um Last zu verteilen und Schleifen zu vermeiden, sind Server in Schichten (Strata) organisiert.<ul> <li>Stratum 0: Atomuhren (die Referenz).</li> <li>Stratum 1: Server, die direkt mit Stratum 0 synchronisieren.</li> <li>Stratum n+1: Server, die mit Stratum \\(n\\) synchronisieren.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#4-logische-zeit-und-reihenfolge","title":"4. Logische Zeit und Reihenfolge","text":"<p>Oft ist nicht die exakte physikalische Zeit wichtig, sondern nur die relative Reihenfolge von Ereignissen. Dies wird durch die Happened-Before-Relation (\\(\\rightarrow\\)) und Logische Uhren (Lamport Clocks) erreicht.</p> <ul> <li>Happened-Before Relation (\\(\\rightarrow\\)): Eine partielle Ordnung, definiert durch drei Regeln:<ol> <li>Im selben Prozess: Wenn \\(a\\) vor \\(b\\) im selben Prozess passiert, dann \\(a \\rightarrow b\\).</li> <li>Nachrichten: Wenn \\(a\\) das Senden und \\(b\\) der Empfang derselben Nachricht ist, dann \\(a \\rightarrow b\\).</li> <li>Transitivit\u00e4t: Wenn \\(a \\rightarrow b\\) und \\(b \\rightarrow c\\), dann \\(a \\rightarrow c\\).</li> </ol> </li> <li>Lamports Algorithmus: Weist jedem Ereignis einen Zeitstempel (einen Z\u00e4hler \\(C\\)) zu, der die Happened-Before-Relation abbildet.<ul> <li>Regel 1 (Lokales Ereignis): \\(C_i \\leftarrow C_i + 1\\).</li> <li>Regel 2 (Senden): \\(C_i \\leftarrow C_i + 1\\); die Nachricht erh\u00e4lt den Zeitstempel \\(T_m = C_i\\).</li> <li>Regel 3 (Empfangen): Beim Empfang von \\(T_m\\), setze \\(C_j \\leftarrow max(C_j, T_m) + 1\\).</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#5-vector-clocks","title":"5. Vector Clocks","text":"<p>Lamport Clocks haben eine Schw\u00e4che: Wenn \\(C(a) &lt; C(b)\\), hei\u00dft das nicht zwingend, dass \\(a \\rightarrow b\\). Vector Clocks l\u00f6sen dieses Problem und erfassen die Kausalit\u00e4t exakt.</p> <ul> <li>Struktur: Jeder Prozess \\(P_i\\) hat einen Vektor \\(VC_i[1..n]\\). \\(VC_i[j]\\) z\u00e4hlt die Ereignisse bei Prozess \\(P_j\\), von denen \\(P_i\\) wei\u00df.</li> <li>Regel 1 (Lokales Ereignis): \\(VC_i[i] \\leftarrow VC_i[i] + 1\\).</li> <li>Regel 2 (Senden): \\(VC_i[i] \\leftarrow VC_i[i] + 1\\); sende den gesamten Vektor \\(VC_i\\) mit der Nachricht.</li> <li>Regel 3 (Empfangen): Beim Empfang von \\(vt(m)\\) von \\(P_i\\):<ol> <li>\\(VC_j[k] \\leftarrow max(VC_j[k], vt(m)[k])\\) f\u00fcr alle \\(k\\).</li> <li>\\(VC_j[j] \\leftarrow VC_j[j] + 1\\).</li> </ol> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#6-totale-ordnung","title":"6. Totale Ordnung","text":"<p>In manchen Systemen (z.B. replizierte Datenbanken) reicht eine partielle Ordnung nicht aus. Gleichzeitige Updates m\u00fcssen bei allen Replikaten in derselben Reihenfolge angewendet werden, um Inkonsistenzen zu vermeiden.</p> <ul> <li>Problem: Replikat R1 wendet (Einzahlung + Zinsen) an, R2 wendet (Zinsen + Einzahlung) an. Die Endergebnisse sind unterschiedlich.</li> <li>L\u00f6sung: Total geordneter Multicast, der sicherstellt, dass alle Prozesse alle Nachrichten in derselben globalen Reihenfolge empfangen.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#7-gegenseitiger-ausschluss-mutex","title":"7. Gegenseitiger Ausschluss (Mutex)","text":"<p>Ein klassisches Problem, bei dem mehrere Prozesse exklusiven Zugriff auf eine gemeinsame Ressource (einen kritischen Abschnitt) ben\u00f6tigen.</p> <ul> <li>Ansatz 1: Zentralisierter Algorithmus:<ul> <li>Ein Prozess wird zum Koordinator gew\u00e4hlt.</li> <li>Wer in den kritischen Abschnitt will, schickt eine <code>Request</code>-Nachricht an den Koordinator.</li> <li>Der Koordinator antwortet mit <code>OK</code>. Wenn die Ressource belegt ist, kommt der <code>Request</code> in eine Warteschlange.</li> <li>Nach Verlassen wird eine <code>Release</code>-Nachricht gesendet.</li> <li>Problem: Der Koordinator ist ein Single Point of Failure.</li> </ul> </li> <li>Ansatz 2: Dezentralisierter Algorithmus:<ul> <li>Die Ressource wird \\(n\\)-mal repliziert, jede mit einem Koordinator.</li> <li>Ein Prozess ben\u00f6tigt die Erlaubnis von einer Mehrheit (\\(m &gt; n/2\\)) der Koordinatoren.</li> <li>Probleme: Nur probabilistisch korrekt und anf\u00e4llig f\u00fcr \"Verhungern\" (keiner kriegt eine Mehrheit).</li> </ul> </li> <li>Ansatz 3: Praktische Systeme (z.B. Zookeeper):<ul> <li>Verwenden oft einen (hochverf\u00fcgbaren) zentralisierten Koordinator-Dienst wie Apache Zookeeper.</li> <li>Zookeeper wird f\u00fcr Cluster-Management, Leader-Wahl und Konfiguration in Systemen wie Hadoop und Kafka genutzt.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/5.%20Koordination/#8-wahl-algorithmen-election","title":"8. Wahl-Algorithmen (Election)","text":"<p>Diese Algorithmen werden ben\u00f6tigt, um dynamisch einen Koordinator (Leader) zu bestimmen, z.B. wenn der alte ausf\u00e4llt. Statische Wahlen sind ein Single-Point-of-Failure.</p> <ul> <li>Der Bully-Algorithmus:<ul> <li>Idee: Der Prozess mit der h\u00f6chsten Priorit\u00e4t (h\u00f6chste ID-Nummer) \"mobbt\" sich an die Spitze und wird Leader.</li> <li>Ablauf:<ol> <li>Prozess \\(P\\) stellt Ausfall des Leaders fest und startet eine Wahl. Er sendet <code>Election</code>-Nachrichten an alle Prozesse mit h\u00f6herer ID.</li> <li>Wenn ein h\u00f6herer Prozess \\(Q\\) die Nachricht empf\u00e4ngt, antwortet er mit <code>OK</code>, \\(P\\) ist aus dem Rennen und \\(Q\\) startet selbst eine Wahl.</li> <li>Wenn \\(P\\) keine <code>OK</code>-Antwort erh\u00e4lt (weil alle h\u00f6heren ausgefallen sind), gewinnt \\(P\\) die Wahl und sendet eine <code>Coordinator</code>-Nachricht an alle.</li> </ol> </li> </ul> </li> <li>Ring-Algorithmus:<ul> <li>Idee: Die Prozesse sind in einem logischen Ring angeordnet.</li> <li>Ablauf:<ol> <li>\\(P\\) startet eine Wahl und sendet eine <code>Election</code>-Nachricht mit einer \"Alive-Liste\" an seinen Nachfolger.</li> <li>Jeder Prozess f\u00fcgt seine ID der Liste hinzu und leitet sie weiter.</li> <li>Wenn die Nachricht wieder beim Initiator \\(P\\) ankommt, enth\u00e4lt sie eine Liste aller aktiven Prozesse.</li> <li>\\(P\\) sendet eine <code>Coordinator</code>-Nachricht an alle, die den Prozess mit der h\u00f6chsten Priorit\u00e4t aus der Liste zum neuen Leader ernennt.</li> </ol> </li> </ul> </li> <li>Praktische Systeme: Zookeeper und Raft sind g\u00e4ngige Systeme zur Implementierung von Leader-Wahlen.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/6.%20Namen%20in%20Verteilten%20Systemen/","title":"6. Namen in Verteilten Systemen","text":""},{"location":"Verteilte%20Systeme/Vorlesung/6.%20Namen%20in%20Verteilten%20Systemen/#1-relevanz-der-benennung","title":"1. Relevanz der Benennung","text":"<p>Die Benennung (Naming) ist ein fundamentales Konzept in verteilten Systemen. Sie dient dazu, Transparenz (Zugriff und Lokation) herzustellen, die gemeinsame Nutzung von Ressourcen zu erm\u00f6glichen, Skalierbarkeit zu gew\u00e4hrleisten und die Sicherheit (Zugriffskontrolle) zu unterst\u00fctzen.</p>"},{"location":"Verteilte%20Systeme/Vorlesung/6.%20Namen%20in%20Verteilten%20Systemen/#2-namen-adressen-und-bezeichner","title":"2. Namen, Adressen und Bezeichner","text":"<p>Um Entit\u00e4ten (wie Computer, Drucker, Dienste etc.) anzusprechen, werden verschiedene Arten von \"Namen\" verwendet.</p> <ul> <li>Name: Ein allgemeiner Begriff, der verwendet wird, um sich auf eine Entit\u00e4t zu beziehen.<ul> <li>Reiner Name (Pure Name): Eine zuf\u00e4llige Zeichenkette ohne eigene Bedeutung, die nur f\u00fcr Vergleiche n\u00fctzlich ist.</li> </ul> </li> <li>Zugangspunkt (Access Point): Ein Ort, \u00fcber den auf eine Entit\u00e4t zugegriffen werden kann.</li> <li>Adresse: Der Name eines Zugangspunktes.</li> <li>Ortsunabh\u00e4ngiger Name: Ein Name, der nicht von der Adresse der Entit\u00e4t abh\u00e4ngt.</li> <li>Bezeichner (Identifier): Ein Name, der eine Entit\u00e4t eindeutig und dauerhaft referenziert.<ul> <li>Er bezieht sich auf h\u00f6chstens eine Entit\u00e4t.</li> <li>Er bezieht sich immer auf dieselbe Entit\u00e4t und wird nicht wiederverwendet.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/6.%20Namen%20in%20Verteilten%20Systemen/#3-benennung-vs-lokalisierung","title":"3. Benennung vs. Lokalisierung","text":"<p>In einem dynamischen verteilten System ist es unrealistisch anzunehmen, dass die Standorte (Adressen) von Entit\u00e4ten stabil sind. Daher ist es sinnvoll, die Benennung von der Standortfindung zu entkoppeln.</p> <ul> <li>Direkte Zuordnung (a): Ein Name wird direkt einer oder mehreren Adressen zugeordnet. Dies ist unflexibel.</li> <li>Indirekte Zuordnung (b): Ein (oder mehrere) Namen werden einem stabilen Bezeichner (Entity ID) zugeordnet. Dieser Bezeichner wird dann auf die aktuellen Adressen (Standorte) abgebildet.<ul> <li>Naming Service (Benennungsdienst): Bildet Namen auf Bezeichner ab (z.B. DNS). Er geht von stabilen Inhalten aus.</li> <li>Location Service (Standortdienst): Bildet Bezeichner auf die aktuellen Adressen mobiler Entit\u00e4ten ab. Er geht davon aus, dass sich Standorte h\u00e4ufig \u00e4ndern.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/6.%20Namen%20in%20Verteilten%20Systemen/#4-home-based-approach-beispiel-mobiltelefonie","title":"4. Home-Based Approach (Beispiel Mobiltelefonie)","text":"<p>Ein g\u00e4ngiges Muster zur Lokalisierung mobiler Entit\u00e4ten ist der \"Home-Base\"-Ansatz.</p> <ul> <li>Konzept: Jede mobile Entit\u00e4t hat einen festen \"Heimatstandort\" (Home Location), der ihren Bezeichner kennt.</li> <li>Ablauf (z.B. Anruf an ein Handy):<ol> <li>Ein Anrufer (Caller) sendet das Paket (den Anruf) an den Heimatstandort des Mobiltelefons.</li> <li>Der Heimatstandort wei\u00df, wo sich das Telefon aktuell befindet (Mobile's current location) und leitet die R\u00fcckadresse des aktuellen Standorts an den Anrufer weiter.</li> <li>Gleichzeitig wird das erste Paket vom Heimatstandort zum aktuellen Standort \"getunnelt\" (weitergeleitet).</li> <li>Der Anrufer kann nun alle folgenden Pakete direkt an den (jetzt bekannten) aktuellen Standort senden.</li> </ol> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/","title":"7. Konsistenz und Replikation","text":""},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/#1-replikation-und-das-konsistenzproblem","title":"1. Replikation und das Konsistenzproblem","text":"<p>Replikation, also das Kopieren von Daten auf mehrere Rechner, wird genutzt, um die Zuverl\u00e4ssigkeit (Schutz vor Ausfall) und die Skalierbarkeit (Lastverteilung) zu erh\u00f6hen.</p> <ul> <li>Das Hauptproblem: Um Replikate konsistent zu halten, m\u00fcssen alle Operationen (insbesondere kollidierende) auf allen Kopien in derselben Reihenfolge ausgef\u00fchrt werden.</li> <li>Konflikte:<ul> <li>Lese-Schreib-Konflikt: Ein Lesevorgang ist gleichzeitig mit einem Schreibvorgang.</li> <li>Schreib-Schreib-Konflikt: Zwei Schreibvorg\u00e4nge sind gleichzeitig.</li> </ul> </li> <li>Die L\u00f6sung (Kompromiss): Die Gew\u00e4hrleistung einer strikten globalen Ordnung ist teuer und langsam. Daher werden Konsistenzmodelle geschw\u00e4cht, um eine bessere Skalierbarkeit zu erreichen.</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/#2-datenzentrierte-konsistenzmodelle","title":"2. Datenzentrierte Konsistenzmodelle","text":"<p>Ein Konsistenzmodell ist ein Vertrag zwischen dem Datenspeicher und den Prozessen. Es definiert, welches Ergebnis Leseoperationen zur\u00fcckliefern, wenn gleichzeitig Schreiboperationen stattfinden.</p> <p>Man unterscheidet zwischen starken Modellen (strikte Regeln) und schwachen Modellen (gelockerte Regeln).</p>"},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/#3-starke-konsistenzmodelle","title":"3. Starke Konsistenzmodelle","text":"<p>Diese Modelle bieten starke Garantien \u00fcber die Reihenfolge der Operationen, die f\u00fcr alle Prozesse sichtbar sind.</p> <ul> <li>Strenge Konsistenz (Strict Consistency)<ul> <li>Definition: Jeder Lesevorgang liefert den Wert des j\u00fcngsten Schreibvorgangs (basierend auf der Echtzeit).</li> <li>Problem: In einem verteilten System gibt es keine globale Uhr, daher ist das Konzept des \"j\u00fcngsten\" Zeitpunkts kaum umsetzbar.</li> </ul> </li> <li>Sequentielle Konsistenz (Sequential Consistency)<ul> <li>Definition: Das Ergebnis ist dasselbe, als ob alle Operationen aller Prozesse in irgendeiner sequentiellen Reihenfolge (Interleaving) ausgef\u00fchrt worden w\u00e4ren, wobei die programminterne Reihenfolge jedes einzelnen Prozesses erhalten bleibt.</li> <li>Bedeutung: Es gibt eine globale Reihenfolge, die alle Prozesse \"sehen\" (z.B. W(a) vor W(b)), aber diese Reihenfolge muss nicht der Echtzeit entsprechen.</li> </ul> </li> <li>Kausale Konsistenz (Causal Consistency)<ul> <li>Definition: Nur kausal zusammenh\u00e4ngende Schreibvorg\u00e4nge m\u00fcssen von allen Prozessen in derselben (kausalen) Reihenfolge gesehen werden.</li> <li>Bedeutung: Gleichzeitige (konkurrierende) Schreibvorg\u00e4nge k\u00f6nnen von verschiedenen Prozessen in unterschiedlicher Reihenfolge gesehen werden.</li> </ul> </li> <li>FIFO-Konsistenz (FIFO Consistency)<ul> <li>Definition: Schreibvorg\u00e4nge von einem einzelnen Prozess werden von allen anderen Prozessen in der Reihenfolge gesehen, in der sie ausgef\u00fchrt wurden.</li> <li>Bedeutung: Schreibvorg\u00e4nge von verschiedenen Prozessen k\u00f6nnen in unterschiedlicher Reihenfolge gesehen werden.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/#4-schwache-konsistenzmodelle","title":"4. Schwache Konsistenzmodelle","text":"<p>Diese Modelle lockern die Regeln stark und verlassen sich auf Synchronisationsvariablen (wie Mutexe oder Sperren), um Konsistenz nur dann explizit zu erzwingen, wenn es vom Programm angefordert wird.</p> <ul> <li>Schwache Konsistenz (Weak Consistency)<ul> <li>Definition: Es wird nicht garantiert, dass einzelne Schreibvorg\u00e4nge sofort sichtbar sind. Konsistenz wird nur an Synchronisationspunkten erzwungen.</li> <li>Regeln:<ol> <li>Operationen auf Synchronisationsvariablen selbst sind sequentiell konsistent.</li> <li>Bevor eine Synchronisationsoperation (z.B. <code>release()</code>) durchgef\u00fchrt wird, m\u00fcssen alle vorherigen Schreibvorg\u00e4nge auf den Daten abgeschlossen und f\u00fcr alle sichtbar sein.</li> <li>Bevor auf Daten zugegriffen wird (Lesen/Schreiben), m\u00fcssen alle vorherigen Synchronisationsoperationen abgeschlossen sein.</li> </ol> </li> </ul> </li> <li>Weitere Modelle:<ul> <li>Freigabekonsistenz (Release): Gemeinsame Daten sind konsistent, wenn eine Synchronisationsvariable freigegeben wird.</li> <li>Eintrittskonsistenz (Entry): Gemeinsame Daten sind konsistent, wenn eine Synchronisationsvariable erlangt (acquire) wird.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/#5-klienten-zentrierte-konsistenz","title":"5. Klienten-zentrierte Konsistenz","text":"<p>Diese Perspektive konzentriert sich nicht auf die globale Sicht aller Prozesse, sondern auf die Garantien, die ein einzelner Klient erh\u00e4lt (besonders relevant f\u00fcr mobile Nutzer, die auf verschiedene Replikate zugreifen).</p> <ul> <li>Monotones Lesen (Monotonic Reads)<ul> <li>Definition: Wenn ein Prozess einen Wert \\(x\\) liest, liefert jeder nachfolgende Lesevorgang desselben Prozesses denselben oder einen neueren Wert. Man sieht nie \"die Vergangenheit\".</li> <li>Beispiel: Eine E-Mail-Inbox, die auf einem Server gelesene Mails anzeigt, wird auf einem anderen Server nicht pl\u00f6tzlich wieder als \"ungelesen\" angezeigt.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/7.%20Konsistenz%20und%20Replikation/#6-eventual-consistency-stufenlose-konsistenz","title":"6. Eventual Consistency &amp; Stufenlose Konsistenz","text":"<p>Diese Modelle sind f\u00fcr hochskalierbare Systeme (z.B. Cloud-Datenbanken) relevant, die Verf\u00fcgbarkeit \u00fcber sofortige Konsistenz stellen.</p> <ul> <li>Eventual Consistency<ul> <li>Definition: Wenn keine neuen Aktualisierungen (Schreibvorg\u00e4nge) an einem Datenelement vorgenommen werden, konvergieren irgendwann (eventually) alle Replikate auf denselben, zuletzt geschriebenen Wert.</li> <li>Kontext: Dies stellt Verf\u00fcgbarkeit trotz Netzwerkpartitionen sicher (siehe CAP-Theorem).</li> <li>Klienten-zentrierte Sicht (Definitionen f\u00fcr \"Eventual\"):<ul> <li>Monotones Lesen: Man sieht nie veraltete Daten, nachdem man neuere gesehen hat.</li> <li>Lies Deine Schreibvorg\u00e4nge (Read Your Writes): Ein Prozess sieht immer seine eigenen, (gerade eben) geschriebenen Werte.</li> <li>Schreibvorg\u00e4nge folgen Lesevorg\u00e4ngen (Writes Follow Reads): Kausale Abh\u00e4ngigkeiten (Lesen eines Werts, dann Schreiben eines neuen Werts) werden eingehalten.</li> </ul> </li> </ul> </li> <li>Stufenlose Konsistenz (Tunable Consistency)<ul> <li>Idee: Statt einer bin\u00e4ren (ja/nein) Konsistenz wird der Grad der Inkonsistenz gemessen und toleriert.</li> <li>Conit (Consistency Unit): Die Dateneinheit, f\u00fcr die die Metriken gelten (z.B. ein einzelner Datensatz).</li> <li>Metriken (Abweichungen):<ol> <li>Veralterungsgrad (Staleness): Wie alt sind die Daten im Replikat?</li> <li>Ordnungsabweichung (Order deviation): Wie viele Updates wurden in der falschen Reihenfolge angewendet?</li> <li>Numerische Abweichung (Numerical deviation): Wie gro\u00df ist der Zahlenunterschied zwischen den Werten der Replikate?</li> </ol> </li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/","title":"8. Fehlertolleranz","text":""},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/#1-grundlagen-verlasslichkeit-und-terminologie","title":"1. Grundlagen: Verl\u00e4sslichkeit und Terminologie","text":"<p>Fehlertoleranz ist ein Aspekt der Verl\u00e4sslichkeit (Dependability). Diese beschreibt, wie korrekt eine Komponente ihren Dienst erbringt, selbst wenn andere Komponenten, von denen sie abh\u00e4ngt, fehlerhaft sind.</p> <ul> <li>Eigenschaften der Verl\u00e4sslichkeit:<ul> <li>Verf\u00fcgbarkeit (Availability): Das System ist unmittelbar benutzbar.</li> <li>Zuverl\u00e4ssigkeit (Reliability): Das System l\u00e4uft fortlaufend ausfallfrei.</li> <li>(Funktions-)Sicherheit (Safety): Es tritt kein katastrophaler Zustand ein.</li> <li>Wartbarkeit (Maintainability): Wie leicht ein ausgefallenes System repariert werden kann.</li> </ul> </li> <li>Terminologie (Ursache &amp; Wirkung):<ul> <li>St\u00f6rung (Fault): Die Ursache eines Problems (z.B. ein Programmierfehler, ein defektes Kabel).</li> <li>Fehler (Error): Ein Teil des Systemzustands, der zu einem Ausfall f\u00fchren kann (z.B. ein falscher Wert im Speicher).</li> <li>Ausfall (Failure): Das System erf\u00fcllt seine Spezifikation nicht mehr (z.B. liefert ein falsches Ergebnis oder st\u00fcrzt ab).</li> </ul> </li> <li>Strategien:<ul> <li>St\u00f6rungspr\u00e4vention (Fault Prevention): Verhindern, dass St\u00f6rungen \u00fcberhaupt entstehen.</li> <li>St\u00f6rungstoleranz (Fault Tolerance): Die Spezifikation trotz St\u00f6rungen erf\u00fcllen.</li> <li>St\u00f6rungsbehebung (Fault Removal): Die Anzahl oder Schwere von St\u00f6rungen reduzieren (z.B. Debugging).</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/#2-fehlermodelle","title":"2. Fehlermodelle","text":"<p>Fehler werden in verschiedene Arten klassifiziert, um den Umgang mit ihnen zu modellieren.</p> <ul> <li>Absturzausfall (Crash Failure): Der Server stoppt, hat aber bis dahin korrekt gearbeitet.</li> <li>Dienstausfall (Omission Failure): Der Server reagiert nicht auf Anfragen (entweder beim Senden oder Empfangen ausgelassen).</li> <li>Zeitbedingter Ausfall (Timing Failure): Die Antwort des Servers liegt au\u00dferhalb des festgelegten Zeitintervalls (zu fr\u00fch oder zu sp\u00e4t).</li> <li>Ausfall korrekter Antwort (Response Failure): Die Antwort des Servers ist inhaltlich falsch (falscher Wert oder falscher Zustands\u00fcbergang).</li> <li>Byzantinischer (Zuf\u00e4lliger) Ausfall (Byzantine/Arbitrary Failure): Der Server verh\u00e4lt sich v\u00f6llig unvorhersehbar, erstellt zuf\u00e4llige Antworten zu zuf\u00e4lligen Zeiten. Dies ist der schwerwiegendste und am schwierigsten zu behandelnde Fehlertyp.</li> <li>Wichtige Begriffe:<ul> <li>Fail-silent: Ein Absturz- oder Dienstausfall. Der Client wei\u00df nicht, was passiert ist.</li> <li>Fail-stop: Ein Absturzausfall, der von anderen Prozessen (z.B. per Timeout) erkannt werden kann.</li> <li>Fail-safe: Ein Ausfall, der \"gutartig\" ist und keinen Schaden anrichtet.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/#3-prozessresilienz-resilienz-durch-gruppen","title":"3. Prozessresilienz (Resilienz durch Gruppen)","text":"<p>Die grundlegende Strategie, um Prozesse fehlertolerant zu machen, ist die Replikation. Berechnungen werden auf eine Gruppe von Prozessreplikaten verteilt.</p> <ul> <li>Flache Gruppe (Flat Group):<ul> <li>Alle Mitglieder kommunizieren direkt miteinander (Peer-to-Peer).</li> <li>Vorteil: Gut f\u00fcr Fehlertoleranz, da der Informationsaustausch sofort erfolgt.</li> <li>Nachteil: Hoher Overhead und schwierig zu implementieren, da die Steuerung verteilt ist.</li> </ul> </li> <li>Hierarchische Gruppe (Hierarchical Group):<ul> <li>Die gesamte Kommunikation l\u00e4uft \u00fcber einen zentralen Koordinator.</li> <li>Vorteil: Einfach zu implementieren.</li> <li>Nachteil: Nicht wirklich fehlertolerant, da der Koordinator ein Single Point of Failure ist.</li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/#4-fehlermaskierung-und-ubereinstimmung-konsens","title":"4. Fehlermaskierung und \u00dcbereinstimmung (Konsens)","text":"<p>Fehlermaskierung bedeutet, dass eine Gruppe von Prozessen eine bestimmte Anzahl von Fehlern \"verstecken\" kann, sodass das System als Ganzes weiter funktioniert. Eine Gruppe, die \\(k\\) Fehler maskieren kann, hei\u00dft k-fehler-tolerant.</p> <p>Die zentrale Frage ist: Wie viele Replikate (\\(n\\)) braucht man, um \\(k\\) Fehler zu tolerieren?</p> <ul> <li>Bei Absturzausf\u00e4llen (Crash Failures):<ul> <li>Es werden \\(n = k + 1\\) Mitglieder ben\u00f6tigt.</li> <li>Begr\u00fcndung: Wenn \\(k\\) Prozesse ausfallen, liefert der eine verbleibende Prozess das Ergebnis.</li> </ul> </li> <li>Bei Byzantinischen Ausf\u00e4llen (Arbitrary Failures):<ul> <li>Hier ist eine Abstimmung (Voting) \u00fcber das Ergebnis n\u00f6tig.</li> <li>Fall A (mit synchronisierten Uhren): Es werden \\(n = 2k + 1\\) Mitglieder ben\u00f6tigt.<ul> <li>Begr\u00fcndung: Die \\(k+1\\) \"loyalen\" Mitglieder k\u00f6nnen die \\(k\\) \"verr\u00e4terischen\" Mitglieder \u00fcberstimmen. (z.B. Dreifach-Modulare-Redundanz, TMR).</li> </ul> </li> <li>Fall B (ohne synchronisierte Uhren / Konsensproblem): Es werden \\(n = 3k + 1\\) Mitglieder ben\u00f6tigt.<ul> <li>Begr\u00fcndung: Dies ist das Ergebnis des Byzantinischen Generalsproblems. Um \\(k\\) \"Verr\u00e4ter\" zu tolerieren, ben\u00f6tigt man \\(2k+1\\) \"loyale\" Prozesse, um eine Mehrheit unter den Loyalen zu bilden, was eine Gesamtanzahl von \\(3k+1\\) erfordert.</li> <li>Beispiel: Um \\(k=1\\) Verr\u00e4ter zu tolerieren, braucht man 4 Gener\u00e4le. Mit nur 3 Gener\u00e4len (2 Loyale, 1 Verr\u00e4ter) ist das Problem nicht l\u00f6sbar, da die Loyalen nicht wissen, wer von den beiden anderen l\u00fcgt.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/#5-ausfallerkennung-fault-detection","title":"5. Ausfallerkennung (Fault Detection)","text":"<p>Um auf Fehler reagieren zu k\u00f6nnen, m\u00fcssen sie erkannt werden. Dies geschieht typischerweise \u00fcber Timeouts.</p> <ul> <li>Pull (Ping / Probe): Prozess A sendet \"Bist du aktiv?\"-Nachrichten an Prozess B und erwartet eine Antwort.</li> <li>Push (Heartbeat): Prozess B sendet periodisch \"Ich bin aktiv\"-Nachrichten an Prozess A.</li> <li>Problem: In unzuverl\u00e4ssigen oder langsamen Netzwerken kann ein Timeout ablaufen, obwohl der Prozess gar nicht ausgefallen ist (ein falsch-positiv).</li> </ul>"},{"location":"Verteilte%20Systeme/Vorlesung/8.%20Fehlertolleranz/#6-verlassliche-kommunikation-rpc","title":"6. Verl\u00e4ssliche Kommunikation (RPC)","text":"<p>Neben Prozessen k\u00f6nnen auch Kommunikationskan\u00e4le ausfallen. Bei RPCs (Remote Procedure Calls) k\u00f6nnen 5 Hauptprobleme auftreten:</p> <ol> <li>Client findet Server nicht: Einfach, dem Client wird ein Fehler gemeldet.</li> <li>Anfrage des Clients geht verloren: Einfach, der Client sendet die Anfrage nach einem Timeout erneut.</li> <li>Server st\u00fcrzt ab: Schwierig. Der Client wei\u00df nicht, ob der Server die Operation vor oder nach dem Absturz ausgef\u00fchrt hat.</li> <li>Antwort des Servers geht verloren: Schwierig. Der Client erh\u00e4lt keine Antwort und wei\u00df nicht, ob der Server (Fall 3) oder nur die Antwort verloren ging.</li> <li>Client st\u00fcrzt ab: Schwierig. Der Server f\u00fchrt eine Operation aus, deren Ergebnis niemand mehr abholt. Dies wird als Waisenberechnung (Orphan Computation) bezeichnet.</li> </ol> <ul> <li>RPC-Semantiken (Umgang mit Fall 3 &amp; 4):<ul> <li>Mindestens-einmal-Semantik (At-least-once): Der Client sendet die Anfrage so lange, bis er eine Antwort erh\u00e4lt. Garantiert, dass die Operation ausgef\u00fchrt wird. Risiko: Mehrfache Ausf\u00fchrung.</li> <li>H\u00f6chstens-einmal-Semantik (At-most-once): Garantiert, dass eine Operation nicht mehrfach ausgef\u00fchrt wird. Risiko: Keine Ausf\u00fchrung, wenn die Antwort verloren geht und der Client nicht erneut sendet.</li> </ul> </li> <li>L\u00f6sung f\u00fcr verlorene Antworten (Fall 4): Wenn eine Operation idempotent ist (d.h. sie kann mehrfach ausgef\u00fchrt werden, ohne Schaden anzurichten, z.B. das Lesen eines Kontostands), kann der Client die Anfrage einfach erneut senden.</li> </ul>"}]}